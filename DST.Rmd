---
title: "Seizure Tracker DST analysis.Rmd"
author: "Logan Schneider"
date: "December 12, 2017"
output: html_document
---
    
    ```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown  
```{r FYI, echo=FALSE}
#print("Analyses perfomed using:")
#R.Version()$version.string
print("lubridate,zoo,ggplot2,RColorBrewer,car,agricolae")
library(lubridate)
library(zoo)
library(ggplot2)
library(RColorBrewer)
library(car)
library(agricolae)
library(scales)
print("Please use the following citation information")
citation()

sessionInfo()
```
  
Data processing  
#useful calculator: http://www.webexhibits.org/daylightsaving/b.html  
#date manipulations with POSIXct variables: https://rstudio-pubs-static.s3.amazonaws.com/28038_1bcb9aa80ca84f27ace07d612872861a.html  
#=====================================#
```{r Data processing}
#read in Sz entry dataset
#install.packages("lubridate")
#library("lubridate")
Sz <- read.csv("STFullExportMignot_20170317.csv_Seizures.txt",stringsAsFactors = F)
names(Sz)
#convert Date_Time to POSIXct format
#alternatively could use install.packages("anytime")
#library("anytime")
Sz$datetime <- as.POSIXct(Sz$Date_Time, format="%Y-%m-%d %H:%M:%S")
summary(year(Sz$datetime))
#export was March 2017, and also don't care about seizures from before origination date Dec 2007
Sz08to17 <- Sz[which(year(Sz$datetime)>2007 & year(Sz$datetime)<2018),]
summary(year(Sz08to17$datetime))
paste("Entries dropped: ",dim(Sz)[1]-dim(Sz08to17)[1]," (",round((dim(Sz)[1]-dim(Sz08to17)[1])*100/dim(Sz)[1],2),"%)",sep = "")
#create sleep period and daytime categories
#first add weekdays
Sz08to17$wkday <- weekdays(Sz08to17$datetime)
#overnight defined as 21:00-07:00, to capture the general sense of sleep periods for most individuals
Sz08to17$overnight <- ifelse(hour(Sz08to17$datetime)<7 | hour(Sz08to17$datetime)>21,1,0)
#confirm
head(Sz08to17[,c("datetime","overnight")],10)
#define the start of the overnight seizures
Sz08to17$overnightStart <- ifelse(hour(Sz08to17$datetime)<7,weekdays(Sz08to17$datetime-3600*24),ifelse(hour(Sz08to17$datetime)>21,weekdays(Sz08to17$datetime),"NA"))
#confirm
head(Sz08to17[,c("datetime","wkday","overnightStart")],10)
#define the week of the year
Sz08to17$weeknum <- isoweek(Sz08to17$datetime)
#confirm
tail(Sz08to17[,c("datetime","weeknum","wkday")],15)
#convert seizure duration to seconds only
Sz08to17$dur_secs <- Sz08to17$length_hr*3600+Sz08to17$length_min*60+Sz08to17$length_sec
#remove seizures with negative duration
Sz08to17 <- Sz08to17[which(Sz08to17$dur_secs>0),]
#confirm
head(Sz08to17[,c("length_hr","length_min","length_sec","dur_secs")],10)
summary(Sz08to17[,c("length_hr","length_min","length_sec","dur_secs")])
```
  
Adding daylight saving information for each year, using methods from:  
```{r getting DST/ST information}
#http://stackoverflow.com/questions/26226453/lubridate-get-date-of-certain-day-in-a-month  
#Most of the US begins DST at 02:00 on the second Sunday in March ends on the first Sunday in November  
#install.packages("zoo")
#library("zoo")
Sz08to17$inDST <- as.POSIXlt(Sz08to17$datetime)$isdst
#confirm
tail(Sz08to17[,c("datetime","inDST")],15)
#determine date of DSTon and DSToff for the year
#and calculate the days since either, depending upon whether in DST or not
#the multiple nested loops makes this a HUGE time commitment (12-13 hrs of processing)

###=====This one takes a little while to run=====###
for(i in 1:length(Sz08to17$datetime)) {
    if(Sz08to17[i,"inDST"]==1) {
        #this calculates the date of the preceding DST transition
        DSTon <- as.Date(ymd(paste(year(as.POSIXlt(Sz08to17[i,"datetime"])),3,01,sep="-")))
        DSTon <- as.Date(ifelse(wday(DSTon)==1,DSTon+7,DSTon+(15-wday(DSTon))))
        #this calculates the days since the preceding DST transition (relevant for analyses of first week's days: 0-6::Sun-Sat)
        Sz08to17[i,"DSTonday"] <- as.numeric(round(as.Date(Sz08to17[i,"datetime"])-as.Date(as.POSIXct(DSTon)),0))
        Sz08to17[i,"DSToffday"] <- "NA"
    } else {
        if(month(Sz08to17[i,"datetime"])>3) {
            #this calculates the date of the preceding ST transition
            DSToff <- as.Date(ymd(paste(year(as.POSIXlt(Sz08to17[i,"datetime"])),11,01,sep="-")))
            DSToff <- as.Date(ifelse(wday(DSToff)==1,DSToff,DSToff+(8-wday(DSToff))))
            #this calculates the days since the preceding ST transition (relevant for analyses of first week's days: 0-6::Sun-Sat)
            Sz08to17[i,"DSToffday"] <- as.numeric(round(as.Date(Sz08to17[i,"datetime"])-as.Date(as.POSIXct(DSToff)),0))
        } else {
            #this calculates the date of the preceding ST transition
            DSToff <- as.Date(ymd(paste(year(as.POSIXlt(Sz08to17[i,"datetime"]))-1,11,01,sep="-")))
            DSToff <- as.Date(ifelse(wday(DSToff)==1,DSToff,DSToff+(8-wday(DSToff))))
            #this calculates the days since the preceding ST transition (relevant for analyses of first week's days: 0-6::Sun-Sat)
            Sz08to17[i,"DSToffday"] <- as.numeric(round(as.Date(Sz08to17[i,"datetime"])-as.Date(as.POSIXct(DSToff)),0))
        }
        Sz08to17[i,"DSTonday"] <- "NA"
    }
}
###=====This one takes a little while to run=====###

#adding week and day number for DST/ST transitions, so can align to t0=transition time
###=====This one takes a little while to run=====###
for(i in 1:length(Sz08to17$datetime)) {
    #this calculates the date of the DST transition for the year
    DSTon <- as.Date(ymd(paste(year(as.POSIXlt(Sz08to17[i,"datetime"])),3,01,sep="-")))
    DSTon <- as.Date(ifelse(wday(DSTon)==1,DSTon+7,DSTon+(15-wday(DSTon))))
    Sz08to17[i,"DSTweek"] <- as.numeric(week(DSTon))
    Sz08to17[i,"DSTday"] <- as.numeric(yday(DSTon))
    #this calculates the date of the ST transition for the year
    DSToff <- as.Date(ymd(paste(year(as.POSIXlt(Sz08to17[i,"datetime"])),11,01,sep="-")))
    DSToff <- as.Date(ifelse(wday(DSToff)==1,DSToff,DSToff+(8-wday(DSToff))))
    Sz08to17[i,"STweek"] <- as.numeric(week(DSToff))
    Sz08to17[i,"STday"] <- as.numeric(yday(DSToff))
}
###=====This one takes a little while to run=====###
#because the addition of NAs coerced the numbers to characters, so coerce back
Sz08to17 <- transform(Sz08to17, DSTonday = as.numeric(DSTonday), DSToffday = as.numeric(DSToffday))

#should be 238 days in DST, so check
summary(Sz08to17$DSTonday)
ifelse(238>=max(Sz08to17$DSTonday,na.rm = T) & 0<=min(Sz08to17$DSTonday,na.rm = T),"expected result","needs a check")
checkON <- Sz08to17[which(Sz08to17$DSTonday==0),]
summary(Sz08to16$STday-Sz08to16$DSTday) # another verification

#conversely, there could be up to 133 days not in DST, depending upon leap years and calendar year crossings (e.g. Nov 1st, 2015 to March 13th, 2016)
summary(Sz08to17$DSToffday)
ifelse(133>=max(Sz08to17$DSToffday,na.rm = T) & 0<=min(Sz08to17$DSToffday,na.rm = T),"expected result","needs a check")
checkOFF <- Sz08to17[which(Sz08to17$DSToffday==0),]
```
  
Now to determine status epilepticus (in the event of stratified analyses)
```{r status determination}
#Define status as >5 min Sz
###=====This one takes a little while to run=====###
for(i in 1:nrow(Sz08to17)) {
    if(Sz08to17[i,"dur_secs"] > 299) {
        Sz08to17[i,"StatusYN"] <- 1
        Sz08to17[i,"Statusdur"] <- Sz08to17[i,"dur_secs"]
    } else {
        Sz08to17[i,"StatusYN"] <- 0
        Sz08to17[i,"Statusdur"] <- 0
    }
}
###=====This one takes a little while to run=====###

#OR multiple Sz with inter-Sz interval <5 min with time from start to end of all Sz >5 min
#Get the dataframe into an order in which the following algorithmic Status Epilepticus checking can work (assumes seizures entered in non-temporal order)
ordered <- Sz08to17[with(Sz08to17, order(Unlinked_ID, datetime)), ]

#define only those events <5 min apart (giving essentially 91,589 lines to look at, rather than the full 1,409,382)
###=====This one takes a while to run=====###
for(i in 2:nrow(ordered)) {
    ordered[i,"timeFROMlast"] <- as.numeric(difftime(ordered[i,"datetime"],ordered[i-1,"datetime"],units="secs"))-ordered[i-1,"dur_secs"]
}
###=====This one takes a while to run=====###
ordered[1,"timeFROMlast"] <- 0

#run through the rows of the dataframe
###=====This one takes about 1 day to run=====###
for(i in 1:(nrow(ordered)-1)) {
    #only perform this nested looping if <5 min between events (ordered by time within individuals)
    if(ordered[i+1,"timeFROMlast"] < 300 & ordered[i+1,"timeFROMlast"] > 0) {
        #start relative index for blocks of similar IDs
        j <- 1
        #if IDs are the same from current i and next entry...
        if(ordered[i,"Unlinked_ID"] == ordered[i+1,"Unlinked_ID"] & i>=j) {
            #...set ID block range from i to the end with j...
            j <- rle(ordered[i:nrow(ordered),"Unlinked_ID"])$lengths[1]
            #...then loop over the ID block
            for(k in i:i+j-1) {
                #if date is the same from current k and next entry (within the same ID block)...
                if(date(ordered[k,"datetime"]) == date(ordered[k+1,"datetime"])) {
                    #...set date block range from k to second from the end with m...
                    m <- rle(as.numeric(date(ordered[k:nrow(ordered),"datetime"])))$lengths[1]
                    #...then loop over the same-date-within-same-ID block
                    SEstart <- k
                    SEend <- k
                    while(k<m) {
                        #if the time between this and the next Sz is <5 min
                        if(ordered[k+1,"timeFROMlast"] < 300 & ordered[k+1,"timeFROMlast"] > 0) {
                            #...set the end of the the Status to the next line
                            SEend <- k+1
                        } else {
                            #...otherwise, end the Status block and calculate total duration
                            #NOTE: this will only define new Status entries if not able to create a new SEend AND the Status did iterate previously (i.e. SEstart<SEend)
                            #...set the SEstart->SEend entries to Status Yes (1)
                            #...and set all to the total "status epilepticus" duration (from start of first to end of last seizure in status series)
                            if(SEstart<SEend) {
                                for(p in SEstart:SEend) {
                                    #this makes all entries for a given status event have duration from start of SEstart's Sz to end of SEend's Sz
                                    ordered[p,"StatusYN"]<-1
                                    ordered[p,"Statusdur"]<-as.numeric(ordered[SEend,"datetime"],ordered[SEstart,"datetime"],units="secs")+ordered[SEend,"dur_secs"]
                                }
                            }
                            SEstart <- k+1
                        }
                        k <- k+1
                    }
                }
            }
        }
    }
}
###=====This one takes about 1 day to run=====###

head(ordered[,c("timeFROMlast","Unlinked_ID","datetime")],15)
tail(ordered[,c("timeFROMlast","Unlinked_ID","datetime")],15)

###################################
#####TAKES about 2.5hrs TO RUN#####
###################################
start_time <- Sys.time()
thisyeardenom <- 0
#Establishing aggregating "at risk" counts for each year, with denominator derived from unique IDs up to the end of that year
for(i in min(year(Sz08to16$datetime)):max(year(Sz08to16$datetime))) {
    denomdf <- Sz08to16[which(year(Sz08to16$datetime) <= i),"Unlinked_ID"]
    yearnumer <- length(denomdf)
    yeardenom <- length(unique(denomdf))
    Sz08to16[which(year(Sz08to16$datetime) == i),"AtRiskperYEAR"] <- yeardenom
    Sz08to16[which(year(Sz08to16$datetime) == i),"FreqperYEAR"] <- yearnumer
    Sz08to16[which(year(Sz08to16$datetime) == i),"IncidenceperYEAR"] <- yearnumer/yeardenom
    #Establishing aggregating "at risk" counts for each week, with denominator derived from unique IDs up to the end of that week
    for(j in 1:max(week(Sz08to16[which(year(Sz08to16$datetime) == i),"datetime"]))) {
        #Get the last date in the week j of year i
        endweek <- max(Sz08to16[which(year(Sz08to16$datetime) == i & week(Sz08to16$datetime) <= j),"datetime"])
        #weeklydf <- Sz08to16[which(year(Sz08to16$datetime) <= i & week(Sz08to16$datetime) <= j),"Unlinked_ID"]
        #Get Unlinked_ID list up to week j of year i
        weeklydf <- Sz08to16[which(Sz08to16$datetime <= endweek),"Unlinked_ID"]
        weeknumer <- nrow(Sz08to16[which(year(Sz08to16$datetime) == i & week(Sz08to16$datetime) == j),])
        weekdenom <- length(unique(weeklydf)) + thisyeardenom
        Sz08to16[which(year(Sz08to16$datetime) == i & week(Sz08to16$datetime) == j),"AtRiskperWEEK"] <- weekdenom
        Sz08to16[which(year(Sz08to16$datetime) == i & week(Sz08to16$datetime) == j),"FreqperWEEK"] <- weeknumer
        Sz08to16[which(year(Sz08to16$datetime) == i & week(Sz08to16$datetime) == j),"IncidenceperWEEK"] <- weeknumer/weekdenom
    }
    #Establishing aggregating "at risk" counts for each day, with denominator derived from unique IDs up to that day
    for(j in 1:max(yday(Sz08to16[which(year(Sz08to16$datetime) == i),"datetime"]))) {
        #Get the last date in the day j of year i
        endday <- max(Sz08to16[which(year(Sz08to16$datetime) == i & yday(Sz08to16$datetime) <= j),"datetime"])
        #Get Unlinked_ID list up to day j of year i
        dailydf <- Sz08to16[which(Sz08to16$datetime <= endday),"Unlinked_ID"]
        daynumer <- nrow(Sz08to16[which(year(Sz08to16$datetime) == i & yday(Sz08to16$datetime) == j),])
        daydenom <- length(unique(dailydf)) + thisyeardenom
        Sz08to16[which(year(Sz08to16$datetime) == i & yday(Sz08to16$datetime) == j),"AtRiskperDAY"] <- daydenom
        Sz08to16[which(year(Sz08to16$datetime) == i & yday(Sz08to16$datetime) == j),"FreqperDAY"] <- daynumer
        Sz08to16[which(year(Sz08to16$datetime) == i & yday(Sz08to16$datetime) == j),"IncidenceperDAY"] <- daynumer/daydenom
    }
    #This keeps a count of the aggregated count up to this year's end (for adding to next years weekly/daily counts in nested loops)
    thisyeardenom <- length(unique(denomdf))
}
Sys.time() - start_time
###################################
#####TAKES about 2.5hrs TO RUN#####
###################################

#Based on:
summary(Sz08to16[,56:64])
#it might be worth eliminating extreme incidences (though averaging and partial week elimination might help)
write.csv(Sz08to16,file="Sz08to16wIncidence.csv")

for(i in min(year(Sz08to16$datetime)):max(year(Sz08to16$datetime))) {
    yearlist <- unique(Sz08to16[which(year(Sz08to16$datetime) == i),"Unlinked_ID"])
    for(j in yearlist) {
        IDdenom <- nrow(Sz08to16[which(year(Sz08to16$datetime) == i & Sz08to16$Unlinked_ID == j),])
        Sz08to16[which(year(Sz08to16$datetime) == i & Sz08to16$Unlinked_ID == j),"UID_yearlySz"] <- IDdenom
    }
}
Sz08to16$relIncidenceperYEAR <- Sz08to16$IncidenceperYEAR/Sz08to16$UID_yearlySz
Sz08to16$relIncidenceperWEEK <- Sz08to16$IncidenceperWEEK/Sz08to16$UID_yearlySz
Sz08to16$relIncidenceperDAY <- Sz08to16$IncidenceperDAY/Sz08to16$UID_yearlySz

###################################
#####TAKES about 24hrs TO RUN#####
###################################
#Now, feature scale each individual's yearly seizures to [0-1]
scaleIDs <- unique(Sz08to16$Unlinked_ID) #get list of unique IDs
for(i in scaleIDs) {
    #Sz08to16 subset just for this individual
    scalesub <- Sz08to16[which(Sz08to16$Unlinked_ID == i),c("Unlinked_ID","datetime")]
    #adding an orderable value of format YYYY.DDD
    scalesub$year.day <- as.numeric(paste(year(scalesub$datetime),
                                          formatC(yday(scalesub$datetime),width=3,flag=0),
                                          sep="."))
    for(k in min(year(scalesub$datetime)):max(year(scalesub$datetime))) {
        #Subset for year k
        fortable <- scalesub[which(year(scalesub$datetime) == k),]
        #Get seizure counts for each day that had documented seizures by individual i in year k
        library(data.table)
        tableofi <- as.data.frame(table(yday(fortable$datetime)))
        tableofi$Var1 <- as.numeric(as.character(tableofi$Var1)) #converts days back to numeric
        library(lubridate)
        #Now with unit vector scaling, in hindsight, partitioning partial/total years was not necessary
        #NOTE: Unit scaling implicitly accounts for seizure-free days, by not pointing the unit vector into those "dimensions" anyhow
        if(k < min(year(scalesub$datetime))) { #Skip years in which the person wasn't yet documenting
        } else { #Starting with the year with individual i's first documented seizure...
            #...daily seizure counts are scaled to [0-1] based on i's yearly seizure "profusion", by making the whole year's seizure vector downscale to unit length: https://en.wikipedia.org/wiki/Feature_scaling
            tableofi$Freq <- apply(tableofi[2], MARGIN=2, FUN = function(x) {x / sqrt(sum(x^2))})
        }
        
        for(j in tableofi$Var1) {
            Sz08to16[which(Sz08to16$Unlinked_ID == i & year(Sz08to16$datetime) == k & yday(Sz08to16$datetime) == j),"ScaledSzCount"] <- tableofi[which(tableofi$Var1 == j),2][1]
        }
    }
}
###################################
#####TAKES about 24hrs TO RUN#####
###################################

for(i in min(year(Sz08to16$datetime)):max(year(Sz08to16$datetime))) {
    #Calculating "scaled" incidences using sum of individually-scaled seizure counts
    for(j in 1:max(week(Sz08to16[which(year(Sz08to16$datetime) == i),"datetime"]))) {
        #Get the scaled seizures for week j of year i
        weeklydf <- Sz08to16[which(year(Sz08to16$datetime) == i & week(Sz08to16$datetime) == j), c("Unlinked_ID","ScaledSzCount")]
        #Only use a single scaled value to account for all seizures per individual (based on definition unit vector scaling, which seeks to establish distribution of the "1 unit of seizures" an individual has per year). For comparisons of count options:
        #-nrow(weeklydf) gives the total count of seizures in week i (original $IncidenceperWEEK)
        #-sum(weeklydf$ScaledSzCount) gives the sum of all scaled seizures (with redudancy for multiseizers)
        weeknumer <- sum(unique(weeklydf$ScaledSzCount))
        #Calculates the incidence denominator of at-risk persons*time (time window is always the same, so it's not added)
        weekdenom <- mean(mean(Sz08to16[which(year(Sz08to16$datetime) == i & week(Sz08to16$datetime) == j),"AtRiskperWEEK"])) #They're all the same number, so this just gets that number
        Sz08to16[which(year(Sz08to16$datetime) == i & week(Sz08to16$datetime) == j),"scldIncidenceperWEEK"] <- weeknumer/weekdenom
    }
    #Calculating "scaled" incidences using sum of individually-scaled seizure counts
    for(j in 1:max(yday(Sz08to16[which(year(Sz08to16$datetime) == i),"datetime"]))) {
        #Get the scaled seizures for day j of year i
        dailydf <- Sz08to16[which(year(Sz08to16$datetime) == i & yday(Sz08to16$datetime) == j), c("Unlinked_ID","ScaledSzCount")]
        #Only use a single scaled value to account for all seizures per individual (based on definition unit vector scaling, which seeks to establish distribution of the "1 unit of seizures" an individual has per year). For comparisons of count options:
        #-nrow(dailydf) gives the total count of seizures in day i (original $IncidenceperDAY)
        #-sum(dailydf$ScaledSzCount) gives the sum of all scaled seizures (with redudancy for multiseizers)
        daynumer <- sum(unique(dailydf$ScaledSzCount))
        #Calculates the incidence denominator of at-risk persons*time (time window is always the same, so it's not added)
        daydenom <- mean(Sz08to16[which(year(Sz08to16$datetime) == i & yday(Sz08to16$datetime) == j),"AtRiskperDAY"]) #They're all the same number, so this just gets that number
        Sz08to16[which(year(Sz08to16$datetime) == i & yday(Sz08to16$datetime) == j),"scldIncidenceperDAY"] <- daynumer/daydenom
    }
}
    
write.csv(Sz08to16,file="Sz08to16wInc&RelRates.csv")

###NOTE: to read in the saved csv files:
###Sz08to16 <- read.csv("Sz08to16wInc&RelRates.csv", stringsAsFactors = F)
###Sz08to16 <- Sz08to16[,-1]
###Sz08to16$datetime <- as.POSIXct(Sz08to16$datetime)

###CLEANED THE DATA: https://docs.google.com/document/d/1-hO9j-3Zj9mUBu6ukHHilunIDDx_0U7cExPqzt5BA8w/edit?ts=58d2cd60
#personal notes on specifics to my analysis (but check/clean on all aspects in Google)
#May need to do "Sz pos" analysis for those with neg durations, as they comprise about 20% of the data
```
  
Day and Night seizure counts  
```{r Day vs Night split of dataset}
Day08to16 <- Sz08to16[which(Sz08to16$overnight == 0),]
Night08to16 <- Sz08to16[which(Sz08to16$overnight == 1),]

###################################
#####TAKES about 24hrs TO RUN#####
###################################
#Now, feature scale each individual's yearly seizures to [0-1]
scaleIDs <- unique(Day08to16$Unlinked_ID) #get list of unique IDs
for(i in scaleIDs) {
    #Day08to16 subset just for this individual
    scalesub <- Day08to16[which(Day08to16$Unlinked_ID == i),c("Unlinked_ID","datetime")]
    #adding an orderable value of format YYYY.DDD
    scalesub$year.day <- as.numeric(paste(year(scalesub$datetime),
                                          formatC(yday(scalesub$datetime),width=3,flag=0),
                                          sep="."))
    for(k in min(year(scalesub$datetime)):max(year(scalesub$datetime))) {
        #Subset for year k
        fortable <- scalesub[which(year(scalesub$datetime) == k),]
        #Get seizure counts for each day that had documented seizures by individual i in year k
        library(data.table)
        tableofi <- as.data.frame(table(yday(fortable$datetime)))
        tableofi$Var1 <- as.numeric(as.character(tableofi$Var1)) #converts days back to numeric
        library(lubridate)
        #Now with unit vector scaling, in hindsight, partitioning partial/total years was not necessary
        #NOTE: Unit scaling implicitly accounts for seizure-free days, by not pointing the unit vector into those "dimensions" anyhow
        if(k < min(year(scalesub$datetime))) { #Skip years in which the person wasn't yet documenting
        } else { #Starting with the year with individual i's first documented seizure...
            #...daily seizure counts are scaled to [0-1] based on i's yearly seizure "profusion", by making the whole year's seizure vector downscale to unit length: https://en.wikipedia.org/wiki/Feature_scaling
            tableofi$Freq <- apply(tableofi[2], MARGIN=2, FUN = function(x) {x / sqrt(sum(x^2))})
        }
        
        for(j in tableofi$Var1) {
            Day08to16[which(Day08to16$Unlinked_ID == i & year(Day08to16$datetime) == k & yday(Day08to16$datetime) == j),"DAYScaledSzCount"] <- tableofi[which(tableofi$Var1 == j),2][1]
        }
    }
}
###################################
#####TAKES about 24hrs TO RUN#####
###################################

for(i in min(year(Day08to16$datetime)):max(year(Day08to16$datetime))) {
    #Calculating "scaled" incidences using sum of individually-scaled seizure counts
    for(j in 1:max(week(Day08to16[which(year(Day08to16$datetime) == i),"datetime"]))) {
        #Get the scaled seizures for week j of year i
        weeklydf <- Day08to16[which(year(Day08to16$datetime) == i & week(Day08to16$datetime) == j), c("Unlinked_ID","ScaledSzCount")]
        #Only use a single scaled value to account for all seizures per individual (based on definition unit vector scaling, which seeks to establish distribution of the "1 unit of seizures" an individual has per year). For comparisons of count options:
        #-nrow(weeklydf) gives the total count of seizures in week i (original $IncidenceperWEEK)
        #-sum(weeklydf$ScaledSzCount) gives the sum of all scaled seizures (with redudancy for multiseizers)
        weeknumer <- sum(unique(weeklydf$ScaledSzCount))
        #Calculates the incidence denominator of at-risk persons*time (time window is always the same, so it's not added)
        weekdenom <- mean(mean(Day08to16[which(year(Day08to16$datetime) == i & week(Day08to16$datetime) == j),"AtRiskperWEEK"])) #They're all the same number, so this just gets that number
        Day08to16[which(year(Day08to16$datetime) == i & week(Day08to16$datetime) == j),"scldIncidenceperWEEK"] <- weeknumer/weekdenom
    }
    #Calculating "scaled" incidences using sum of individually-scaled seizure counts
    for(j in 1:max(yday(Day08to16[which(year(Day08to16$datetime) == i),"datetime"]))) {
        #Get the scaled seizures for day j of year i
        dailydf <- Day08to16[which(year(Day08to16$datetime) == i & yday(Day08to16$datetime) == j), c("Unlinked_ID","ScaledSzCount")]
        #Only use a single scaled value to account for all seizures per individual (based on definition unit vector scaling, which seeks to establish distribution of the "1 unit of seizures" an individual has per year). For comparisons of count options:
        #-nrow(dailydf) gives the total count of seizures in day i (original $IncidenceperDAY)
        #-sum(dailydf$ScaledSzCount) gives the sum of all scaled seizures (with redudancy for multiseizers)
        daynumer <- sum(unique(dailydf$ScaledSzCount))
        #Calculates the incidence denominator of at-risk persons*time (time window is always the same, so it's not added)
        daydenom <- mean(Day08to16[which(year(Day08to16$datetime) == i & yday(Day08to16$datetime) == j),"AtRiskperDAY"]) #They're all the same number, so this just gets that number
        Day08to16[which(year(Day08to16$datetime) == i & yday(Day08to16$datetime) == j),"scldIncidenceperDAY"] <- daynumer/daydenom
    }
}
    
write.csv(Day08to16,file="DAY08to16wInc&RelRates.csv")

###################################
#####TAKES about 24hrs TO RUN#####
###################################
#Now, feature scale each individual's yearly seizures to [0-1]
scaleIDs <- unique(Night08to16$Unlinked_ID) #get list of unique IDs
for(i in scaleIDs) {
    #Night08to16 subset just for this individual
    scalesub <- Night08to16[which(Night08to16$Unlinked_ID == i),c("Unlinked_ID","datetime")]
    #adding an orderable value of format YYYY.DDD
    scalesub$year.day <- as.numeric(paste(year(scalesub$datetime),
                                          formatC(yday(scalesub$datetime),width=3,flag=0),
                                          sep="."))
    for(k in min(year(scalesub$datetime)):max(year(scalesub$datetime))) {
        #Subset for year k
        fortable <- scalesub[which(year(scalesub$datetime) == k),]
        #Get seizure counts for each day that had documented seizures by individual i in year k
        library(data.table)
        tableofi <- as.data.frame(table(yday(fortable$datetime)))
        tableofi$Var1 <- as.numeric(as.character(tableofi$Var1)) #converts days back to numeric
        library(lubridate)
        #Now with unit vector scaling, in hindsight, partitioning partial/total years was not necessary
        #NOTE: Unit scaling implicitly accounts for seizure-free days, by not pointing the unit vector into those "dimensions" anyhow
        if(k < min(year(scalesub$datetime))) { #Skip years in which the person wasn't yet documenting
        } else { #Starting with the year with individual i's first documented seizure...
            #...daily seizure counts are scaled to [0-1] based on i's yearly seizure "profusion", by making the whole year's seizure vector downscale to unit length: https://en.wikipedia.org/wiki/Feature_scaling
            tableofi$Freq <- apply(tableofi[2], MARGIN=2, FUN = function(x) {x / sqrt(sum(x^2))})
        }
        
        for(j in tableofi$Var1) {
            Night08to16[which(Night08to16$Unlinked_ID == i & year(Night08to16$datetime) == k & yday(Night08to16$datetime) == j),"NIGHTScaledSzCount"] <- tableofi[which(tableofi$Var1 == j),2][1]
        }
    }
}
###################################
#####TAKES about 24hrs TO RUN#####
###################################

for(i in min(year(Night08to16$datetime)):max(year(Night08to16$datetime))) {
    #Calculating "scaled" incidences using sum of individually-scaled seizure counts
    for(j in 1:max(week(Night08to16[which(year(Night08to16$datetime) == i),"datetime"]))) {
        #Get the scaled seizures for week j of year i
        weeklydf <- Night08to16[which(year(Night08to16$datetime) == i & week(Night08to16$datetime) == j), c("Unlinked_ID","ScaledSzCount")]
        #Only use a single scaled value to account for all seizures per individual (based on definition unit vector scaling, which seeks to establish distribution of the "1 unit of seizures" an individual has per year). For comparisons of count options:
        #-nrow(weeklydf) gives the total count of seizures in week i (original $IncidenceperWEEK)
        #-sum(weeklydf$ScaledSzCount) gives the sum of all scaled seizures (with redudancy for multiseizers)
        weeknumer <- sum(unique(weeklydf$ScaledSzCount))
        #Calculates the incidence denominator of at-risk persons*time (time window is always the same, so it's not added)
        weekdenom <- mean(mean(Night08to16[which(year(Night08to16$datetime) == i & week(Night08to16$datetime) == j),"AtRiskperWEEK"])) #They're all the same number, so this just gets that number
        Night08to16[which(year(Night08to16$datetime) == i & week(Night08to16$datetime) == j),"scldIncidenceperWEEK"] <- weeknumer/weekdenom
    }
    #Calculating "scaled" incidences using sum of individually-scaled seizure counts
    for(j in 1:max(yday(Night08to16[which(year(Night08to16$datetime) == i),"datetime"]))) {
        #Get the scaled seizures for day j of year i
        dailydf <- Night08to16[which(year(Night08to16$datetime) == i & yday(Night08to16$datetime) == j), c("Unlinked_ID","ScaledSzCount")]
        #Only use a single scaled value to account for all seizures per individual (based on definition unit vector scaling, which seeks to establish distribution of the "1 unit of seizures" an individual has per year). For comparisons of count options:
        #-nrow(dailydf) gives the total count of seizures in day i (original $IncidenceperDAY)
        #-sum(dailydf$ScaledSzCount) gives the sum of all scaled seizures (with redudancy for multiseizers)
        daynumer <- sum(unique(dailydf$ScaledSzCount))
        #Calculates the incidence denominator of at-risk persons*time (time window is always the same, so it's not added)
        daydenom <- mean(Night08to16[which(year(Night08to16$datetime) == i & yday(Night08to16$datetime) == j),"AtRiskperDAY"]) #They're all the same number, so this just gets that number
        Night08to16[which(year(Night08to16$datetime) == i & yday(Night08to16$datetime) == j),"scldIncidenceperDAY"] <- daynumer/daydenom
    }
}
    
write.csv(Night08to16,file="NIGHT08to16wInc&RelRates.csv")
```
  
Data imaging and analysis   
#====================================#  
```{r yearly data summaries}
#examine by year; source method: http://stackoverflow.com/questions/2127926/how-do-i-highlight-an-observations-bin-in-a-histogram-in-r
highlight <- function(x, value1, value2, col.value1, col.value2, col=NA, ...){
    hst <- hist(x, ...)
    idx1 <- findInterval(value1, hst$breaks)
    idx2 <- findInterval(value2, hst$breaks)
    cols <- rep(col, length(hst$counts))
    cols[idx1] <- col.value1
    cols[idx2] <- col.value2
    hist(x, col=cols, ...)
}
for(i in 2008:2017) {
    DSTon <- as.Date(ymd(paste(i,3,01,sep="-")))
    DSTon <- as.Date(ifelse(wday(DSTon)==1,DSTon+7,DSTon+(15-wday(DSTon))))
    DSToff <- as.Date(ymd(paste(i,11,01,sep="-")))
    DSToff <- as.Date(ifelse(wday(DSToff)==1,DSToff,DSToff+(8-wday(DSToff))))
    Szwks <- week(ordered[which(year(ordered$datetime)==i),"datetime"])
    highlight(Szwks,week(DSTon),week(DSToff),"red","blue",breaks=week(as.POSIXct(paste(i,12,31,sep="-"))),main=paste("Histogram of seizure counts for ",i,sep=""))
}

#plot aggregate data from complete years: 2008-2016
#-normalize week of DST transition to 0
Sz08to16 <- ordered[which(year(ordered$datetime)<2017),]
Szwks<-week(Sz08to16[,"datetime"])-Sz08to16[,"DSTweek"]
#-plot with highlights
highlight(Szwks,0,34,"red","blue",breaks=53,main="Histogram of seizure counts for Jan 2008-Dec 2016")
```
  
Subsetting datasets for DST and baseline time windows
```{r data subsetting}
#Make relevant dataframes for comparison:
#-the week of DST (DSTonday 0-6: Sun-Sat)
Sz08to16wkofDST <- Sz08to16[which(Sz08to16$DSTonday >= 0 & Sz08to16$DSTonday < 7),] #only includes DST-week days
summary(Sz08to16wkofDST$DSTonday)
wkofDST <- table(Sz08to16wkofDST$wkday)
recombobulate <- c(4,2,6,7,5,1,3) #needed to reorder the alphabetical ordering default of table
barplot(wkofDST[recombobulate])
str(Sz08to16wkofDST$DSTonday)
#-the week before DST (a control time period)
Sz08to16wkpreDST <- Sz08to16[which((yday(Sz08to16$datetime) >= Sz08to16$DSTday-7 ) & (yday(Sz08to16$datetime) < Sz08to16$DSTday-0 ) ),] #only includes days in week before DST
summary(yday(Sz08to16wkpreDST$datetime))
summary(Sz08to16$DSTday)
wkpreDST <- table(Sz08to16wkpreDST$wkday)
recombobulate <- c(4,2,6,7,5,1,3) #needed to reorder the alphabetical ordering default of table
barplot(wkpreDST[recombobulate])
str(yday(Sz08to16wkpreDST$datetime))
#-the week following DST week (a control time period)
Sz08to16wkpostDST <- Sz08to16[which(Sz08to16$DSTonday >= 7 & Sz08to16$DSTonday < 14),] #only includes days in week following DST week
summary(yday(Sz08to16wkpostDST$datetime))
summary(Sz08to16$DSTday)
wkpostDST <- table(Sz08to16wkpostDST$wkday)
recombobulate <- c(4,2,6,7,5,1,3) #needed to reorder the alphabetical ordering default of table
barplot(wkpostDST[recombobulate])
str(yday(Sz08to16wkpostDST$datetime))
#-the week of ST (STonday 0-6: Sun-Sat) (a control time period, or primary time period)
Sz08to16wkofST <- Sz08to16[which(Sz08to16$DSToffday >= 0 & Sz08to16$DSToffday < 7),] #only includes ST-week days
summary(Sz08to16wkofST$DSToffday)
wkofST <- table(Sz08to16wkofST$wkday)
recombobulate <- c(4,2,6,7,5,1,3) #needed to reorder the alphabetical ordering default of table
barplot(wkofST[recombobulate])
str(Sz08to16wkofST$DSToffday)
#-the week before ST (a control time period)
Sz08to16wkpreST <- Sz08to16[which(Sz08to16$DSTonday > 231 & Sz08to16$DSTonday <= 238),] #only includes days in week before ST week
summary(yday(Sz08to16wkpreST$datetime))
summary(Sz08to16$STday)
wkpreST <- table(Sz08to16wkpreST$wkday)
recombobulate <- c(4,2,6,7,5,1,3) #needed to reorder the alphabetical ordering default of table
barplot(wkpreST[recombobulate])
str(yday(Sz08to16wkpreST$datetime))
#-the week following ST week (a control time period)
Sz08to16wkpostST <- Sz08to16[which(Sz08to16$DSToffday >= 7 & Sz08to16$DSToffday < 14),] #only includes days in week following ST week
summary(yday(Sz08to16wkpostST$datetime))
summary(Sz08to16$STday)
wkpostST <- table(Sz08to16wkpostST$wkday)
recombobulate <- c(4,2,6,7,5,1,3) #needed to reorder the alphabetical ordering default of table
barplot(wkpostST[recombobulate])
str(yday(Sz08to16wkpostST$datetime))
#-NOT week of DST (a control time period)
Sz08to16notDST <- Sz08to16[which(Sz08to16$DSTonday >= 7 | Sz08to16$DSToffday >=0),] #includes all non-DST-week days and all ST days
summary(yday(Sz08to16notDST$datetime))
notDST <- table(Sz08to16notDST$wkday)
recombobulate <- c(4,2,6,7,5,1,3) #needed to reorder the alphabetical ordering default of table
barplot(notDST[recombobulate])
str(yday(Sz08to16notDST$datetime))
```
  
Comparisons to baseline windows  
###ANALYZED AS SO: chi square by day of the week, T-test (two tailed) by average day of the week, ORs
```{r initial comparisons for chi-square}
DSTvsPRE <- data.frame("wkofDST"=as.data.frame(wkofDST[recombobulate])[,2],"wkpreDST"=as.data.frame(wkpreDST[recombobulate])[,2])
rownames(DSTvsPRE) <- c("Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday")
chisq.test(DSTvsPRE)
barplot(t(DSTvsPRE),legend=T,beside=T)

DSTvsST <- data.frame("wkofDST"=as.data.frame(wkofDST[recombobulate])[,2],"wkofST"=as.data.frame(wkofST[recombobulate])[,2])
rownames(DSTvsST) <- c("Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday")
chisq.test(DSTvsST)
barplot(t(DSTvsST),legend=T,beside=T)
```
  
Calculate Z-scores and percentile for DST seizure mean using the whole of population data as the "normative baseline"  
```{r zscore comparisons and independent t-tests comparing DST to any non-DST baseline weekday}
dailypercentiles <- data.frame("Weekday"=character(),
                               "MeanPercentile"=numeric(),
                               "PercentileSD"=numeric(),
                               stringsAsFactors = F)
sigdf <- data.frame("Weekday"=character(),
                    "p"=numeric(),
                    "p.signif"=character(),
                    stringsAsFactors = F)
percentalls <- data.frame("Year"=numeric(),
                          "Percentile"=numeric(),
                          "Weekday"=character(),
                          stringsAsFactors = F)
yearlist <- c(min(year(Sz08to16$datetime)):max(year(Sz08to16$datetime))) #Bound years by the bounds of the dataset
list <- c("Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday")
index=1
for(i in list) {
    yearlyDSTdf <- data.frame("Year"=numeric(),
                              "PopMean"=numeric(),
                              "PopSD"=numeric(),
                              "SzCount"=numeric(),
                              "Zscore"=numeric(),
                              "Percentile"=numeric())
    counter=1
    for(j in yearlist) {
        daymean <- mean(table(as.Date(Sz08to16[which(Sz08to16$wkday == i & year(Sz08to16$datetime) == j),"datetime"],
                                      'America/Los_Angeles')))
        yearlyDSTdf[counter,"PopMean"] <- daymean
        daysd <- sd(table(as.Date(Sz08to16[which(Sz08to16$wkday == i & year(Sz08to16$datetime) == j),"datetime"],
                                  'America/Los_Angeles')))
        yearlyDSTdf[counter,"PopSD"] <- daysd
        yearlyDSTdf[counter,"Year"] <- j
        yearlyDSTdf[counter,"SzCount"] <- table(as.Date(Sz08to16wkofDST[which(Sz08to16wkofDST$wkday == i & year(Sz08to16wkofDST$datetime) == j),"datetime"],
                                                        'America/Los_Angeles'))[[1]]
        yearlyDSTdf[counter,"Zscore"] <- (yearlyDSTdf[counter,"SzCount"] - daymean)/daysd
        yearlyDSTdf[counter,"Percentile"] <- round(pnorm(yearlyDSTdf[counter,"Zscore"])*100,2)
        counter=counter+1
    }
    FORtall <- yearlyDSTdf[,c("Year","Percentile")]
    FORtall$Weekday <- i
    percentalls <- rbind(percentalls,FORtall)
    write.table(yearlyDSTdf,
                file = paste(i,"yearly percentiles.txt"),
                quote = F,
                row.names = F)
    
    dailypercentiles[index,"Weekday"] <- i
    dailypercentiles[index,"MeanPercentile"] <- mean(yearlyDSTdf$Percentile)
    dailypercentiles[index,"PercentileSD"] <- sd(yearlyDSTdf$Percentile)/sqrt(max(year(Sz08to16$datetime))-min(year(Sz08to16$datetime)))
    
    sigdf[index,"Weekday"] <- i
    sigdf[index,"p"] <- round(t.test(table(as.Date(firstweek[which(firstweek$wkday == i),"datetime"],'America/Los_Angeles')),
                                     table(as.Date(secondweek[which(secondweek$wkday == i),"datetime"],'America/Los_Angeles')))[["p.value"]],4)
    if(sigdf[index,"p"]<0.05 & sigdf[index,"p"]>0.01) {
        sigdf[index,"p.signif"] <- "*"
    } else if(sigdf[index,"p"]<0.01 & sigdf[index,"p"]>0.001) {
        sigdf[index,"p.signif"] <- "**"
    } else if(sigdf[index,"p"]<0.001) {
        sigdf[index,"p.signif"] <- "***"
    } else {
        sigdf[index,"p.signif"] <- "ns"
    }
    
    index=index+1
}
dailypercentiles$Weekday <- factor(dailypercentiles$Weekday, levels = dailypercentiles$Weekday) #ensures weekdays stay in order Sun-Sat
dailypercentiles
factorlevels <- factor(list,levels=list)
percentalls$Weekday <- factor(percentalls$Weekday, levels=factorlevels) #ensures weekdays stay in order Sun-Sat

#library(ggplot2)

ggplot(dailypercentiles, aes(x=Weekday, y=MeanPercentile)) + 
    geom_bar(position=position_dodge(), stat="identity",
             colour="black", # Use black outlines,
             size=.3,  # Thinner lines
             alpha=0.8) +  #Semi-transparent
    #stat_compare_means(aes(group = Week), label = "p.signif", label.y = 300)
    geom_errorbar(aes(ymin=MeanPercentile-PercentileSD, ymax=MeanPercentile+PercentileSD),
                  size=.3,    # Thinner lines
                  width=.2,
                  position=position_dodge(.9)) +
    geom_point(data=percentalls, aes(x=Weekday, y=Percentile, color=factor(Year)), size=3, alpha=0.8) + 
    xlab("Weekday") +
    ylab("Percentile (± SEM)") +
    ggtitle(paste("Percentile of DST seizure counts by weekday over period from",min(year(Sz08to16$datetime)),"to",max(year(Sz08to16$datetime)))) +
    scale_y_continuous(breaks=0:100*10, limits=c(0,100)) +
    theme_bw() + 
    theme(legend.title = element_blank())
png(paste("Percentile of DST seizure counts by weekday over period from ",min(year(Sz08to16$datetime))," to ",max(year(Sz08to16$datetime)),".png",sep=""), 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
print(ggplot(dailypercentiles, aes(x=Weekday, y=MeanPercentile)) + 
    geom_bar(position=position_dodge(), stat="identity",
             colour="black", # Use black outlines,
             size=.3) +      # Thinner lines
    #stat_compare_means(aes(group = Week), label = "p.signif", label.y = 300)
    geom_errorbar(aes(ymin=MeanPercentile-PercentileSD, ymax=MeanPercentile+PercentileSD),
                  size=.3,    # Thinner lines
                  width=.2,
                  position=position_dodge(.9)) +
    xlab("Weekday") +
    ylab("Percentile (± SEM)") +
    ggtitle(paste("Percentile of DST seizure counts by weekday over period from",min(year(Sz08to16$datetime)),"to",max(year(Sz08to16$datetime)))) +
    scale_y_continuous(breaks=0:100*10) +
    theme_bw())
dev.off()
```
  
Check seizure weekday percentiles for DST by ANOVA
```{r ANOVA of DST percentiles by weekday}
attach(percentalls)
Anova(lm(Percentile ~ Weekday,
         data=percentalls),
      type="III")
wkday2percentile <- aov(lm(Percentile ~ Weekday))
wkday2percentile
posthoc <- TukeyHSD(x=wkday2percentile, 'Weekday', conf.level = 0.95)
posthoc
hsdwkday2percentile <- HSD.test(wkday2percentile, "Weekday")
hsdwkday2percentile
```
It appears that Saturday is in a group all it's own (by DST percentiles)...and that it's somewhat protective  
Also, the periweekend days (Fri, Sat, and Sun) appear to be somewhat distinct as well  

###Is the "Weekend protective effect" present throughout the year?
```{r weekday counts for the whole dataset}
weekendlist <- c("Wednesday","Thursday","Friday","Saturday","Sunday","Monday","Tuesday")
#factorlevels <- factor(list,levels=weekendlist) 
factorlevels <- factor(weekendlist, levels = weekendlist) # setting factor levels to put weekend in middle of graphs
#wkdayrefactored <- Sz08to16
#wkdayrefactored$wkday <- factor(wkdayrefactored$wkday, levels=factorlevels)
#totANOVA <- as.data.frame(table(wkdayrefactored$wkday))
totANOVA <- as.data.frame(table(Sz08to16$wkday))
totANOVA$Var1 <- factor(totANOVA$Var1, levels=factorlevels)
#Just take a look at total seizure counts over the whole period

ggplot(totANOVA, aes(x=Var1, y=Freq)) + 
    geom_histogram(stat="identity") +
    xlab("Weekday") + 
    ylab("Total seizure counts") + 
    scale_y_continuous(breaks = c(round(min(totANOVA$Freq),digits=-3),round(max(totANOVA$Freq),digits=-3))) + 
    #ylim(round(min(totANOVA$Freq),digits=-3),round(max(totANOVA$Freq),digits=-3)) +
    ggtitle(paste("Total weekday seizure counts over",min(year(Sz08to16$datetime)),"to",max(year(Sz08to16$datetime)))) + 
    theme_bw() + 
    theme(legend.position = "none")

ggplot(totANOVA, aes(x=Var1, y=Freq)) + 
    geom_point(size=3) +
    ylab("Total seizure counts") +
    ggtitle(paste("Total weekday seizure counts over",min(year(Sz08to16$datetime)),"to",max(year(Sz08to16$datetime)))) + 
    theme_bw() + 
    theme(legend.position = "none",
          axis.title.x = element_blank())
png("Weekday count totals from entire dataset.png", 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
print(ggplot(totANOVA, aes(x=Var1, y=Freq)) + 
    geom_point(size=3) +
    ylab("Total seizure counts") +
    ggtitle(paste("Total weekday seizure counts over",min(year(Sz08to16$datetime)),"to",max(year(Sz08to16$datetime)))) + 
    theme_bw() + 
    theme(legend.position = "none",
          axis.title.x = element_blank()))
dev.off()
```
Seems like there might be a protective pattern for the weekends  
  
#First check ANOVA by yearly counts as a coarse estimate
```{r ANOVA by yearly count totals for each weekday}
tabling <- Sz08to16[,c("wkday","datetime")]
tabling$datetime <- year(tabling$datetime)
tabling$wkday <- factor(tabling$wkday, levels=factorlevels)
table(tabling)
#barplot(table(tabling),
#        col=brewer.pal(n=7,"Accent"),
#        legend.text=T,
#        args.legend=list(x="topleft"),
#        beside=T)
par(mar = c(5,4,4,8))
barplot(table(tabling),
        col=brewer.pal(n=7,"Accent"),
        legend.text=T,
        args.legend = list(x = "right", bty="n", inset=c(-0.3,0), xpd = TRUE),
        ylab = "Total seizure counts per weekday",
        beside=T)
png(paste("Weekday count totals from ",min(year(Sz08to16$datetime))," to ",max(year(Sz08to16$datetime)),".png",sep=""), 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
par(mar = c(5,4,4,8))
barplot(table(tabling),
        col=brewer.pal(n=7,"Accent"),
        legend.text=T,
        args.legend = list(x = "right", bty="n", inset=c(-0.2,0), xpd = TRUE),
        ylab = "Total seizure counts per weekday",
        beside=T)
dev.off()

#Now doing it by proportion:

#Legend location: https://coders-corner.net/2016/03/06/data-visualization-in-r-show-legend-outside-of-the-plotting-area/
par(mar = c(5,4,4,8))
barplot(prop.table(table(tabling),margin=2),
        col=brewer.pal(n=7,"Accent"),
        legend.text=T,
        args.legend = list(x = "right", bty="n", inset=c(-0.3,0), xpd = TRUE),
        ylab = "Proportion of yearly seizure counts",
        beside=T)
png(paste("Weekday count proportions from ",min(year(Sz08to16$datetime))," to ",max(year(Sz08to16$datetime)),".png",sep=""), 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
par(mar = c(5,4,4,8))
barplot(prop.table(table(tabling),margin=2),
        col=brewer.pal(n=7,"Accent"),
        legend.text=T,
        args.legend = list(x = "right", bty="n", inset=c(-0.2,0), xpd = TRUE),
        ylab = "Proportion of yearly seizure counts",
        beside=T)
dev.off()

yearANOVA <- as.data.frame(table(tabling))
attach(yearANOVA)
Anova(lm(Freq ~ wkday,
         data=yearANOVA),
      type="III")
day2countYEAR <- aov(lm(Freq ~ wkday))
day2countYEAR
posthoc <- TukeyHSD(x=day2countYEAR, 'wkday', conf.level = 0.95)
posthoc
hsdday2countYEAR <- HSD.test(day2countYEAR, "wkday")
hsdday2countYEAR
```
Based on looking at those yearly counts, still seems like a plausible hypothesis  
  
#Now check ANOVA by weekly counts (more granular and less subject to varying/accruing subject counts over the year)
```{r ANOVA by weekly counts in each year}
tabling <- Sz08to16[,c("wkday","weeknum")]
summary(tabling)
#Because first (1st) and last weeks (52nd or 53rd) can be partial weeks, will remove so as not to bias averages for given weekdays
tabling <- tabling[which(tabling$weeknum > 1 & tabling$weeknum < 52),]
summary(tabling)

summary(Sz08to16$weeknum)
#Because first (1st) and last weeks (52nd or 53rd) can be partial weeks, will remove so as not to bias averages for given weekdays
FORtabling <- Sz08to16[which(Sz08to16$weeknum > 1 & Sz08to16$weeknum < 52),c("wkday","datetime","weeknum")]
summary(FORtabling$weeknum)
FORtabling$Date <- as.Date(FORtabling$datetime) #,'America/Los_Angeles'
summary(FORtabling$Date)
tabling <- FORtabling[,c("wkday","Date")]
tabling$wkday <- factor(tabling$wkday, levels=factorlevels)
#table(tabling)
weekdANOVA <- as.data.frame(table(tabling))
weekdANOVA$Date <- as.POSIXct(weekdANOVA$Date)
weekdANOVA <- weekdANOVA[which(weekdays(weekdANOVA$Date) == weekdANOVA$wkday),] #due to how table works, need to only keep counts for actual dat-weekday matches
weekdANOVA$Year <- year(weekdANOVA$Date)
ggplot() + 
    geom_boxplot(data=weekdANOVA, aes(x=wkday, y=Freq), fill="#4271AE", alpha=0.5, outlier.size=NA,na.rm=T) + #Avoid duplicate outlier plotting
    geom_jitter(data=weekdANOVA, aes(x=wkday,y=Freq,color=factor(Year)), position=position_jitter(width=0.05), alpha=0.8,na.rm=T) + #Outliers from incomplete weeks
    #geom_point(data=weekdANOVA, aes(x=wkday, y=Freq, color=factor(Year)), alpha=1, size=3) +
    geom_hline(yintercept = mean(weekdANOVA$Freq,na.rm=T)) + 
    geom_hline(yintercept = c(mean(weekdANOVA$Freq,na.rm=T)+1.96*sd(weekdANOVA$Freq,na.rm=T),
                              mean(weekdANOVA$Freq,na.rm=T)-1.96*sd(weekdANOVA$Freq,na.rm=T)),
               linetype=3) + 
    ylim((mean(weekdANOVA$Freq,na.rm=T)-2*sd(weekdANOVA$Freq,na.rm=T)),(mean(weekdANOVA$Freq,na.rm=T)+2*sd(weekdANOVA$Freq,na.rm=T))) + 
    xlab("Weekday") +
    ylab("Weekly seizure counts") +
    ggtitle("Weekly seizure counts, aggregated by day of the week") + 
    theme_bw() + 
    theme(legend.title = element_blank())
png(paste("Weekday seizure counts, aggregated by day of the week, from ",min(year(Sz08to16$datetime))," to ",max(year(Sz08to16$datetime)),".png",sep=""), 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
print(ggplot() + 
    geom_boxplot(data=weekdANOVA, aes(x=wkday, y=Freq), fill="#4271AE", alpha=0.5, outlier.size=NA,na.rm=T) + #Avoid duplicate outlier plotting
    geom_jitter(data=weekdANOVA, aes(x=wkday,y=Freq,color=factor(Year)), position=position_jitter(width=0.05), alpha=0.8,na.rm=T) + #Outliers from incomplete weeks
    #geom_point(data=weekdANOVA, aes(x=wkday, y=Freq, color=factor(Year)), alpha=1, size=3) +
    geom_hline(yintercept = mean(weekdANOVA$Freq,na.rm=T)) + 
    geom_hline(yintercept = c(mean(weekdANOVA$Freq,na.rm=T)+1.96*sd(weekdANOVA$Freq,na.rm=T),
                              mean(weekdANOVA$Freq,na.rm=T)-1.96*sd(weekdANOVA$Freq,na.rm=T)),
               linetype=3) + 
    ylim((mean(weekdANOVA$Freq,na.rm=T)-2*sd(weekdANOVA$Freq,na.rm=T)),(mean(weekdANOVA$Freq,na.rm=T)+2*sd(weekdANOVA$Freq,na.rm=T))) + 
    xlab("Weekday") +
    ylab("Weekly seizure counts") +
    ggtitle("Weekly seizure counts, aggregated by day of the week") + 
    theme_bw() + 
    theme(legend.title = element_blank()))
dev.off()
attach(weekdANOVA)
Anova(lm(Freq ~ wkday,
         data=weekdANOVA),
      type="III")
day2countWEEK <- aov(lm(Freq ~ wkday))
day2countWEEK
posthoc <- TukeyHSD(x=day2countWEEK, 'wkday', conf.level = 0.95)
posthoc
hsdday2countWEEK <- HSD.test(day2countWEEK, "wkday")
hsdday2countWEEK
```
Doesn't look like there is a trend in aggregate...  
  
#But the high variance introduced by recruitment may dilute the variation when comparing more stable at-risk population counts (i.e. over a given year)
```{r parse out by year}
p <- ggplot() 
for(i in min(year(Sz08to16$datetime)):max(year(Sz08to16$datetime))) {
    p <- p + geom_boxplot(data=weekdANOVA[which(weekdANOVA[,"Year"] == i),],
                 aes(x=wkday, y=Freq),
                 fill=brewer.pal(n=(max(year(Sz08to16$datetime))-min(year(Sz08to16$datetime))),"Paired")[i-2007],
                 alpha=0.2,
                 outlier.size=NA, #Avoid duplicate outlier plotting
                 notch = T, #Enhance visibility
                 na.rm=T)
    p <- p + geom_jitter(data=weekdANOVA[which(weekdANOVA[,"Year"] == i),],
                aes(x=wkday,y=Freq),
                color=brewer.pal(n=(max(year(Sz08to16$datetime))-min(year(Sz08to16$datetime))),"Paired")[i-2007],
                position=position_jitter(width=0.05),
                alpha=0.8,
                na.rm=T)#Outliers from incomplete weeks
}
p <- p + 
    ylim((mean(weekdANOVA$Freq,na.rm=T)-2*sd(weekdANOVA$Freq,na.rm=T)),(mean(weekdANOVA$Freq,na.rm=T)+2*sd(weekdANOVA$Freq,na.rm=T))) + 
    xlab("Weekday") +
    ylab("Weekly seizure counts") +
    ggtitle("Weekly seizure counts, aggregated by day of the week, separated by year") + 
    theme_bw()
p
print(p)

#That was a little messy, but it looks like the yearly pattern may be there, so plot them (and do ANOVA) separately

groups <- data.frame("Weekday"=weekendlist)
pvals <- data.frame("comparisons"=c("Thursday-Wednesday","Friday-Wednesday",",Saturday-Wednesday","Sunday-Wednesday","Monday-Wednesday","Tuesday-Wednesday","Friday-Thursday","Saturday-Thursday","Sunday-Thursday","Monday-Thursday","Tuesday-Thursday","Saturday-Friday","Sunday-Friday","Monday-Friday","Tuesday-Friday","Sunday-Saturday","Monday-Saturday","Tuesday-Saturday","Monday-Sunday","Tuesday-Sunday","Tuesday-Monday","ANOVA"),stringsAsFactors = F)
colid <- 2
for(i in min(year(Sz08to16$datetime)):max(year(Sz08to16$datetime))) {
    print(paste("Weekday seizure counts for the 2nd through 51st [full] weeks, for the year of",i))
    wXyANOVA <- weekdANOVA[which(weekdANOVA$Year == i),]
    print(ggplot() + 
        geom_boxplot(data=wXyANOVA, aes(x=wkday, y=Freq), fill="#4271AE", alpha=0.5, outlier.size=0,na.rm=T) + #Avoid duplicate outlier plotting
        geom_jitter(data=wXyANOVA, aes(x=wkday,y=Freq), position=position_jitter(width=0.05), alpha=0.8,na.rm=T) + #Outliers from incomplete weeks
        geom_hline(yintercept = mean(wXyANOVA$Freq,na.rm=T)) + 
        geom_hline(yintercept = c(mean(wXyANOVA$Freq,na.rm=T)+1.96*sd(wXyANOVA$Freq,na.rm=T),
                                  mean(wXyANOVA$Freq,na.rm=T)-1.96*sd(wXyANOVA$Freq,na.rm=T)),
                   linetype=3) + 
        ylim((mean(wXyANOVA$Freq,na.rm=T)-2*sd(wXyANOVA$Freq,na.rm=T)),(mean(wXyANOVA$Freq,na.rm=T)+2*sd(wXyANOVA$Freq,na.rm=T))) + 
        xlab("Weekday") +
        ylab("Weekly seizure counts") +
        ggtitle(paste("Weekly seizure counts, aggregated by day of the week for",i)) + 
        theme_bw())
    png(paste("Weekday seizure counts for the 2nd through 51st (full) weeks, for the year of ",i,".png",sep=""), 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
        print(ggplot() + 
        geom_boxplot(data=wXyANOVA, aes(x=wkday, y=Freq), fill="#4271AE", alpha=0.5, outlier.size=0,na.rm=T) + #Avoid duplicate outlier plotting
        geom_jitter(data=wXyANOVA, aes(x=wkday,y=Freq), position=position_jitter(width=0.05), alpha=0.8,na.rm=T) + #Outliers from incomplete weeks
        geom_hline(yintercept = mean(wXyANOVA$Freq,na.rm=T)) + 
        geom_hline(yintercept = c(mean(wXyANOVA$Freq,na.rm=T)+1.96*sd(wXyANOVA$Freq,na.rm=T),
                                  mean(wXyANOVA$Freq,na.rm=T)-1.96*sd(wXyANOVA$Freq,na.rm=T)),
                   linetype=3) + 
        ylim((mean(wXyANOVA$Freq,na.rm=T)-2*sd(wXyANOVA$Freq,na.rm=T)),(mean(wXyANOVA$Freq,na.rm=T)+2*sd(wXyANOVA$Freq,na.rm=T))) + 
        xlab("Weekday") +
        ylab("Weekly seizure counts") +
        ggtitle(paste("Weekly seizure counts, aggregated by day of the week for",i)) + 
        theme_bw())
    dev.off()
    attach(wXyANOVA)
    PANOVA <- Anova(lm(Freq ~ wkday,
                    data=wXyANOVA),
                    type="III")
    print(PANOVA)
    day2countWEEK <- aov(lm(Freq ~ wkday))
    print(day2countWEEK)
    posthoc <- TukeyHSD(x=day2countWEEK, 'wkday', conf.level = 0.95)
    print(posthoc)
    hsdday2countWEEK <- HSD.test(day2countWEEK, "wkday")
    print(hsdday2countWEEK)
    plot(hsdday2countWEEK)
    png(paste("Honestly significant difference in seizure counts, by weekday, for ",i,".png",sep=""), 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
    plot(hsdday2countWEEK)
    dev.off()
    groups <- merge(groups,hsdday2countWEEK$groups[2],by.x="Weekday",by.y=0,sort=F)
    names(groups)[colid] <- i
    forPval <- data.frame("comparisons"=rownames(posthoc$wkday),
                          "year"=as.numeric(posthoc$wkday[,4]),
                          stringsAsFactors = F)
    forPval[nrow(forPval)+1,"comparisons"] <- "ANOVA"
    forPval[nrow(forPval),"year"] <- as.numeric(PANOVA$`Pr(>F)`[2])
    #rbind(forPval,data.frame("comparisons"="ANOVA",
    #                         "year"=as.numeric(PANOVA$`Pr(>F)`[2]),
    #                         stringsAsFactors = F))
    colnames(forPval)[2] <-i
    
    pvals <- merge.data.frame(pvals,
                              forPval,
                              by = intersect(names(pvals), names(forPval)),
                              sort = F)
    colid <- colid+1
}
print(groups)
print(pvals)
write.table(groups,"Tukey_groupings.txt",quote = F,row.names = F)
write.table(pvals,"ANOVA&Tukey_pvals.txt",quote = F,row.names = F)
###TO DO: do the above with scaled incidences
```
It's possible that there is a grouping effect for the weekends...  
  
#Now to look at it from the scaled incidences per weekday
```{r scaled daily incidence multi-dien trends}
summary(Sz08to16$weeknum)
#Because first (1st) and last weeks (52nd or 53rd) can be partial weeks, will remove so as not to bias averages for given weekdays
FORtabling <- Sz08to16[which(Sz08to16$weeknum > 1 & Sz08to16$weeknum < 52),c("wkday","datetime","weeknum","scldIncidenceperDAY")]
summary(FORtabling$weeknum)
FORtabling$Date <- as.Date(FORtabling$datetime) #,'America/Los_Angeles'
summary(FORtabling$Date)
tabling <- FORtabling[,c("wkday","Date","scldIncidenceperDAY")]
tabling <- unique(tabling)
tabling$wkday <- factor(tabling$wkday, levels=factorlevels)
weekdANOVA <- tabling
weekdANOVA$Date <- as.POSIXct(weekdANOVA$Date)
weekdANOVA$Year <- year(weekdANOVA$Date)
ggplot() + 
    geom_boxplot(data=weekdANOVA, aes(x=wkday, y=scldIncidenceperDAY), fill="#4271AE", alpha=0.5, outlier.size=0,na.rm=T) + #Avoid duplicate outlier plotting
    geom_jitter(data=weekdANOVA, aes(x=wkday,y=scldIncidenceperDAY,color=factor(Year)), position=position_jitter(width=0.05), alpha=0.8,na.rm=T) + #Outliers from incomplete weeks
    #geom_point(data=weekdANOVA, aes(x=wkday, y=scldIncidenceperDAY, color=factor(Year)), alpha=1, size=3) +
    #geom_hline(yintercept = mean(weekdANOVA$scldIncidenceperDAY,na.rm=T)) + 
    #geom_hline(yintercept = c(mean(weekdANOVA$scldIncidenceperDAY,na.rm=T)+1.96*sd(weekdANOVA$scldIncidenceperDAY,na.rm=T),mean(weekdANOVA$scldIncidenceperDAY,na.rm=T)-1.96*sd(weekdANOVA$scldIncidenceperDAY,na.rm=T)),linetype=3) + 
    ylim(0,(mean(weekdANOVA$scldIncidenceperDAY,na.rm=T)+2*sd(weekdANOVA$scldIncidenceperDAY,na.rm=T))) + 
    xlab("Weekday") +
    ylab("Weekly seizure incidence rates") +
    ggtitle("Weekly seizure incidence rates (scaled per individual), aggregated by day of the week") + 
    theme_bw() + 
    theme(legend.title = element_blank())
png(paste("Weekday seizure incidence rates, aggregated by day of the week, from ",min(year(Sz08to16$datetime))," to ",max(year(Sz08to16$datetime)),".png",sep=""), 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
print(ggplot() + 
    geom_boxplot(data=weekdANOVA, aes(x=wkday, y=scldIncidenceperDAY), fill="#4271AE", alpha=0.5, outlier.size=0,na.rm=T) + #Avoid duplicate outlier plotting
    geom_jitter(data=weekdANOVA, aes(x=wkday,y=scldIncidenceperDAY,color=factor(Year)), position=position_jitter(width=0.05), alpha=0.8,na.rm=T) + #Outliers from incomplete weeks
    #geom_point(data=weekdANOVA, aes(x=wkday, y=scldIncidenceperDAY, color=factor(Year)), alpha=1, size=3) +
    #geom_hline(yintercept = mean(weekdANOVA$scldIncidenceperDAY,na.rm=T)) + 
    #geom_hline(yintercept = c(mean(weekdANOVA$scldIncidenceperDAY,na.rm=T)+1.96*sd(weekdANOVA$scldIncidenceperDAY,na.rm=T),mean(weekdANOVA$scldIncidenceperDAY,na.rm=T)-1.96*sd(weekdANOVA$scldIncidenceperDAY,na.rm=T)),linetype=3) + 
    ylim(0,(mean(weekdANOVA$scldIncidenceperDAY,na.rm=T)+2*sd(weekdANOVA$scldIncidenceperDAY,na.rm=T))) + 
    xlab("Weekday") +
    ylab("Weekly seizure incidence rates") +
    ggtitle("Weekly seizure incidence rates (scaled per individual), aggregated by day of the week") + 
    theme_bw() + 
    theme(legend.title = element_blank()))
dev.off()
attach(weekdANOVA)
Anova(lm(scldIncidenceperDAY ~ wkday,
         data=weekdANOVA),
      type="III")
day2countWEEK <- aov(lm(scldIncidenceperDAY ~ wkday))
day2countWEEK
posthoc <- TukeyHSD(x=day2countWEEK, 'wkday', conf.level = 0.95)
posthoc
hsdday2countWEEK <- HSD.test(day2countWEEK, "wkday")
hsdday2countWEEK

groups <- data.frame("Weekday"=weekendlist)
pvals <- data.frame("comparisons"=c("Thursday-Wednesday","Friday-Wednesday",",Saturday-Wednesday","Sunday-Wednesday","Monday-Wednesday","Tuesday-Wednesday","Friday-Thursday","Saturday-Thursday","Sunday-Thursday","Monday-Thursday","Tuesday-Thursday","Saturday-Friday","Sunday-Friday","Monday-Friday","Tuesday-Friday","Sunday-Saturday","Monday-Saturday","Tuesday-Saturday","Monday-Sunday","Tuesday-Sunday","Tuesday-Monday","ANOVA"),stringsAsFactors = F)
colid <- 2
for(i in min(year(Sz08to16$datetime)):max(year(Sz08to16$datetime))) {
    print(paste("Weekday seizure incidence rates for the 2nd through 51st [full] weeks, for the year of",i))
    wXyANOVA <- weekdANOVA[which(weekdANOVA$Year == i),]
    print(ggplot() + 
        geom_boxplot(data=wXyANOVA, aes(x=wkday, y=scldIncidenceperDAY), fill="#4271AE", alpha=0.5, outlier.size=0,na.rm=T) + #Avoid duplicate outlier plotting
        geom_jitter(data=wXyANOVA, aes(x=wkday,y=scldIncidenceperDAY), position=position_jitter(width=0.05), alpha=0.8,na.rm=T) + #Outliers from incomplete weeks
        geom_hline(yintercept = mean(wXyANOVA$scldIncidenceperDAY,na.rm=T)) + 
        geom_hline(yintercept = c(mean(wXyANOVA$scldIncidenceperDAY,na.rm=T)+1.96*sd(wXyANOVA$scldIncidenceperDAY,na.rm=T),
                                  mean(wXyANOVA$scldIncidenceperDAY,na.rm=T)-1.96*sd(wXyANOVA$scldIncidenceperDAY,na.rm=T)),
                   linetype=3) + 
        ylim(0,(mean(wXyANOVA$scldIncidenceperDAY,na.rm=T)+2*sd(wXyANOVA$scldIncidenceperDAY,na.rm=T))) + 
        xlab("Weekday") +
        ylab("Weekly seizure incidence rates") +
        ggtitle(paste("Weekly seizure incidence rates, aggregated by day of the week for",i)) + 
        theme_bw())
    png(paste("Weekday seizure incidence rates for the 2nd through 51st (full) weeks, for the year of ",i,".png",sep=""), 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
        print(ggplot() + 
        geom_boxplot(data=wXyANOVA, aes(x=wkday, y=scldIncidenceperDAY), fill="#4271AE", alpha=0.5, outlier.size=0,na.rm=T) + #Avoid duplicate outlier plotting
        geom_jitter(data=wXyANOVA, aes(x=wkday,y=scldIncidenceperDAY), position=position_jitter(width=0.05), alpha=0.8,na.rm=T) + #Outliers from incomplete weeks
        geom_hline(yintercept = mean(wXyANOVA$scldIncidenceperDAY,na.rm=T)) + 
        geom_hline(yintercept = c(mean(wXyANOVA$scldIncidenceperDAY,na.rm=T)+1.96*sd(wXyANOVA$scldIncidenceperDAY,na.rm=T),
                                  mean(wXyANOVA$scldIncidenceperDAY,na.rm=T)-1.96*sd(wXyANOVA$scldIncidenceperDAY,na.rm=T)),
                   linetype=3) + 
        ylim(0,(mean(wXyANOVA$scldIncidenceperDAY,na.rm=T)+2*sd(wXyANOVA$scldIncidenceperDAY,na.rm=T))) + 
        xlab("Weekday") +
        ylab("Weekly seizure incidence rates") +
        ggtitle(paste("Weekly seizure incidence rates, aggregated by day of the week for",i)) + 
        theme_bw())
    dev.off()
    attach(wXyANOVA)
    PANOVA <- Anova(lm(scldIncidenceperDAY ~ wkday,
                    data=wXyANOVA),
                    type="III")
    print(PANOVA)
    day2countWEEK <- aov(lm(scldIncidenceperDAY ~ wkday))
    print(day2countWEEK)
    posthoc <- TukeyHSD(x=day2countWEEK, 'wkday', conf.level = 0.95)
    print(posthoc)
    hsdday2countWEEK <- HSD.test(day2countWEEK, "wkday")
    print(hsdday2countWEEK)
    plot(hsdday2countWEEK)
    png(paste("Honestly significant difference in seizure incidence rates, by weekday, for ",i,".png",sep=""), 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
    plot(hsdday2countWEEK)
    dev.off()
    groups <- merge(groups,hsdday2countWEEK$groups[2],by.x="Weekday",by.y=0,sort=F)
    names(groups)[colid] <- i
    forPval <- data.frame("comparisons"=rownames(posthoc$wkday),
                          "year"=as.numeric(posthoc$wkday[,4]),
                          stringsAsFactors = F)
    forPval[nrow(forPval)+1,"comparisons"] <- "ANOVA"
    forPval[nrow(forPval),"year"] <- as.numeric(PANOVA$`Pr(>F)`[2])
    #rbind(forPval,data.frame("comparisons"="ANOVA",
    #                         "year"=as.numeric(PANOVA$`Pr(>F)`[2]),
    #                         stringsAsFactors = F))
    colnames(forPval)[2] <-i
    
    pvals <- merge.data.frame(pvals,
                              forPval,
                              by = intersect(names(pvals), names(forPval)),
                              sort = F)
    colid <- colid+1
}
print(groups)
print(pvals)
write.table(groups,"Tukey_groupings_incidence.txt",quote = F,row.names = F)
write.table(pvals,"ANOVA&Tukey_pvals_incidence.txt",quote = F,row.names = F)
```
  
#It's worthwhile to attempt standardization by approximate incidence (through gross estimates of at-risk population)
```{r pseudostandardized incidence rates per day}
#This will add in the relevant data incidence data, based on an approximation of unique, at-risk individuals
# -note this denominator of person-time is inaccurate for multiple reasons:
#  +it counts people "at risk" only if they've documented a seizure - i.e. ascertainment bias for those reporting
#  +it doesn't account for single documenters that then stop using the app - also an ascertainment bias
#  +it doesn't account for interventions (i.e. surgery, changes in regimen), assuming similar risk over similar time periods
#  +it doesn't account for "voyeurs" - people who signed up, but haven't documented yet

###=====This one takes a little while to run=====###
for(j in 1:nrow(weekdANOVA)) {
    denomdf <- Sz08to16[which(Sz08to16$datetime <= as.Date(weekdANOVA[j,"Date"])),"Unlinked_ID"]
    weekdANOVA[j,"AtRisk"] <- length(unique(denomdf))
    weekdANOVA[j,"Incidence"] <- weekdANOVA[j,"Freq"]/length(unique(denomdf))
}
###=====This one takes a little while to run=====###

p <- ggplot() 
for(i in min(year(Sz08to16$datetime)):max(year(Sz08to16$datetime))) {
    p <- p + geom_boxplot(data=weekdANOVA[which(weekdANOVA[,"Year"] == i),],
                 aes(x=wkday, y=Incidence),
                 fill=brewer.pal(n=(max(year(Sz08to16$datetime))-min(year(Sz08to16$datetime))),"Paired")[i-2007],
                 alpha=0.2,
                 outlier.size=NA, #Avoid duplicate outlier plotting
                 notch = T, #Enhance visibility
                 na.rm=T)
    p <- p + geom_jitter(data=weekdANOVA[which(weekdANOVA[,"Year"] == i),],
                aes(x=wkday,y=Incidence),
                color=brewer.pal(n=(max(year(Sz08to16$datetime))-min(year(Sz08to16$datetime))),"Paired")[i-2007],
                position=position_jitter(width=0.05),
                alpha=0.8,
                na.rm=T)#Outliers from incomplete weeks
}
p <- p + 
    ylim((mean(weekdANOVA$Incidence,na.rm=T)-2*sd(weekdANOVA$Incidence,na.rm=T)),(mean(weekdANOVA$Incidence,na.rm=T)+2*sd(weekdANOVA$Incidence,na.rm=T))) + 
    xlab("Weekday") +
    ylab("Weekly seizure incidence rates (seizures per persons at risk)") +
    ggtitle("Weekly seizure incidence trends, by day of the week, separated by year") + 
    theme_bw()
p
print(p)

#That was a little messy, but it looks like the yearly pattern may be there, so plot them (and do ANOVA) separately
groups <- data.frame("Weekday"=weekendlist)
colid <- 2
for(i in min(year(Sz08to16$datetime)):max(year(Sz08to16$datetime))) {
    print(paste("Weekday seizure incidence trends for the 2nd through 51st [full] weeks, for the year of",i))
    wXyANOVA <- weekdANOVA[which(weekdANOVA$Year == i),]
    print(ggplot() + 
        geom_boxplot(data=wXyANOVA, aes(x=wkday, y=Incidence), fill="#4271AE", alpha=0.5, outlier.size=NA,na.rm=T) + #Avoid duplicate outlier plotting
        geom_jitter(data=wXyANOVA, aes(x=wkday,y=Incidence), position=position_jitter(width=0.05), alpha=0.8,na.rm=T) + #Outliers from incomplete weeks
        geom_hline(yintercept = mean(wXyANOVA$Incidence,na.rm=T)) + 
        geom_hline(yintercept = c(mean(wXyANOVA$Incidence,na.rm=T)+1.96*sd(wXyANOVA$Incidence,na.rm=T),
                                  mean(wXyANOVA$Incidence,na.rm=T)-1.96*sd(wXyANOVA$Incidence,na.rm=T)),
                   linetype=3) + 
        ylim((mean(wXyANOVA$Incidence,na.rm=T)-2*sd(wXyANOVA$Incidence,na.rm=T)),(mean(wXyANOVA$Incidence,na.rm=T)+2*sd(wXyANOVA$Incidence,na.rm=T))) + 
        xlab("Weekday") +
        ylab("Weekly seizure incidence rates (seizures per persons at risk)") +
        ggtitle(paste("Weekly seizure incidence trends, by day of the week for",i)) + 
        theme_bw())
    png(paste("Weekday seizure incidence trends for the 2nd through 51st (full) weeks, for the year of ",i,".png",sep=""), 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
        print(ggplot() + 
        geom_boxplot(data=wXyANOVA, aes(x=wkday, y=Incidence), fill="#4271AE", alpha=0.5, outlier.size=NA,na.rm=T) + #Avoid duplicate outlier plotting
        geom_jitter(data=wXyANOVA, aes(x=wkday,y=Incidence), position=position_jitter(width=0.05), alpha=0.8,na.rm=T) + #Outliers from incomplete weeks
        geom_hline(yintercept = mean(wXyANOVA$Incidence,na.rm=T)) + 
        geom_hline(yintercept = c(mean(wXyANOVA$Incidence,na.rm=T)+1.96*sd(wXyANOVA$Incidence,na.rm=T),
                                  mean(wXyANOVA$Incidence,na.rm=T)-1.96*sd(wXyANOVA$Incidence,na.rm=T)),
                   linetype=3) + 
        ylim((mean(wXyANOVA$Incidence,na.rm=T)-2*sd(wXyANOVA$Incidence,na.rm=T)),(mean(wXyANOVA$Incidence,na.rm=T)+2*sd(wXyANOVA$Incidence,na.rm=T))) + 
        xlab("Weekday") +
        ylab("Weekly seizure incidence rates (seizures per persons at risk)") +
        ggtitle(paste("Weekly seizure incidence trends, by day of the week for",i)) + 
        theme_bw())
    dev.off()
    attach(wXyANOVA)
    Anova(lm(Incidence ~ wkday,
             data=wXyANOVA),
          type="III")
    day2countWEEK <- aov(lm(Incidence ~ wkday))
    print(day2countWEEK)
    posthoc <- TukeyHSD(x=day2countWEEK, 'wkday', conf.level = 0.95)
    print(posthoc)
    hsdday2countWEEK <- HSD.test(day2countWEEK, "wkday")
    print(hsdday2countWEEK)
    plot(hsdday2countWEEK)
    png(paste("Honestly significant difference in seizure incidence, by weekday, for ",i,".png",sep=""), 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
    plot(hsdday2countWEEK)
    dev.off()
    groups <- merge(groups,hsdday2countWEEK$groups[2],by.x="Weekday",by.y=0,sort=F)
    names(groups)[colid] <- i
    colid <- colid+1
}
print(groups)
```
  
Seizure incidence rate ratios (approximated, as different denominators of person-time)
```{r rate ratio trends}
#Because first (1st) and last weeks (52nd or 53rd) can be partial weeks, will remove so as not to bias averages for given weekdays
trending <- Sz08to16[which(Sz08to16$weeknum > 1 & Sz08to16$weeknum < 52),]
daytrend <- data.frame("Year"=year(trending$datetime),
                       "RelativeDay"=(yday(trending$datetime) - trending$DSTday),
                       "DailyIncidence"=trending$IncidenceperDAY,
                       "AtRisk"=trending$AtRiskperDAY)
#Calculate approximate "rate ratio" relative to DST
for(i in min(daytrend$Year):max(daytrend$Year)) {
    DSTinc <- mean(daytrend[which(daytrend$RelativeDay == 0 & daytrend$Year == i),"DailyIncidence"])
    #Even though getting mean DST incidence, it can be verified that it's the same for any year: 
    print(summary(daytrend[which(daytrend$RelativeDay == 0 & daytrend$Year == i),]))
    daytrend[which(daytrend$Year == i),"RateRatio"] <- daytrend[which(daytrend$Year == i),"DailyIncidence"]/DSTinc
}

#Because each representation at a given day of the year contains the same incidence for that day, need to remove duplicates before removing outliers (can verify by checking dim of daytrend after outlier removal if unique is done before or after the outlier removal)
daytrend <- unique(daytrend)
#Eliminate spuriously extreme outliers (beyond 1st/99th percentiles)
daytrend <- daytrend[which(daytrend$RateRatio > quantile(daytrend$RateRatio, 0.01, na.rm=T)[[1]] & daytrend$RateRatio < quantile(daytrend$RateRatio, 0.99, na.rm=T)[[1]]),]
daystats <- data.frame("RelativeDay"=numeric(),
                       "Mean"=numeric(),
                       "SD"=numeric())

###PREVIOUS METHOD without weighted averages and SDs
#index=1
#for(i in min(daytrend$RelativeDay):max(daytrend$RelativeDay)) {
#    daystats[index,"RelativeDay"] <- i
#    daystats[index,"Mean"] <- mean(daytrend[which(daytrend$RelativeDay == i),"RateRatio"])
#    daystats[index,"SD"] <- sd(daytrend[which(daytrend$RelativeDay == i),"RateRatio"])
#    index=index+1
#}

index=1
for(i in min(daytrend$RelativeDay):max(daytrend$RelativeDay)) {
    daystats[index,"RelativeDay"] <- i
    #Creating a weighted average and weighted SD
    WA <- weighted.mean(daytrend[which(daytrend$RelativeDay == i),"RateRatio"], daytrend[which(daytrend$RelativeDay == i),"AtRisk"])
    daystats[index,"Mean"] <- WA
    WSD <- sqrt(sum(daytrend[which(daytrend$RelativeDay == i),"AtRisk"] * (daytrend[which(daytrend$RelativeDay == i),"RateRatio"] - WA)^2)/sum(daytrend[which(daytrend$RelativeDay == i),"AtRisk"]))
    daystats[index,"SD"] <- WSD
    index=index+1
}

ggplot() + 
    #geom_boxplot(data=daytrend, aes(x=RelativeDay, y=RateRatio), fill="#4271AE", alpha=0.5, outlier.size=NA) + #Avoid duplicate outlier plotting
    #geom_point(data=daytrend, aes(x=RelativeDay, y=RateRatio, color=factor(Year)), alpha=1, size=3) +
    geom_line() + 
    stat_summary(data=daytrend, aes(x=RelativeDay, y=RateRatio, group=Year, color=factor(Year)), geom="line", fun.y=mean) + 
    geom_hline(yintercept = mean(daytrend$RateRatio,na.rm=T)) + 
    geom_hline(yintercept = c(mean(daytrend$RateRatio,na.rm=T)+1.96*sd(daytrend$RateRatio,na.rm=T),
                              mean(daytrend$RateRatio,na.rm=T)-1.96*sd(daytrend$RateRatio,na.rm=T)),
               linetype=3) + 
    xlab("Day of year (relative to DST transition on Sunday - indexed as 0)") +
    ylab("Rate Ratio (Sz incidence compared to DST)") +
    ggtitle("Daily Rate Ratio trends over a year, indexed to DST") + 
    #ylim(0,quantile(daytrend$RateRatio, 0.99, na.rm=T)[[1]]) + 
    theme_bw() + 
    theme(legend.title = element_blank())

png("Daily rate ratios (relative to DST).png", 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
print(ggplot() + 
    #geom_boxplot(data=daytrend, aes(x=RelativeDay, y=RateRatio), fill="#4271AE", alpha=0.5, outlier.size=NA) + #Avoid duplicate outlier plotting
    #geom_point(data=daytrend, aes(x=RelativeDay, y=RateRatio, color=factor(Year)), alpha=1, size=3) +
    geom_line() + 
    stat_summary(data=daytrend, aes(x=RelativeDay, y=RateRatio, group=Year, color=factor(Year)), geom="line", fun.y=mean) + 
    geom_hline(yintercept = mean(daytrend$RateRatio,na.rm=T)) + 
    geom_hline(yintercept = c(mean(daytrend$RateRatio,na.rm=T)+1.96*sd(daytrend$RateRatio,na.rm=T),
                              mean(daytrend$RateRatio,na.rm=T)-1.96*sd(daytrend$RateRatio,na.rm=T)),
               linetype=3) + 
    xlab("Day of year (relative to DST transition on Sunday - indexed as 0)") +
    ylab("Rate Ratio (Sz incidence compared to DST)") +
    ggtitle("Daily Rate Ratio trends over a year, indexed to DST") + 
    #ylim(0,quantile(daytrend$RateRatio, 0.99, na.rm=T)[[1]]) + 
    theme_bw() + 
    theme(legend.title = element_blank()))
dev.off()

ggplot() + 
    #geom_point(data=unique(daytrend),
    #           aes(x=RelativeDay,y=RateRatio,color=factor(Year)), 
    #           alpha=0.25) + 
    geom_hline(yintercept = 1, linetype = 3) + 
    geom_smooth(data=unique(daytrend),
                aes(x=RelativeDay,y=RateRatio,color=factor(Year)), 
                method="loess",
                span=0.1,
                se=FALSE) + 
    geom_smooth(data=unique(daytrend),
                aes(x=RelativeDay,y=RateRatio,color=factor(Year)), 
                method="loess",
                span=7/365,
                se=TRUE,
                alpha=0.5,
                colour="black") + 
    geom_vline(xintercept=c(0,7,237,244)) + 
    annotate("rect", xmin=0, xmax=7, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=237, xmax=244, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Day of the year (indexed to DST transition)") +
    ylab("Daily Rate Ratio trends over a year (mean ± SEM)") +
    ggtitle("Daily Rate Ratio trends over a year, indexed to DST") + 
    #ylim(0.5,2.25) + 
    theme_bw() + 
    theme(legend.title = element_blank())

png("Daily rate ratios with loess averaging of trends.png", 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
print(ggplot() + 
    #geom_point(data=unique(daytrend),
    #           aes(x=RelativeDay,y=RateRatio,color=factor(Year)), 
    #           alpha=0.25) + 
    geom_hline(yintercept = 1, linetype = 3) + 
    geom_smooth(data=unique(daytrend),
                aes(x=RelativeDay,y=RateRatio,color=factor(Year)), 
                method="loess",
                span=0.1,
                se=FALSE) + 
    geom_smooth(data=unique(daytrend),
                aes(x=RelativeDay,y=RateRatio,color=factor(Year)), 
                method="loess",
                span=7/365,
                se=TRUE,
                alpha=0.5,
                colour="black") + 
    geom_vline(xintercept=c(0,7,237,244)) + 
    annotate("rect", xmin=0, xmax=7, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=237, xmax=244, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Day of the year (indexed to DST transition)") +
    ylab("Daily Rate Ratio trends over a year (mean ± SEM)") +
    ggtitle("Daily Rate Ratio trends over a year, indexed to DST") + 
    #ylim(0.5,2.25) + 
    theme_bw() + 
    theme(legend.title = element_blank()))
dev.off()

ggplot() + 
    #geom_point(data=daytrend, aes(x=RelativeDay,y=RateRatio,color=Year), alpha=0.01) + 
    geom_hline(yintercept = 1, linetype = 3) + 
    geom_line(data=daystats, aes(x=RelativeDay,y=Mean),size=1,color="black") + 
    geom_ribbon(data=daystats,aes(x=RelativeDay,ymin=(Mean+SD),ymax=(Mean-SD)),alpha=0.5) + 
    geom_vline(xintercept=c(0,7,237,244)) + 
    annotate("rect", xmin=0, xmax=7, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=237, xmax=244, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Day of the year (indexed to DST transition)") +
    ylab("Daily Rate Ratio trends over a year (mean ± SD)") +
    ggtitle("Daily Rate Ratio trends over a year, indexed to DST") + 
    #ylim(0.5,2) + 
    theme_bw() + 
    theme(legend.title = element_blank())

png("Daily rate ratio trends over a year, indexed to DST.png", 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
print(ggplot() + 
    #geom_point(data=daytrend, aes(x=RelativeDay,y=RateRatio,color=Year), alpha=0.01) + 
    geom_hline(yintercept = 1, linetype = 3) + 
    geom_line(data=daystats, aes(x=RelativeDay,y=Mean),size=1,color="black") + 
    geom_ribbon(data=daystats,aes(x=RelativeDay,ymin=(Mean+SD),ymax=(Mean-SD)),alpha=0.5) + 
    geom_vline(xintercept=c(0,7,237,244)) + 
    annotate("rect", xmin=0, xmax=7, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=237, xmax=244, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Day of the year (indexed to DST transition)") +
    ylab("Daily Rate Ratio trends over a year (mean ± SD)") +
    ggtitle("Daily Rate Ratio trends over a year, indexed to DST") + 
    #ylim(0.5,2) + 
    theme_bw() + 
    theme(legend.title = element_blank()))
dev.off()

weektrend <- data.frame("Year"=year(trending$datetime),
                        "RelativeWeek"=(week(trending$datetime) - trending$DSTweek),
                        "WeeklyIncidence"=trending$IncidenceperWEEK,
                        "AtRisk"=trending$AtRiskperWEEK)
#Calculate approximate "rate ratio" relative to DST
for(i in min(weektrend$Year):max(weektrend$Year)) {
    DSTinc <- mean(weektrend[which(weektrend$RelativeWeek == 0 & weektrend$Year == i),"WeeklyIncidence"])
    #Even though getting mean DST incidence, it can be verified that it's the same for any year: 
    print(summary(weektrend[which(weektrend$RelativeWeek == 0 & weektrend$Year == i),]))
    weektrend[which(weektrend$Year == i),"RateRatio"] <- weektrend[which(weektrend$Year == i),"WeeklyIncidence"]/DSTinc
}
#Removing duplicate entries (should be the case for each week to have n duplicates, where n is the number of seizures that contributed to the incidence in that time period)...important to remove before outlier removal as different Ns per week will cause biased outlier removal
weektrend <- unique(weektrend)
#Eliminate spuriously extreme outliers (beyond 1st/99th percentiles)
weektrend <- weektrend[which(weektrend$RateRatio > quantile(weektrend$RateRatio, 0.01, na.rm=T)[[1]] & weektrend$RateRatio < quantile(weektrend$RateRatio, 0.99, na.rm=T)[[1]]),]
weekstats <- data.frame("RelativeWeek"=numeric(),
                        "Mean"=numeric(),
                        "SD"=numeric())

###PREVIOUS METHOD without weighted averages and SDs
#index=1
#for(i in min(weektrend$RelativeWeek):max(weektrend$RelativeWeek)) {
#    weekstats[index,"RelativeWeek"] <- i
#    weekstats[index,"Mean"] <- mean(weektrend[which(weektrend$RelativeWeek == i),"RateRatio"])
#    weekstats[index,"SD"] <- sd(weektrend[which(weektrend$RelativeWeek == i),"RateRatio"])#/nrow(weektrend[which(weektrend$RelativeWeek == i),])
#    index=index+1
#}

index=1
for(i in min(weektrend$RelativeWeek):max(weektrend$RelativeWeek)) {
    weekstats[index,"RelativeWeek"] <- i
    #Creating a weighted average and weighted SD
    WA <- weighted.mean(weektrend[which(weektrend$RelativeWeek == i),"RateRatio"], weektrend[which(weektrend$RelativeWeek == i),"AtRisk"])
    weekstats[index,"Mean"] <- WA
    WSD <- sqrt(sum(weektrend[which(weektrend$RelativeWeek == i),"AtRisk"] * (weektrend[which(weektrend$RelativeWeek == i),"RateRatio"] - WA)^2)/sum(weektrend[which(weektrend$RelativeWeek == i),"AtRisk"]))
    weekstats[index,"SD"] <- WSD
    index=index+1
}

ggplot() + 
    #geom_boxplot(data=weektrend, aes(x=RelativeWeek, y=RateRatio), fill="#4271AE", alpha=0.5, outlier.size=NA) + #Avoid duplicate outlier plotting
    #geom_point(data=weektrend, aes(x=RelativeWeek, y=RateRatio, color=factor(Year)), alpha=1, size=3) +
    geom_line() + 
    stat_summary(data=weektrend, aes(x=RelativeWeek, y=RateRatio, group=Year, color=factor(Year)), geom="line", fun.y=mean) + 
    geom_hline(yintercept = mean(weektrend$RateRatio,na.rm=T)) + 
    geom_hline(yintercept = c(mean(weektrend$RateRatio,na.rm=T)+1.96*sd(weektrend$RateRatio,na.rm=T),
                              mean(weektrend$RateRatio,na.rm=T)-1.96*sd(weektrend$RateRatio,na.rm=T)),
               linetype=3) + 
    xlab("Week of year (relative to DST transition on Sunday - indexed as 0)") +
    ylab("Rate Ratio (Sz incidence compared to DST)") +
    ggtitle("Weekly Rate Ratio trends over a year, indexed to DST") + 
    #ylim(0,quantile(weektrend$RateRatio, 0.99, na.rm=T)[[1]]) + 
    theme_bw() + 
    theme(legend.title = element_blank())

png("Weekly rate ratios (relative to DST).png", 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
print(ggplot() + 
    #geom_boxplot(data=weektrend, aes(x=RelativeWeek, y=RateRatio), fill="#4271AE", alpha=0.5, outlier.size=NA) + #Avoid duplicate outlier plotting
    #geom_point(data=weektrend, aes(x=RelativeWeek, y=RateRatio, color=factor(Year)), alpha=1, size=3) +
    geom_line() + 
    stat_summary(data=weektrend, aes(x=RelativeWeek, y=RateRatio, group=Year, color=factor(Year)), geom="line", fun.y=mean) + 
    geom_hline(yintercept = mean(weektrend$RateRatio,na.rm=T)) + 
    geom_hline(yintercept = c(mean(weektrend$RateRatio,na.rm=T)+1.96*sd(weektrend$RateRatio,na.rm=T),
                              mean(weektrend$RateRatio,na.rm=T)-1.96*sd(weektrend$RateRatio,na.rm=T)),
               linetype=3) + 
    xlab("Week of year (relative to DST transition on Sunday - indexed as 0)") +
    ylab("Rate Ratio (Sz incidence compared to DST)") +
    ggtitle("Weekly Rate Ratio trends over a year, indexed to DST") + 
    #ylim(0,quantile(weektrend$RateRatio, 0.99, na.rm=T)[[1]]) + 
    theme_bw() + 
    theme(legend.title = element_blank()))
dev.off()

ggplot(data=weektrend,
       aes(x=RelativeWeek,y=RateRatio,color=factor(Year))) + 
    #geom_point(alpha=0.3) + 
    geom_hline(yintercept = 1, linetype = 3) + 
    geom_smooth(se=FALSE, method="loess", span=0.3) + 
    geom_smooth(method="loess",
                span=0.1,
                se=TRUE,
                alpha=0.75,
                colour="black") + 
    geom_vline(xintercept=c(0,1,33,34)) + 
    annotate("rect", xmin=0, xmax=1, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=33, xmax=34, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Week of the year (indexed to DST transition)") +
    ylab("Weekly Rate Ratio trends over a year (mean ± SD)") +
    ggtitle("Weekly Rate Ratio trends over a year, indexed to DST") + 
    #ylim(0,quantile(weektrend$RateRatio, 0.99, na.rm=T)[[1]]) + 
    theme_bw() + 
    theme(legend.title = element_blank())

png("Weekly rate ratios with loess averaging and yearly trends.png", 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
print(ggplot(data=weektrend,
       aes(x=RelativeWeek,y=RateRatio,color=factor(Year))) + 
    #geom_point(alpha=0.3) + 
    geom_hline(yintercept = 1, linetype = 3) + 
    geom_smooth(se=FALSE, method="loess", span=0.3) + 
    geom_smooth(method="loess",
                span=0.1,
                se=TRUE,
                alpha=0.75,
                colour="black") + 
    geom_vline(xintercept=c(0,1,33,34)) + 
    annotate("rect", xmin=0, xmax=1, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=33, xmax=34, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Week of the year (indexed to DST transition)") +
    ylab("Weekly Rate Ratio trends over a year (mean ± SD)") +
    ggtitle("Weekly Rate Ratio trends over a year, indexed to DST") + 
    #ylim(0,quantile(weektrend$RateRatio, 0.99, na.rm=T)[[1]]) + 
    theme_bw() + 
    theme(legend.title = element_blank()))
dev.off()

ggplot() + 
    #geom_point(data=weektrend, aes(x=RelativeWeek,y=RateRatio,color=Year), alpha=0.01) + 
    geom_hline(yintercept = 1, linetype = 3) + 
    geom_line(data=weekstats, aes(x=RelativeWeek,y=Mean),size=1,color="black") + 
    geom_ribbon(data=weekstats,aes(x=RelativeWeek,ymin=(Mean+SD),ymax=(Mean-SD)),alpha=0.5) + 
    geom_vline(xintercept=c(0,1,33,34)) + 
    annotate("rect", xmin=0, xmax=1, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=33, xmax=34, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Week of the year (indexed to DST transition)") +
    ylab("Weekly Rate Ratio trends over a year (mean ± SD)") +
    ggtitle("Weekly Rate Ratio trends over a year, indexed to DST") + 
    #ylim(0.5,2) + 
    theme_bw() + 
    theme(legend.title = element_blank())

png("Weekly rate ratio trends over a year, indexed to DST.png", 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
print(ggplot() + 
    #geom_point(data=weektrend, aes(x=RelativeWeek,y=RateRatio,color=Year), alpha=0.01) + 
    geom_hline(yintercept = 1, linetype = 3) + 
    geom_line(data=weekstats, aes(x=RelativeWeek,y=Mean),size=1,color="black") + 
    geom_ribbon(data=weekstats,aes(x=RelativeWeek,ymin=(Mean+SD),ymax=(Mean-SD)),alpha=0.5) + 
    geom_vline(xintercept=c(0,1,33,34)) + 
    annotate("rect", xmin=0, xmax=1, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=33, xmax=34, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Week of the year (indexed to DST transition)") +
    ylab("Weekly Rate Ratio trends over a year (mean ± SD)") +
    ggtitle("Weekly Rate Ratio trends over a year, indexed to DST") + 
    #ylim(0.5,2) + 
    theme_bw() + 
    theme(legend.title = element_blank()))
dev.off()
```
  
Individual-seizure-propensity-adusted seizure incidence rate ratios (approximated, as different denominators of person-time)
```{r rate ratio trends - adjusted for individual yearly seizure counts}
#Because first (1st) and last weeks (52nd or 53rd) can be partial weeks, will remove so as not to bias averages for given weekdays
reltrend <- Sz08to16[which(Sz08to16$weeknum > 1 & Sz08to16$weeknum < 52),]
daytrend <- data.frame("Year"=year(reltrend$datetime),
                       "RelativeDay"=(yday(reltrend$datetime) - reltrend$DSTday),
                       "DailyIncidence"=reltrend$relIncidenceperDAY,
                       "AtRisk"=reltrend$AtRiskperDAY)
dayagg <- data.frame("Year"=numeric(),
                     "RelativeDay"=numeric(),
                     "DailyIncidence"=numeric(),
                     "RateRatio"=numeric())

#Calculate approximate "rate ratio" relative to DST
index=1
for(i in min(daytrend$Year):max(daytrend$Year)) {
    DSTinc <- mean(daytrend[which(daytrend$RelativeDay == 0 & daytrend$Year == i),"DailyIncidence"])
    daytrend[which(daytrend$Year == i),"RateRatio"] <- daytrend[which(daytrend$Year == i),"DailyIncidence"]/DSTinc
    #This loop is to integrate the individual-adjusted, per-person incidences into an aggregated incidence over the time period (1 day), separately for each year. Recall the individual-adjusted, per-person incidence is each individual's seizure, divided by their yearly seizure count, then divided by the person-time at risk, but in reality this is just divided by the number at risk in that time window (because the time frame will be the same and drop out when calculating the Rate Ratios). So, because each person has a different individually-adjusted incidence, an aggregate measure is made from the mean of the individual-adjusted incidences, for each time window (ie, 1 day), and then a Rate Ratio is calculated with respect to the individual-adjusted, DST incidence.
    for(j in min(daytrend$RelativeDay):max(daytrend$RelativeDay)) {
        dayagg[index,"Year"] <- i
        dayagg[index,"RelativeDay"] <- j
        dayagg[index,"DailyIncidence"] <- mean(daytrend[which(daytrend$RelativeDay == j & daytrend$Year == i),"DailyIncidence"])
        dayagg[index,"RateRatio"] <- mean(daytrend[which(daytrend$RelativeDay == j & daytrend$Year == i),"DailyIncidence"])/DSTinc
        index <- index + 1
    }
}

#Eliminate spuriously extreme outliers (beyond 1st/99th percentiles)
daytrend <- daytrend[which(daytrend$RateRatio > quantile(daytrend$RateRatio, 0.01, na.rm=T)[[1]] & daytrend$RateRatio < quantile(daytrend$RateRatio, 0.99, na.rm=T)[[1]]),]
dayagg <- dayagg[which(dayagg$RateRatio > quantile(dayagg$RateRatio, 0.01, na.rm=T)[[1]] & dayagg$RateRatio < quantile(dayagg$RateRatio, 0.99, na.rm=T)[[1]]),]
forstats <- unique(daytrend[order( daytrend[,1], daytrend[,2] ),-c(3,5)]) #Removes DailyIncidence & Rate Ratio
forstats <- merge.data.frame(dayagg, forstats, na.last=NA)
forstats <- forstats[order( forstats[,1], forstats[,2] ),]
daystats <- data.frame("RelativeDay"=numeric(),
                       "Mean"=numeric(),
                       "SD"=numeric())
###PREVIOUS METHOD without weighted averages and SDs
#index=1
#for(i in min(daytrend$RelativeDay):max(daytrend$RelativeDay)) {
#    daystats[index,"RelativeDay"] <- i
#    daystats[index,"Mean"] <- mean(dayagg[which(dayagg$RelativeDay == i),"RateRatio"])
#    daystats[index,"SD"] <- sd(dayagg[which(dayagg$RelativeDay == i),"RateRatio"])
#    index=index+1
#}

index=1
for(i in min(forstats$RelativeDay):max(forstats$RelativeDay)) {
    daystats[index,"RelativeDay"] <- i
    #Creating a weighted average and weighted SD
    WA <- weighted.mean(forstats[which(forstats$RelativeDay == i),"RateRatio"], forstats[which(forstats$RelativeDay == i),"AtRisk"])
    daystats[index,"Mean"] <- WA
    WSD <- sqrt(sum(forstats[which(forstats$RelativeDay == i),"AtRisk"] * (forstats[which(forstats$RelativeDay == i),"RateRatio"] - WA)^2)/sum(forstats[which(forstats$RelativeDay == i),"AtRisk"]))
    daystats[index,"SD"] <- WSD
    index=index+1
}

ggplot() + 
    #geom_boxplot(data=dayagg, aes(x=RelativeDay, y=RateRatio), fill="#4271AE", alpha=0.5, outlier.size=NA) + #Avoid duplicate outlier plotting
    #geom_point(data=dayagg, aes(x=RelativeDay, y=RateRatio, color=factor(Year)), alpha=1, size=3) +
    geom_line() + 
    stat_summary(data=dayagg, aes(x=RelativeDay, y=RateRatio, group=Year, color=factor(Year)), geom="line", fun.y=mean) + 
    geom_hline(yintercept = mean(dayagg$RateRatio,na.rm=T)) + 
    geom_hline(yintercept = c(mean(dayagg$RateRatio,na.rm=T)+1.96*sd(dayagg$RateRatio,na.rm=T),
                              mean(dayagg$RateRatio,na.rm=T)-1.96*sd(dayagg$RateRatio,na.rm=T)),
               linetype=3) + 
    xlab("Day of year (relative to DST transition on Sunday - indexed as 0)") +
    ylab("Individual-adjusted Rate Ratio (Sz incidence vs DST)") +
    ggtitle("Individual-adjusted daily Rate Ratio trends over a year") + 
    #ylim(0,quantile(dayagg$RateRatio, 0.99, na.rm=T)[[1]]) + 
    theme_bw() + 
    theme(legend.title = element_blank())

png("Individual-adjusted daily rate ratios (relative to DST).png", 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
print(ggplot() + 
    #geom_boxplot(data=dayagg, aes(x=RelativeDay, y=RateRatio), fill="#4271AE", alpha=0.5, outlier.size=NA) + #Avoid duplicate outlier plotting
    #geom_point(data=dayagg, aes(x=RelativeDay, y=RateRatio, color=factor(Year)), alpha=1, size=3) +
    geom_line() + 
    stat_summary(data=dayagg, aes(x=RelativeDay, y=RateRatio, group=Year, color=factor(Year)), geom="line", fun.y=mean) + 
    geom_hline(yintercept = mean(dayagg$RateRatio,na.rm=T)) + 
    geom_hline(yintercept = c(mean(dayagg$RateRatio,na.rm=T)+1.96*sd(dayagg$RateRatio,na.rm=T),
                              mean(dayagg$RateRatio,na.rm=T)-1.96*sd(dayagg$RateRatio,na.rm=T)),
               linetype=3) + 
    xlab("Day of year (relative to DST transition on Sunday - indexed as 0)") +
    ylab("Individual-adjusted Rate Ratio (Sz incidence vs DST)") +
    ggtitle("Individual-adjusted daily Rate Ratio trends over a year") + 
    #ylim(0,quantile(dayagg$RateRatio, 0.99, na.rm=T)[[1]]) + 
    theme_bw() + 
    theme(legend.title = element_blank()))
dev.off()

ggplot() + 
    geom_point(data=unique(dayagg),
               aes(x=RelativeDay,y=RateRatio,color=factor(Year)), 
               alpha=0.25) + 
    #geom_smooth(method="loess", span=1/52, se=TRUE, alpha=0.3, colour="red") + 
    geom_smooth(data=unique(dayagg),
                aes(x=RelativeDay,y=RateRatio,color=factor(Year)), 
                method="loess",
                span=0.01,
                se=TRUE,
                alpha=0.5,
                colour="black") + 
    geom_vline(xintercept=c(0,7,237,244)) + 
    annotate("rect", xmin=0, xmax=7, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=237, xmax=244, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Day of the year (indexed to DST transition)") +
    ylab("Individual-adjusted daily Rate Ratio trends over a year (mean ± SEM)") +
    ggtitle("Individual-adjusted daily Rate Ratio trends over a year") + 
    #ylim(0.5,2.25) + 
    theme_bw() + 
    theme(legend.title = element_blank())

ggplot(data=unique(dayagg), aes(x=RelativeDay,y=RateRatio,color=factor(Year))) + 
    #geom_point(data=unique(dayagg),
    #           aes(x=RelativeDay,y=RateRatio,color=factor(Year)), 
    #           alpha=0.25) + 
    #geom_smooth(method="loess", span=1/52, se=TRUE, alpha=0.3, colour="red") + 
    geom_hline(yintercept = 1, linetype = 3) + 
    geom_smooth(se=FALSE, method="loess", span=0.1, alpha=0.5) + 
    geom_smooth(method="loess",
                span=0.01,
                se=TRUE,
                alpha=0.75,
                colour="black") + 
    geom_vline(xintercept=c(0,7,237,244)) + 
    annotate("rect", xmin=0, xmax=7, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=237, xmax=244, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Day of the year (indexed to DST transition)") +
    ylab("Individual-adjusted daily Rate Ratio trends over a year (mean ± SEM)") +
    ggtitle("Individual-adjusted daily Rate Ratio trends over a year") + 
    #ylim(0.5,2.25) + 
    theme_bw() + 
    theme(legend.title = element_blank())

png("Individual-adjusted daily rate ratios with loess averaging of trends.png", 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
print(ggplot(data=unique(dayagg), aes(x=RelativeDay,y=RateRatio,color=factor(Year))) + 
    #geom_point(data=unique(dayagg),
    #           aes(x=RelativeDay,y=RateRatio,color=factor(Year)), 
    #           alpha=0.25) + 
    #geom_smooth(method="loess", span=1/52, se=TRUE, alpha=0.3, colour="red") + 
    geom_hline(yintercept = 1, linetype = 3) + 
    geom_smooth(se=FALSE, method="loess", span=0.1, alpha=0.5) + 
    geom_smooth(method="loess",
                span=0.01,
                se=TRUE,
                alpha=0.75,
                colour="black") + 
    geom_vline(xintercept=c(0,7,237,244)) + 
    annotate("rect", xmin=0, xmax=7, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=237, xmax=244, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Day of the year (indexed to DST transition)") +
    ylab("Individual-adjusted daily Rate Ratio trends over a year (mean ± SEM)") +
    ggtitle("Individual-adjusted daily Rate Ratio trends over a year") + 
    #ylim(0.5,2.25) + 
    theme_bw() + 
    theme(legend.title = element_blank()))
dev.off()

ggplot() + 
    #geom_point(data=dayagg, aes(x=RelativeDay,y=RateRatio,color=Year), alpha=0.01) + 
    geom_hline(yintercept = 1, linetype = 3) + 
    geom_line(data=daystats, aes(x=RelativeDay,y=Mean),size=1,color="black") + 
    geom_ribbon(data=daystats,aes(x=RelativeDay,ymin=(Mean+SD),ymax=(Mean-SD)),alpha=0.5) + 
    geom_vline(xintercept=c(0,7,237,244)) + 
    annotate("rect", xmin=0, xmax=7, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=237, xmax=244, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Day of the year (indexed to DST transition)") +
    ylab("Individual-adjusted daily Rate Ratio trends over a year (mean ± SD)") +
    ggtitle("Individual-adjusted daily Rate Ratio trends over a year") + 
    #ylim(0.5,2) + 
    theme_bw() + 
    theme(legend.title = element_blank())

png("Individual-adjusted daily rate ratio trends over a year, indexed to DST.png", 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
print(ggplot() + 
    #geom_point(data=dayagg, aes(x=RelativeDay,y=RateRatio,color=Year), alpha=0.01) + 
    geom_hline(yintercept = 1, linetype = 3) + 
    geom_line(data=daystats, aes(x=RelativeDay,y=Mean),size=1,color="black") + 
    geom_ribbon(data=daystats,aes(x=RelativeDay,ymin=(Mean+SD),ymax=(Mean-SD)),alpha=0.5) + 
    geom_vline(xintercept=c(0,7,237,244)) + 
    annotate("rect", xmin=0, xmax=7, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=237, xmax=244, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Day of the year (indexed to DST transition)") +
    ylab("Individual-adjusted daily Rate Ratio trends over a year (mean ± SD)") +
    ggtitle("Individual-adjusted daily Rate Ratio trends over a year") + 
    #ylim(0.5,2) + 
    theme_bw() + 
    theme(legend.title = element_blank()))
dev.off()

weektrend <- data.frame("Year"=year(reltrend$datetime),
                        "RelativeWeek"=(week(reltrend$datetime) - reltrend$DSTweek),
                        "WeeklyIncidence"=reltrend$relIncidenceperWEEK,
                        "AtRisk"=reltrend$AtRiskperWEEK)
weekagg <- data.frame("Year"=numeric(),
                      "RelativeWeek"=numeric(),
                      "WeeklyIncidence"=numeric(),
                      "RateRatio"=numeric())

#Calculate approximate "rate ratio" relative to DST
index=1
for(i in min(weektrend$Year):max(weektrend$Year)) {
    DSTinc <- mean(weektrend[which(weektrend$RelativeWeek == 0 & weektrend$Year == i),"WeeklyIncidence"])
    weektrend[which(weektrend$Year == i),"RateRatio"] <- weektrend[which(weektrend$Year == i),"WeeklyIncidence"]/DSTinc
    #This loop is to integrate the individual-adjusted, per-person incidences into an aggregated incidence over the time period (1 week), separately for each year. Recall the individual-adjusted, per-person incidence is each individual's seizure, divided by their yearly seizure count, then divided by the person-time at risk, but in reality this is just divided by the number at risk in that time window (because the time frame will be the same and drop out when calculating the Rate Ratios). So, because each person has a different individually-adjusted incidence, an aggregate measure is made from the mean of the individual-adjusted incidences, for each time window (ie, 1 week), and then a Rate Ratio is calculated with respect to the individual-adjusted, DST incidence.
    for(j in min(weektrend$RelativeWeek):max(weektrend$RelativeWeek)) {
        weekagg[index,"Year"] <- i
        weekagg[index,"RelativeWeek"] <- j
        weekagg[index,"WeeklyIncidence"] <- mean(weektrend[which(weektrend$RelativeWeek == j & weektrend$Year == i),"WeeklyIncidence"])
        weekagg[index,"RateRatio"] <- mean(weektrend[which(weektrend$RelativeWeek == j & weektrend$Year == i),"WeeklyIncidence"])/DSTinc
        index <- index + 1
    }
}

#Eliminate spuriously extreme outliers (beyond 1st/99th percentiles)
weektrend <- weektrend[which(weektrend$RateRatio > quantile(weektrend$RateRatio, 0.01, na.rm=T)[[1]] & weektrend$RateRatio < quantile(weektrend$RateRatio, 0.99, na.rm=T)[[1]]),]
weekagg <- weekagg[which(weekagg$RateRatio > quantile(weekagg$RateRatio, 0.01, na.rm=T)[[1]] & weekagg$RateRatio < quantile(weekagg$RateRatio, 0.99, na.rm=T)[[1]]),]
forstats <- unique(weektrend[order( weektrend[,1], weektrend[,2] ),-c(3,5)]) #Removes WeeklyIncidence & Rate Ratio
forstats <- merge.data.frame(weekagg, forstats, na.last=NA)
forstats <- forstats[order( forstats[,1], forstats[,2] ),]
weekstats <- data.frame("RelativeWeek"=numeric(),
                        "Mean"=numeric(),
                        "SD"=numeric())

###PREVIOUS METHOD without weighted averages and SDs
#index=1
#for(i in min(weektrend$RelativeWeek):max(weektrend$RelativeWeek)) {
#    weekstats[index,"RelativeWeek"] <- i
#    weekstats[index,"Mean"] <- mean(weekagg[which(weekagg$RelativeWeek == i),"RateRatio"])
#    weekstats[index,"SD"] <- sd(weekagg[which(weekagg$RelativeWeek == i),"RateRatio"])/nrow(weekagg[which(weekagg$RelativeWeek == i),])
#    index=index+1
#}

index=1
for(i in min(forstats$RelativeWeek):max(forstats$RelativeWeek)) {
    weekstats[index,"RelativeWeek"] <- i
    #Creating a weighted average and weighted SD
    WA <- weighted.mean(forstats[which(forstats$RelativeWeek == i),"RateRatio"], forstats[which(forstats$RelativeWeek == i),"AtRisk"])
    weekstats[index,"Mean"] <- WA
    WSD <- sqrt(sum(forstats[which(forstats$RelativeWeek == i),"AtRisk"] * (forstats[which(forstats$RelativeWeek == i),"RateRatio"] - WA)^2)/sum(forstats[which(forstats$RelativeWeek == i),"AtRisk"]))
    weekstats[index,"SD"] <- WSD
    index=index+1
}

#Removing duplicate entries (should be the case for each week to have n duplicates, where n is the number of seizures that contributed to the incidence in that time period)
weektrend <- unique(weektrend)
weekagg <- unique(weekagg)

ggplot() + 
    #geom_boxplot(data=weekagg, aes(x=RelativeWeek, y=RateRatio), fill="#4271AE", alpha=0.5, outlier.size=NA) + #Avoid duplicate outlier plotting
    #geom_point(data=weekagg, aes(x=RelativeWeek, y=RateRatio, color=factor(Year)), alpha=1, size=3) +
    geom_line() + 
    stat_summary(data=weekagg, aes(x=RelativeWeek, y=RateRatio, group=Year, color=factor(Year)), geom="line", fun.y=mean) + 
    geom_hline(yintercept = mean(weekagg$RateRatio,na.rm=T)) + 
    geom_hline(yintercept = c(mean(weekagg$RateRatio,na.rm=T)+1.96*sd(weekagg$RateRatio,na.rm=T),
                              mean(weekagg$RateRatio,na.rm=T)-1.96*sd(weekagg$RateRatio,na.rm=T)),
               linetype=3) + 
    xlab("Week of year (relative to DST transition week, indexed as 0)") +
    ylab("Rate Ratio (Sz incidence compared to DST)") +
    ggtitle("Individual-adjusted weekly Rate Ratio trends over a year, indexed to DST") + 
    #ylim(0,quantile(weektrend$RateRatio, 0.99, na.rm=T)[[1]]) + 
    theme_bw() + 
    theme(legend.title = element_blank())

png("Individual-adjusted weekly rate ratios (relative to DST).png", 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
print(ggplot() + 
    #geom_boxplot(data=weekagg, aes(x=RelativeWeek, y=RateRatio), fill="#4271AE", alpha=0.5, outlier.size=NA) + #Avoid duplicate outlier plotting
    #geom_point(data=weekagg, aes(x=RelativeWeek, y=RateRatio, color=factor(Year)), alpha=1, size=3) +
    geom_line() + 
    stat_summary(data=weekagg, aes(x=RelativeWeek, y=RateRatio, group=Year, color=factor(Year)), geom="line", fun.y=mean) + 
    geom_hline(yintercept = mean(weekagg$RateRatio,na.rm=T)) + 
    geom_hline(yintercept = c(mean(weekagg$RateRatio,na.rm=T)+1.96*sd(weekagg$RateRatio,na.rm=T),
                              mean(weekagg$RateRatio,na.rm=T)-1.96*sd(weekagg$RateRatio,na.rm=T)),
               linetype=3) + 
    xlab("Week of year (relative to DST transition week, indexed as 0)") +
    ylab("Rate Ratio (Sz incidence compared to DST)") +
    ggtitle("Individual-adjusted weekly Rate Ratio trends over a year, indexed to DST") + 
    #ylim(0,quantile(weektrend$RateRatio, 0.99, na.rm=T)[[1]]) + 
    theme_bw() + 
    theme(legend.title = element_blank()))
dev.off()

ggplot() + 
    geom_hline(yintercept = 1, linetype = 3) + 
    geom_point(data=weekagg,
               aes(x=RelativeWeek,y=RateRatio,color=factor(Year)), 
               alpha=0.5) + 
    #geom_smooth(method="loess", span=1/52, se=TRUE, alpha=0.3, colour="red") + 
    geom_smooth(data=weekagg,
                aes(x=RelativeWeek,y=RateRatio,color=factor(Year)), 
                method="loess",
                span=0.1,
                se=TRUE,
                alpha=0.5,
                colour="black") + 
    geom_vline(xintercept=c(0,1,33,34)) + 
    annotate("rect", xmin=0, xmax=1, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=33, xmax=34, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Week of the year (indexed to DST transition)") +
    ylab("Weekly Rate Ratio trends over a year (mean ± SEM)") +
    ggtitle("Individual-adjusted weekly Rate Ratio trends over a year") + 
    #ylim(0,quantile(weektrend$RateRatio, 0.99, na.rm=T)[[1]]) + 
    theme_bw() + 
    theme(legend.title = element_blank())

ggplot(data=weekagg,
       aes(x=RelativeWeek,y=RateRatio,color=factor(Year))) + 
    geom_hline(yintercept = 1, linetype = 3) + 
    #geom_point(alpha=0.3) + 
    geom_smooth(se=FALSE, method="loess", span=0.2) + 
    geom_smooth(method="loess",
                span=0.1,
                se=TRUE,
                alpha=0.75,
                colour="black") + 
    geom_vline(xintercept=c(0,1,33,34)) + 
    annotate("rect", xmin=0, xmax=1, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=33, xmax=34, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Week of the year (indexed to DST transition)") +
    ylab("Weekly Rate Ratio trends over a year (mean ± SEM)") +
    ggtitle("Individual-adjusted weekly Rate Ratio trends over a year") + 
    #ylim(0,quantile(weektrend$RateRatio, 0.99, na.rm=T)[[1]]) + 
    theme_bw() + 
    theme(legend.title = element_blank())

png("Individual-adjusted weekly rate ratios with loess averaging and yearly trends.png", 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
print(ggplot(data=weekagg,
       aes(x=RelativeWeek,y=RateRatio,color=factor(Year))) + 
    geom_hline(yintercept = 1, linetype = 3) + 
    #geom_point(alpha=0.3) + 
    geom_smooth(se=FALSE, method="loess", span=0.2) + 
    geom_smooth(method="loess",
                span=0.1,
                se=TRUE,
                alpha=0.75,
                colour="black") + 
    geom_vline(xintercept=c(0,1,33,34)) + 
    annotate("rect", xmin=0, xmax=1, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=33, xmax=34, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Week of the year (indexed to DST transition)") +
    ylab("Weekly Rate Ratio trends over a year (mean ± SEM)") +
    ggtitle("Individual-adjusted weekly Rate Ratio trends over a year") + 
    #ylim(0,quantile(weektrend$RateRatio, 0.99, na.rm=T)[[1]]) + 
    theme_bw() + 
    theme(legend.title = element_blank()))
dev.off()

ggplot() + 
    #geom_point(data=weekagg, aes(x=RelativeWeek,y=RateRatio,color=Year), alpha=0.01) + 
    geom_hline(yintercept = 1, linetype = 3) + 
    geom_line(data=weekstats, aes(x=RelativeWeek,y=Mean),size=1,color="black") + 
    geom_ribbon(data=weekstats,aes(x=RelativeWeek,ymin=(Mean+SD),ymax=(Mean-SD)),alpha=0.5) + 
    geom_vline(xintercept=c(0,1,33,34)) + 
    annotate("rect", xmin=0, xmax=1, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=33, xmax=34, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Week of the year (indexed to DST transition)") +
    ylab("Weekly Rate Ratio trends over a year (mean ± SEM)") +
    ggtitle("Individual-adjusted weekly Rate Ratio trends over a year, indexed to DST") + 
    #ylim(0.5,2) + 
    theme_bw() + 
    theme(legend.title = element_blank())

png("Individual-adjusted weekly rate ratio trends over a year, indexed to DST.png", 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
print(ggplot() + 
    #geom_point(data=weekagg, aes(x=RelativeWeek,y=RateRatio,color=Year), alpha=0.01) + 
    geom_hline(yintercept = 1, linetype = 3) + 
    geom_line(data=weekstats, aes(x=RelativeWeek,y=Mean),size=1,color="black") + 
    geom_ribbon(data=weekstats,aes(x=RelativeWeek,ymin=(Mean+SD),ymax=(Mean-SD)),alpha=0.5) + 
    geom_vline(xintercept=c(0,1,33,34)) + 
    annotate("rect", xmin=0, xmax=1, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=33, xmax=34, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Week of the year (indexed to DST transition)") +
    ylab("Weekly Rate Ratio trends over a year (mean ± SEM)") +
    ggtitle("Individual-adjusted weekly Rate Ratio trends over a year, indexed to DST") + 
    #ylim(0.5,2) + 
    theme_bw() + 
    theme(legend.title = element_blank()))
dev.off()
```
  
Individual-yearly-seizure-propensity-scaled seizure incidence rate ratios (approximated, as different denominators of person-time)
```{r rate ratio trends - scaled for individual yearly seizure counts}
#Because first (1st) and last weeks (52nd or 53rd) can be partial weeks, will remove so as not to bias averages for given weekdays
scldtrend <- Sz08to16[which(Sz08to16$weeknum > 1 & Sz08to16$weeknum < 52),]
daytrend <- data.frame("Year"=year(scldtrend$datetime),
                       "RelativeDay"=(yday(scldtrend$datetime) - scldtrend$DSTday),
                       "DailyIncidence"=scldtrend$scldIncidenceperDAY,
                       "AtRisk"=reltrend$AtRiskperDAY)
#Calculate approximate "rate ratio" relative to DST
for(i in min(daytrend$Year):max(daytrend$Year)) {
    DSTinc <- mean(daytrend[which(daytrend$RelativeDay == 0 & daytrend$Year == i),"DailyIncidence"])
    #Even though getting mean DST incidence, it can be verified that it's the same for any year: 
    print(summary(daytrend[which(daytrend$RelativeDay == 0 & daytrend$Year == i),]))
    daytrend[which(daytrend$Year == i),"RateRatio"] <- daytrend[which(daytrend$Year == i),"DailyIncidence"]/DSTinc
}
#Because each representation at a given day of the year contains the same incidence for that day, need to remove duplicates before removing outliers (can verify by checking dim of daytrend after outlier removal if unique is done before or after the outlier removal)
###TO DO (do unique before stats for general and relative chunks above)...and DO WEIGHTED AVERAGES
daytrend <- unique(daytrend)
#Eliminate spuriously extreme outliers (beyond 1st/99th percentiles)
daytrend <- daytrend[which(daytrend$RateRatio > quantile(daytrend$RateRatio, 0.01, na.rm=T)[[1]] & daytrend$RateRatio < quantile(daytrend$RateRatio, 0.99, na.rm=T)[[1]]),]
daystats <- data.frame("RelativeDay"=numeric(),
                       "Mean"=numeric(),
                       "SD"=numeric())

###PREVIOUS METHOD without weighted averages and SDs
#index=1
#for(i in min(daytrend$RelativeDay):max(daytrend$RelativeDay)) {
#    daystats[index,"RelativeDay"] <- i
#    daystats[index,"Mean"] <- mean(dayagg[which(dayagg$RelativeDay == i),"RateRatio"])
#    daystats[index,"SD"] <- sd(dayagg[which(dayagg$RelativeDay == i),"RateRatio"])
#    index=index+1
#}

index=1
for(i in min(daytrend$RelativeDay):max(daytrend$RelativeDay)) {
    daystats[index,"RelativeDay"] <- i
    #Creating a weighted average and weighted SD
    WA <- weighted.mean(daytrend[which(daytrend$RelativeDay == i),"RateRatio"], daytrend[which(daytrend$RelativeDay == i),"AtRisk"])
    daystats[index,"Mean"] <- WA
    WSD <- sqrt(sum(daytrend[which(daytrend$RelativeDay == i),"AtRisk"] * (daytrend[which(daytrend$RelativeDay == i),"RateRatio"] - WA)^2)/sum(daytrend[which(daytrend$RelativeDay == i),"AtRisk"]))
    daystats[index,"SD"] <- WSD
    index=index+1
}

ggplot() + 
    #geom_boxplot(data=daytrend, aes(x=RelativeDay, y=RateRatio), fill="#4271AE", alpha=0.5, outlier.size=NA) + #Avoid duplicate outlier plotting
    #geom_point(data=daytrend, aes(x=RelativeDay, y=RateRatio, color=factor(Year)), alpha=1, size=3) +
    geom_line() + 
    stat_summary(data=daytrend, aes(x=RelativeDay, y=RateRatio, group=Year, color=factor(Year)), geom="line", fun.y=mean) + 
    geom_hline(yintercept = mean(daytrend$RateRatio,na.rm=T)) + 
    geom_hline(yintercept = c(mean(daytrend$RateRatio,na.rm=T)+1.96*sd(daytrend$RateRatio,na.rm=T),
                              mean(daytrend$RateRatio,na.rm=T)-1.96*sd(daytrend$RateRatio,na.rm=T)),
               linetype=3) + 
    xlab("Day of year (relative to DST transition on Sunday - indexed as 0)") +
    ylab("Rate Ratio (Sz incidence compared to DST)") +
    ggtitle("Individual-scaled daily Rate Ratio trends over a year, indexed to DST") + 
    #ylim(0,quantile(daytrend$RateRatio, 0.99, na.rm=T)[[1]]) + 
    theme_bw() + 
    theme(legend.title = element_blank())

png("Individual-scaled daily rate ratios (relative to DST).png", 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
print(ggplot() + 
    #geom_boxplot(data=daytrend, aes(x=RelativeDay, y=RateRatio), fill="#4271AE", alpha=0.5, outlier.size=NA) + #Avoid duplicate outlier plotting
    #geom_point(data=daytrend, aes(x=RelativeDay, y=RateRatio, color=factor(Year)), alpha=1, size=3) +
    geom_line() + 
    stat_summary(data=daytrend, aes(x=RelativeDay, y=RateRatio, group=Year, color=factor(Year)), geom="line", fun.y=mean) + 
    geom_hline(yintercept = mean(daytrend$RateRatio,na.rm=T)) + 
    geom_hline(yintercept = c(mean(daytrend$RateRatio,na.rm=T)+1.96*sd(daytrend$RateRatio,na.rm=T),
                              mean(daytrend$RateRatio,na.rm=T)-1.96*sd(daytrend$RateRatio,na.rm=T)),
               linetype=3) + 
    xlab("Day of year (relative to DST transition on Sunday - indexed as 0)") +
    ylab("Rate Ratio (Sz incidence compared to DST)") +
    ggtitle("Individual-scaled daily Rate Ratio trends over a year, indexed to DST") + 
    #ylim(0,quantile(daytrend$RateRatio, 0.99, na.rm=T)[[1]]) + 
    theme_bw() + 
    theme(legend.title = element_blank()))
dev.off()

ggplot() + 
    #geom_point(data=daytrend,
    #           aes(x=RelativeDay,y=RateRatio,color=factor(Year)), 
    #           alpha=0.25) + 
    geom_hline(yintercept = 1, linetype = 3) + 
    geom_smooth(data=daytrend,
                aes(x=RelativeDay,y=RateRatio,color=factor(Year)),
                method="loess",
                span=0.1,
                se=FALSE) + 
    geom_smooth(data=daytrend,
                aes(x=RelativeDay,y=RateRatio,color=factor(Year)), 
                method="loess",
                span=7/365,
                se=TRUE,
                alpha=0.75,
                colour="black") + 
    geom_vline(xintercept=c(0,7,237,244)) + 
    annotate("rect", xmin=0, xmax=7, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=237, xmax=244, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Day of the year (indexed to DST transition)") +
    ylab("Daily Rate Ratio trends over a year (mean ± SEM)") +
    ggtitle("Individual-scaled daily Rate Ratio trends over a year, indexed to DST") + 
    #ylim(0.5,2.25) + 
    theme_bw() + 
    theme(legend.title = element_blank())

png("Individual-scaled daily rate ratios with loess averaging of trends.png", 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
print(ggplot() + 
    #geom_point(data=daytrend,
    #           aes(x=RelativeDay,y=RateRatio,color=factor(Year)), 
    #           alpha=0.25) + 
    geom_hline(yintercept = 1, linetype = 3) + 
    geom_smooth(data=daytrend,
                aes(x=RelativeDay,y=RateRatio,color=factor(Year)),
                method="loess",
                span=0.1,
                se=FALSE) + 
    geom_smooth(data=daytrend,
                aes(x=RelativeDay,y=RateRatio,color=factor(Year)), 
                method="loess",
                span=7/365,
                se=TRUE,
                alpha=0.75,
                colour="black") + 
    geom_vline(xintercept=c(0,7,237,244)) + 
    annotate("rect", xmin=0, xmax=7, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=237, xmax=244, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Day of the year (indexed to DST transition)") +
    ylab("Daily Rate Ratio trends over a year (mean ± SEM)") +
    ggtitle("Individual-scaled daily Rate Ratio trends over a year, indexed to DST") + 
    #ylim(0.5,2.25) + 
    theme_bw() + 
    theme(legend.title = element_blank())
)
dev.off()

ggplot() + 
    #geom_point(data=daytrend, aes(x=RelativeDay,y=RateRatio,color=Year), alpha=0.01) + 
    geom_hline(yintercept = 1, linetype = 3) + 
    geom_line(data=daystats, aes(x=RelativeDay,y=Mean),size=1,color="black") + 
    geom_ribbon(data=daystats,aes(x=RelativeDay,ymin=(Mean+SD),ymax=(Mean-SD)),alpha=0.5) + 
    geom_vline(xintercept=c(0,7,237,244)) + 
    annotate("rect", xmin=0, xmax=7, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=237, xmax=244, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Day of the year (indexed to DST transition)") +
    ylab("Daily Rate Ratio trends over a year (mean ± SD)") +
    ggtitle("Individual-scaled daily Rate Ratio trends over a year, indexed to DST") + 
    #ylim(0.5,2) + 
    theme_bw() + 
    theme(legend.title = element_blank())

png("Individual-scaled daily rate ratio trends over a year, indexed to DST.png", 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
print(ggplot() + 
    #geom_point(data=daytrend, aes(x=RelativeDay,y=RateRatio,color=Year), alpha=0.01) + 
    geom_hline(yintercept = 1, linetype = 3) + 
    geom_line(data=daystats, aes(x=RelativeDay,y=Mean),size=1,color="black") + 
    geom_ribbon(data=daystats,aes(x=RelativeDay,ymin=(Mean+SD),ymax=(Mean-SD)),alpha=0.5) + 
    geom_vline(xintercept=c(0,7,237,244)) + 
    annotate("rect", xmin=0, xmax=7, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=237, xmax=244, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Day of the year (indexed to DST transition)") +
    ylab("Daily Rate Ratio trends over a year (mean ± SD)") +
    ggtitle("Individual-scaled daily Rate Ratio trends over a year, indexed to DST") + 
    #ylim(0.5,2) + 
    theme_bw() + 
    theme(legend.title = element_blank()))
dev.off()

weektrend <- data.frame("Year"=year(scldtrend$datetime),
                        "RelativeWeek"=(week(scldtrend$datetime) - scldtrend$DSTweek),
                        "WeeklyIncidence"=scldtrend$scldIncidenceperWEEK,
                        "AtRisk"=reltrend$AtRiskperWEEK)
#Calculate approximate "rate ratio" relative to DST
for(i in min(weektrend$Year):max(weektrend$Year)) {
    DSTinc <- mean(weektrend[which(weektrend$RelativeWeek == 0 & weektrend$Year == i),"WeeklyIncidence"])
    #Even though getting mean DST incidence, it can be verified that it's the same for any year: 
    print(summary(weektrend[which(weektrend$RelativeWeek == 0 & weektrend$Year == i),]))
    weektrend[which(weektrend$Year == i),"RateRatio"] <- weektrend[which(weektrend$Year == i),"WeeklyIncidence"]/DSTinc
}
#Removing duplicate entries (should be the case for each week to have n duplicates, where n is the number of seizures that contributed to the incidence in that time period)...important to remove before outlier removal as different Ns per week will cause biased outlier removal
weektrend <- unique(weektrend)
#Eliminate spuriously extreme outliers (beyond 1st/99th percentiles)
weektrend <- weektrend[which(weektrend$RateRatio > quantile(weektrend$RateRatio, 0.01, na.rm=T)[[1]] & weektrend$RateRatio < quantile(weektrend$RateRatio, 0.99, na.rm=T)[[1]]),]
weekstats <- data.frame("RelativeWeek"=numeric(),
                        "Mean"=numeric(),
                        "SD"=numeric())

###PREVIOUS METHOD without weighted averages and SDs
#index=1
#for(i in min(weektrend$RelativeWeek):max(weektrend$RelativeWeek)) {
#    weekstats[index,"RelativeWeek"] <- i
#    weekstats[index,"Mean"] <- mean(weektrend[which(weektrend$RelativeWeek == i),"RateRatio"])
#    weekstats[index,"SD"] <- sd(weektrend[which(weektrend$RelativeWeek == i),"RateRatio"])#/nrow(weektrend[which(weektrend$RelativeWeek == i),])
#    index=index+1
#}

index=1
for(i in min(weektrend$RelativeWeek):max(weektrend$RelativeWeek)) {
    weekstats[index,"RelativeWeek"] <- i
    #Creating a weighted average and weighted SD
    WA <- weighted.mean(weektrend[which(weektrend$RelativeWeek == i),"RateRatio"], weektrend[which(weektrend$RelativeWeek == i),"AtRisk"])
    weekstats[index,"Mean"] <- WA
    WSD <- sqrt(sum(weektrend[which(weektrend$RelativeWeek == i),"AtRisk"] * (weektrend[which(weektrend$RelativeWeek == i),"RateRatio"] - WA)^2)/sum(weektrend[which(weektrend$RelativeWeek == i),"AtRisk"]))
    weekstats[index,"SD"] <- WSD
    index=index+1
}

ggplot() + 
    #geom_boxplot(data=weektrend, aes(x=RelativeWeek, y=RateRatio), fill="#4271AE", alpha=0.5, outlier.size=NA) + #Avoid duplicate outlier plotting
    #geom_point(data=weektrend, aes(x=RelativeWeek, y=RateRatio, color=factor(Year)), alpha=1, size=3) +
    geom_line() + 
    stat_summary(data=weektrend, aes(x=RelativeWeek, y=RateRatio, group=Year, color=factor(Year)), geom="line", fun.y=mean) + 
    geom_hline(yintercept = mean(weektrend$RateRatio,na.rm=T)) + 
    geom_hline(yintercept = c(mean(weektrend$RateRatio,na.rm=T)+1.96*sd(weektrend$RateRatio,na.rm=T),
                              mean(weektrend$RateRatio,na.rm=T)-1.96*sd(weektrend$RateRatio,na.rm=T)),
               linetype=3) + 
    xlab("Week of year (relative to DST transition on Sunday - indexed as 0)") +
    ylab("Rate Ratio (Sz incidence compared to DST)") +
    ggtitle("Individual-scaled weekly Rate Ratio trends over a year, indexed to DST") + 
    #ylim(0,quantile(weektrend$RateRatio, 0.99, na.rm=T)[[1]]) + 
    theme_bw() + 
    theme(legend.title = element_blank())

png("Individual-scaled weekly rate ratios (relative to DST).png", 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
print(ggplot() + 
    #geom_boxplot(data=weektrend, aes(x=RelativeWeek, y=RateRatio), fill="#4271AE", alpha=0.5, outlier.size=NA) + #Avoid duplicate outlier plotting
    #geom_point(data=weektrend, aes(x=RelativeWeek, y=RateRatio, color=factor(Year)), alpha=1, size=3) +
    geom_line() + 
    stat_summary(data=weektrend, aes(x=RelativeWeek, y=RateRatio, group=Year, color=factor(Year)), geom="line", fun.y=mean) + 
    geom_hline(yintercept = mean(weektrend$RateRatio,na.rm=T)) + 
    geom_hline(yintercept = c(mean(weektrend$RateRatio,na.rm=T)+1.96*sd(weektrend$RateRatio,na.rm=T),
                              mean(weektrend$RateRatio,na.rm=T)-1.96*sd(weektrend$RateRatio,na.rm=T)),
               linetype=3) + 
    xlab("Week of year (relative to DST transition on Sunday - indexed as 0)") +
    ylab("Rate Ratio (Sz incidence compared to DST)") +
    ggtitle("Individual-scaled weekly Rate Ratio trends over a year, indexed to DST") + 
    #ylim(0,quantile(weektrend$RateRatio, 0.99, na.rm=T)[[1]]) + 
    theme_bw() + 
    theme(legend.title = element_blank()))
dev.off()

ggplot() + 
    geom_point(data=weektrend,
               aes(x=RelativeWeek,y=RateRatio,color=factor(Year)), 
               alpha=0.5) + 
    #geom_smooth(method="loess", span=1/52, se=TRUE, alpha=0.3, colour="red") + 
    geom_smooth(data=weektrend,
                aes(x=RelativeWeek,y=RateRatio,color=factor(Year)), 
                method="loess",
                span=0.1,
                se=TRUE,
                alpha=0.5,
                colour="black") + 
    geom_vline(xintercept=c(0,1,33,34)) + 
    annotate("rect", xmin=0, xmax=1, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=33, xmax=34, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Week of the year (indexed to DST transition)") +
    ylab("Weekly Rate Ratio trends over a year (mean ± SEM)") +
    ggtitle("Individual-scaled weekly Rate Ratio trends over a year, indexed to DST") + 
    #ylim(0,quantile(weektrend$RateRatio, 0.99, na.rm=T)[[1]]) + 
    theme_bw() + 
    theme(legend.title = element_blank())

ggplot(data=weektrend,
       aes(x=RelativeWeek,y=RateRatio,color=factor(Year))) + 
    #geom_point(alpha=0.3) + 
    geom_smooth(se=FALSE, method="loess", span=0.3) + 
    geom_smooth(method="loess",
                span=0.1,
                se=TRUE,
                alpha=0.75,
                colour="black") + 
    geom_vline(xintercept=c(0,1,33,34)) + 
    annotate("rect", xmin=0, xmax=1, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=33, xmax=34, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Week of the year (indexed to DST transition)") +
    ylab("Weekly Rate Ratio trends over a year (mean ± SEM)") +
    ggtitle("Individual-scaled weekly Rate Ratio trends over a year, indexed to DST") + 
    #ylim(0,quantile(weektrend$RateRatio, 0.99, na.rm=T)[[1]]) + 
    theme_bw() + 
    theme(legend.title = element_blank())

png("Individual-scaled weekly rate ratios with loess averaging and yearly trends.png", 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
print(ggplot(data=weektrend,
       aes(x=RelativeWeek,y=RateRatio,color=factor(Year))) + 
    #geom_point(alpha=0.3) + 
    geom_smooth(se=FALSE, method="loess", span=0.3) + 
    geom_smooth(method="loess",
                span=0.1,
                se=TRUE,
                alpha=0.75,
                colour="black") + 
    geom_vline(xintercept=c(0,1,33,34)) + 
    annotate("rect", xmin=0, xmax=1, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=33, xmax=34, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Week of the year (indexed to DST transition)") +
    ylab("Weekly Rate Ratio trends over a year (mean ± SEM)") +
    ggtitle("Individual-scaled weekly Rate Ratio trends over a year, indexed to DST") + 
    #ylim(0,quantile(weektrend$RateRatio, 0.99, na.rm=T)[[1]]) + 
    theme_bw() + 
    theme(legend.title = element_blank()))
dev.off()

ggplot() + 
    #geom_point(data=weektrend, aes(x=RelativeWeek,y=RateRatio,color=Year), alpha=0.01) + 
    geom_hline(yintercept = 1, linetype = 3) + 
    geom_line(data=weekstats, aes(x=RelativeWeek,y=Mean),size=1,color="black") + 
    geom_ribbon(data=weekstats,aes(x=RelativeWeek,ymin=(Mean+SD),ymax=(Mean-SD)),alpha=0.5) + 
    geom_vline(xintercept=c(0,1,33,34)) + 
    annotate("rect", xmin=0, xmax=1, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=33, xmax=34, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Week of the year (indexed to DST transition)") +
    ylab("Weekly Rate Ratio trends over a year (mean ± SD)") +
    ggtitle("Individual-scaled weekly Rate Ratio trends over a year, indexed to DST") + 
    #ylim(0.5,2) + 
    theme_bw() + 
    theme(legend.title = element_blank())

png("Individual-scaled weekly rate ratio trends over a year, indexed to DST.png", 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
print(ggplot() + 
    #geom_point(data=weektrend, aes(x=RelativeWeek,y=RateRatio,color=Year), alpha=0.01) + 
    geom_hline(yintercept = 1, linetype = 3) + 
    geom_line(data=weekstats, aes(x=RelativeWeek,y=Mean),size=1,color="black") + 
    geom_ribbon(data=weekstats,aes(x=RelativeWeek,ymin=(Mean+SD),ymax=(Mean-SD)),alpha=0.5) + 
    geom_vline(xintercept=c(0,1,33,34)) + 
    annotate("rect", xmin=0, xmax=1, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=33, xmax=34, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Week of the year (indexed to DST transition)") +
    ylab("Weekly Rate Ratio trends over a year (mean ± SD)") +
    ggtitle("Individual-scaled weekly Rate Ratio trends over a year, indexed to DST") + 
    #ylim(0.5,2) + 
    theme_bw() + 
    theme(legend.title = element_blank()))
dev.off()
```
  
Diurnal vs nocturnal individual-yearly-seizure-propensity-scaled seizure incidence rate ratios (approximated, as different denominators of person-time)
```{r Diem vs Nocturnum rate ratio trends - scaled for individual yearly seizure counts}
#Because first (1st) and last weeks (52nd or 53rd) can be partial weeks, will remove so as not to bias averages for given weekdays
diemtrend <- Day08to16[which(Sz08to16$weeknum > 1 & Sz08to16$weeknum < 52 & Sz08to16$overnight == 0),]
nocttrend <- Night08to16[which(Sz08to16$weeknum > 1 & Sz08to16$weeknum < 52 & Sz08to16$overnight == 1),]
daytrend <- data.frame("Year"=year(diemtrend$datetime),
                       "RelativeDay"=(yday(diemtrend$datetime) - diemtrend$DSTday),
                       "DailyIncidence"=diemtrend$scldIncidenceperDAY,
                       "AtRisk"=diemtrend$AtRiskperDAY)
daytrend <- na.omit(daytrend)
nighttrend <- data.frame("Year"=year(nocttrend$datetime),
                         "RelativeDay"=(yday(nocttrend$datetime) - nocttrend$DSTday),
                         "DailyIncidence"=nocttrend$scldIncidenceperDAY,
                         "AtRisk"=nocttrend$AtRiskperDAY)
nighttrend <- na.omit(nighttrend)
#Calculate approximate "rate ratio" relative to DST
for(i in min(daytrend$Year):max(daytrend$Year)) {
    DSTinc <- mean(daytrend[which(daytrend$RelativeDay == 0 & daytrend$Year == i),"DailyIncidence"])
    #Even though getting mean DST incidence, it can be verified that it's the same for any year: 
    print(summary(daytrend[which(daytrend$RelativeDay == 0 & daytrend$Year == i),]))
    daytrend[which(daytrend$Year == i),"RateRatio"] <- daytrend[which(daytrend$Year == i),"DailyIncidence"]/DSTinc
}
for(i in min(nighttrend$Year):max(nighttrend$Year)) {
    DSTinc <- mean(nighttrend[which(nighttrend$RelativeDay == 0 & nighttrend$Year == i),"DailyIncidence"])
    #Even though getting mean DST incidence, it can be verified that it's the same for any year: 
    print(summary(nighttrend[which(nighttrend$RelativeDay == 0 & nighttrend$Year == i),]))
    nighttrend[which(nighttrend$Year == i),"RateRatio"] <- nighttrend[which(nighttrend$Year == i),"DailyIncidence"]/DSTinc
}
#Because each representation at a given day of the year contains the same incidence for that day, need to remove duplicates before removing outliers (can verify by checking dim of daytrend after outlier removal if unique is done before or after the outlier removal)
daytrend <- unique(daytrend)
#Eliminate spuriously extreme outliers (beyond 1st/99th percentiles)
daytrend <- daytrend[which(daytrend$RateRatio > quantile(daytrend$RateRatio, 0.01, na.rm=T)[[1]] & daytrend$RateRatio < quantile(daytrend$RateRatio, 0.99, na.rm=T)[[1]]),]
daystats <- data.frame("RelativeDay"=numeric(),
                       "Mean"=numeric(),
                       "SD"=numeric())
nighttrend <- unique(nighttrend)
#Eliminate spuriously extreme outliers (beyond 1st/99th percentiles)
nighttrend <- nighttrend[which(nighttrend$RateRatio > quantile(nighttrend$RateRatio, 0.01, na.rm=T)[[1]] & nighttrend$RateRatio < quantile(nighttrend$RateRatio, 0.99, na.rm=T)[[1]]),]
nightstats <- data.frame("RelativeDay"=numeric(),
                         "Mean"=numeric(),
                         "SD"=numeric())

###PREVIOUS METHOD without weighted averages and SDs
#index=1
#for(i in min(daytrend$RelativeDay):max(daytrend$RelativeDay)) {
#    daystats[index,"RelativeDay"] <- i
#    daystats[index,"Mean"] <- mean(dayagg[which(dayagg$RelativeDay == i),"RateRatio"])
#    daystats[index,"SD"] <- sd(dayagg[which(dayagg$RelativeDay == i),"RateRatio"])
#    index=index+1
#}

index=1
for(i in min(daytrend$RelativeDay):max(daytrend$RelativeDay)) {
    daystats[index,"RelativeDay"] <- i
    #Creating a weighted average and weighted SD
    WA <- weighted.mean(daytrend[which(daytrend$RelativeDay == i),"RateRatio"], daytrend[which(daytrend$RelativeDay == i),"AtRisk"])
    daystats[index,"Mean"] <- WA
    WSD <- sqrt(sum(daytrend[which(daytrend$RelativeDay == i),"AtRisk"] * (daytrend[which(daytrend$RelativeDay == i),"RateRatio"] - WA)^2)/sum(daytrend[which(daytrend$RelativeDay == i),"AtRisk"]))
    daystats[index,"SD"] <- WSD
    index=index+1
}
index=1
for(i in min(nighttrend$RelativeDay):max(nighttrend$RelativeDay)) {
    nightstats[index,"RelativeDay"] <- i
    #Creating a weighted average and weighted SD
    WA <- weighted.mean(nighttrend[which(nighttrend$RelativeDay == i),"RateRatio"], nighttrend[which(nighttrend$RelativeDay == i),"AtRisk"])
    nightstats[index,"Mean"] <- WA
    WSD <- sqrt(sum(nighttrend[which(nighttrend$RelativeDay == i),"AtRisk"] * (nighttrend[which(nighttrend$RelativeDay == i),"RateRatio"] - WA)^2)/sum(nighttrend[which(nighttrend$RelativeDay == i),"AtRisk"]))
    nightstats[index,"SD"] <- WSD
    index=index+1
}

ggplot() + 
    #geom_boxplot(data=daytrend, aes(x=RelativeDay, y=RateRatio), fill="#4271AE", alpha=0.5, outlier.size=NA) + #Avoid duplicate outlier plotting
    #geom_point(data=daytrend, aes(x=RelativeDay, y=RateRatio, color=factor(Year)), alpha=1, size=3) +
    geom_line() + 
    stat_summary(data=daytrend, aes(x=RelativeDay, y=RateRatio, group=Year, color=factor(Year)), geom="line", fun.y=mean) + 
    geom_hline(yintercept = mean(daytrend$RateRatio,na.rm=T)) + 
    geom_hline(yintercept = c(mean(daytrend$RateRatio,na.rm=T)+1.96*sd(daytrend$RateRatio,na.rm=T),
                              mean(daytrend$RateRatio,na.rm=T)-1.96*sd(daytrend$RateRatio,na.rm=T)),
               linetype=3) + 
    xlab("Day of year (relative to DST transition on Sunday - indexed as 0)") +
    ylab("Rate Ratio (Sz incidence compared to DST)") +
    ggtitle("Individual-scaled daily Rate Ratio trends over a year, indexed to DST") + 
    #ylim(0,quantile(daytrend$RateRatio, 0.99, na.rm=T)[[1]]) + 
    theme_bw() + 
    theme(legend.title = element_blank())

png("Individual-scaled daily rate ratios (relative to DST).png", 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
print(ggplot() + 
    #geom_boxplot(data=daytrend, aes(x=RelativeDay, y=RateRatio), fill="#4271AE", alpha=0.5, outlier.size=NA) + #Avoid duplicate outlier plotting
    #geom_point(data=daytrend, aes(x=RelativeDay, y=RateRatio, color=factor(Year)), alpha=1, size=3) +
    geom_line() + 
    stat_summary(data=daytrend, aes(x=RelativeDay, y=RateRatio, group=Year, color=factor(Year)), geom="line", fun.y=mean) + 
    geom_hline(yintercept = mean(daytrend$RateRatio,na.rm=T)) + 
    geom_hline(yintercept = c(mean(daytrend$RateRatio,na.rm=T)+1.96*sd(daytrend$RateRatio,na.rm=T),
                              mean(daytrend$RateRatio,na.rm=T)-1.96*sd(daytrend$RateRatio,na.rm=T)),
               linetype=3) + 
    xlab("Day of year (relative to DST transition on Sunday - indexed as 0)") +
    ylab("Rate Ratio (Sz incidence compared to DST)") +
    ggtitle("Individual-scaled daily Rate Ratio trends over a year, indexed to DST") + 
    #ylim(0,quantile(daytrend$RateRatio, 0.99, na.rm=T)[[1]]) + 
    theme_bw() + 
    theme(legend.title = element_blank()))
dev.off()

ggplot() + 
    #geom_point(data=daytrend,
    #           aes(x=RelativeDay,y=RateRatio,color=factor(Year)), 
    #           alpha=0.25) + 
    geom_hline(yintercept = 1, linetype = 3) + 
    #geom_smooth(data=daytrend,
    #            aes(x=RelativeDay,y=RateRatio,color=factor(Year)),
    #            method="loess",
    #            span=0.1,
    #            se=FALSE) + 
    geom_smooth(data=daytrend,
                aes(x=RelativeDay,y=RateRatio,color=factor(Year)), 
                method="loess",
                span=7/365,
                se=TRUE,
                alpha=0.5,
                colour="orange4",
                fill="orange1") + 
    #geom_smooth(data=nighttrend,
    #            aes(x=RelativeDay,y=RateRatio,color=factor(Year)),
    #            method="loess",
    #            span=0.1,
    #            se=FALSE) + 
    geom_smooth(data=nighttrend,
                aes(x=RelativeDay,y=RateRatio,color=factor(Year)), 
                method="loess",
                span=7/365,
                se=TRUE,
                alpha=0.5,
                colour="blue4",
                fill="blue1") + 
    geom_vline(xintercept=c(0,7,237,244)) + 
    annotate("rect", xmin=0, xmax=7, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=237, xmax=244, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Day of the year (indexed to DST transition)") +
    ylab("Daily Rate Ratio trends over a year (mean ± SEM)") +
    ggtitle("Individual-scaled day and night Rate Ratio trends over a year, indexed to DST") + 
    #ylim(0.5,2.25) + 
    theme_bw() + 
    theme(legend.title = element_blank())

png("Individual-scaled day and night rate ratios with loess averaging of trends.png", 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
print(ggplot() + 
    #geom_point(data=daytrend,
    #           aes(x=RelativeDay,y=RateRatio,color=factor(Year)), 
    #           alpha=0.25) + 
    geom_hline(yintercept = 1, linetype = 3) + 
    #geom_smooth(data=daytrend,
    #            aes(x=RelativeDay,y=RateRatio,color=factor(Year)),
    #            method="loess",
    #            span=0.1,
    #            se=FALSE) + 
    geom_smooth(data=daytrend,
                aes(x=RelativeDay,y=RateRatio,color=factor(Year)), 
                method="loess",
                span=7/365,
                se=TRUE,
                alpha=0.5,
                colour="orange4",
                fill="orange1") + 
    #geom_smooth(data=nighttrend,
    #            aes(x=RelativeDay,y=RateRatio,color=factor(Year)),
    #            method="loess",
    #            span=0.1,
    #            se=FALSE) + 
    geom_smooth(data=nighttrend,
                aes(x=RelativeDay,y=RateRatio,color=factor(Year)), 
                method="loess",
                span=7/365,
                se=TRUE,
                alpha=0.5,
                colour="blue4",
                fill="blue1") + 
    geom_vline(xintercept=c(0,7,237,244)) + 
    annotate("rect", xmin=0, xmax=7, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=237, xmax=244, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Day of the year (indexed to DST transition)") +
    ylab("Daily Rate Ratio trends over a year (mean ± SEM)") +
    ggtitle("Individual-scaled day and night Rate Ratio trends over a year, indexed to DST") + 
    #ylim(0.5,2.25) + 
    theme_bw() + 
    theme(legend.title = element_blank()))
dev.off()

ggplot() + 
    #geom_point(data=daytrend, aes(x=RelativeDay,y=RateRatio,color=Year), alpha=0.01) + 
    geom_hline(yintercept = 1, linetype = 3) + 
    geom_line(data=daystats, aes(x=RelativeDay,y=Mean),size=1,color="orange1") + 
    geom_ribbon(data=daystats,aes(x=RelativeDay,ymin=(Mean+SD),ymax=(Mean-SD)),alpha=0.5,fill="orange1") + 
    geom_line(data=nightstats, aes(x=RelativeDay,y=Mean),size=1,color="blue4") + 
    geom_ribbon(data=nightstats,aes(x=RelativeDay,ymin=(Mean+SD),ymax=(Mean-SD)),alpha=0.5,fill="blue4") + 
    geom_vline(xintercept=c(0,7,237,244)) + 
    annotate("rect", xmin=0, xmax=7, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=237, xmax=244, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Day of the year (indexed to DST transition)") +
    ylab("Daily Rate Ratio trends over a year (mean ± SD)") +
    ggtitle("Individual-scaled day and night Rate Ratio trends over a year, indexed to DST") + 
    #ylim(0.5,2) + 
    theme_bw() + 
    theme(legend.title = element_blank())

png("Individual-scaled day and night rate ratio trends over a year, indexed to DST.png", 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
ggplot() + 
    #geom_point(data=daytrend, aes(x=RelativeDay,y=RateRatio,color=Year), alpha=0.01) + 
    geom_hline(yintercept = 1, linetype = 3) + 
    geom_line(data=daystats, aes(x=RelativeDay,y=Mean),size=1,color="orange1") + 
    geom_ribbon(data=daystats,aes(x=RelativeDay,ymin=(Mean+SD),ymax=(Mean-SD)),alpha=0.5,fill="orange1") + 
    geom_line(data=nightstats, aes(x=RelativeDay,y=Mean),size=1,color="blue4") + 
    geom_ribbon(data=nightstats,aes(x=RelativeDay,ymin=(Mean+SD),ymax=(Mean-SD)),alpha=0.5,fill="blue4") + 
    geom_vline(xintercept=c(0,7,237,244)) + 
    annotate("rect", xmin=0, xmax=7, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=237, xmax=244, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Day of the year (indexed to DST transition)") +
    ylab("Daily Rate Ratio trends over a year (mean ± SD)") +
    ggtitle("Individual-scaled day and night Rate Ratio trends over a year, indexed to DST") + 
    #ylim(0.5,2) + 
    theme_bw() + 
    theme(legend.title = element_blank())
dev.off()

ggplot() + 
    #geom_point(data=daytrend, aes(x=RelativeDay,y=RateRatio,color=Year), alpha=0.01) + 
    geom_hline(yintercept = 1, linetype = 3) + 
    geom_line(data=daystats, aes(x=RelativeDay,y=Mean),size=1,color="orange1") + 
    geom_ribbon(data=daystats,aes(x=RelativeDay,ymin=(Mean+SD),ymax=(Mean-SD)),alpha=0.5,fill="orange1") + 
    geom_vline(xintercept=c(0,7,237,244)) + 
    annotate("rect", xmin=0, xmax=7, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=237, xmax=244, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Day of the year (indexed to DST transition)") +
    ylab("Daily Rate Ratio trends over a year (mean ± SD)") +
    ggtitle("Individual-scaled daytime Rate Ratio trends over a year, indexed to DST") + 
    ylim(0.5,2.25) + 
    theme_bw() + 
    theme(legend.title = element_blank())

png("Individual-scaled daytime rate ratio trends over a year, indexed to DST.png", 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
ggplot() + 
    #geom_point(data=daytrend, aes(x=RelativeDay,y=RateRatio,color=Year), alpha=0.01) + 
    geom_hline(yintercept = 1, linetype = 3) + 
    geom_line(data=daystats, aes(x=RelativeDay,y=Mean),size=1,color="orange1") + 
    geom_ribbon(data=daystats,aes(x=RelativeDay,ymin=(Mean+SD),ymax=(Mean-SD)),alpha=0.5,fill="orange1") + 
    geom_vline(xintercept=c(0,7,237,244)) + 
    annotate("rect", xmin=0, xmax=7, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=237, xmax=244, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Day of the year (indexed to DST transition)") +
    ylab("Daily Rate Ratio trends over a year (mean ± SD)") +
    ggtitle("Individual-scaled daytime Rate Ratio trends over a year, indexed to DST") + 
    ylim(0.5,2.25) + 
    theme_bw() + 
    theme(legend.title = element_blank())
dev.off()

ggplot() + 
    #geom_point(data=daytrend, aes(x=RelativeDay,y=RateRatio,color=Year), alpha=0.01) + 
    geom_hline(yintercept = 1, linetype = 3) + 
    geom_line(data=nightstats, aes(x=RelativeDay,y=Mean),size=1,color="blue4") + 
    geom_ribbon(data=nightstats,aes(x=RelativeDay,ymin=(Mean+SD),ymax=(Mean-SD)),alpha=0.5,fill="blue4") + 
    geom_vline(xintercept=c(0,7,237,244)) + 
    annotate("rect", xmin=0, xmax=7, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=237, xmax=244, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Day of the year (indexed to DST transition)") +
    ylab("Daily Rate Ratio trends over a year (mean ± SD)") +
    ggtitle("Individual-scaled nighttime Rate Ratio trends over a year, indexed to DST") + 
    ylim(0.5,2.25) + 
    theme_bw() + 
    theme(legend.title = element_blank())

png("Individual-scaled nighttime rate ratio trends over a year, indexed to DST.png", 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
ggplot() + 
    #geom_point(data=daytrend, aes(x=RelativeDay,y=RateRatio,color=Year), alpha=0.01) + 
    geom_hline(yintercept = 1, linetype = 3) + 
    geom_line(data=nightstats, aes(x=RelativeDay,y=Mean),size=1,color="blue4") + 
    geom_ribbon(data=nightstats,aes(x=RelativeDay,ymin=(Mean+SD),ymax=(Mean-SD)),alpha=0.5,fill="blue4") + 
    geom_vline(xintercept=c(0,7,237,244)) + 
    annotate("rect", xmin=0, xmax=7, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=237, xmax=244, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Day of the year (indexed to DST transition)") +
    ylab("Daily Rate Ratio trends over a year (mean ± SD)") +
    ggtitle("Individual-scaled nighttime Rate Ratio trends over a year, indexed to DST") + 
    ylim(0.5,2.25) + 
    theme_bw() + 
    theme(legend.title = element_blank())
dev.off()
```
  
Seizure count comparisons by weekday
```{r a function for comparing weekdays, defaulted comparison between DST and all non-DST}
compareweekdays <- function(firstweek=Sz08to16wkofDST,
                            secondweek=Sz08to16notDST,
                            wkone="week of DST",
                            wktwo="all non DST") {
    
    #Get seizure counts for each day of the week in DST
    #-this is tabulated BY DATE (i.e. all Sz on Sunday 2008-03-16)
    #-this allows for independent t-tests (albeit suboptimal compared to paired t-tests)
    SUNinDST <- firstweek[which(firstweek$wkday == "Sunday"),"datetime"]
    SUNcount <- table(as.Date(SUNinDST,'America/Los_Angeles'))
    SUNcountdf <- as.data.frame(SUNcount)
    MONinDST <- firstweek[which(firstweek$wkday == "Monday"),"datetime"]
    MONcount <- table(as.Date(MONinDST,'America/Los_Angeles'))
    MONcountdf <- as.data.frame(MONcount)
    TUEinDST <- firstweek[which(firstweek$wkday == "Tuesday"),"datetime"]
    TUEcount <- table(as.Date(TUEinDST,'America/Los_Angeles'))
    TUEcountdf <- as.data.frame(TUEcount)
    WEDinDST <- firstweek[which(firstweek$wkday == "Wednesday"),"datetime"]
    WEDcount <- table(as.Date(WEDinDST,'America/Los_Angeles'))
    WEDcountdf <- as.data.frame(WEDcount)
    THUinDST <- firstweek[which(firstweek$wkday == "Thursday"),"datetime"]
    THUcount <- table(as.Date(THUinDST,'America/Los_Angeles'))
    THUcountdf <- as.data.frame(THUcount)
    FRIinDST <- firstweek[which(firstweek$wkday == "Friday"),"datetime"]
    FRIcount <- table(as.Date(FRIinDST,'America/Los_Angeles'))
    FRIcountdf <- as.data.frame(FRIcount)
    SATinDST <- firstweek[which(firstweek$wkday == "Saturday"),"datetime"]
    SATcount <- table(as.Date(SATinDST,'America/Los_Angeles'))
    SATcountdf <- as.data.frame(SATcount)
    
    #Get seizure counts for each day of the week not in DST
    #-this is tabulated BY DATE (i.e. all Sz on Sunday 2008-03-16)
    SUNnonDST <- secondweek[which(secondweek$wkday == "Sunday"),"datetime"]
    SUNcounts <- table(as.Date(SUNnonDST,'America/Los_Angeles'))
    SUNcountsdf <- as.data.frame(SUNcounts)
    MONnonDST <- secondweek[which(secondweek$wkday == "Monday"),"datetime"]
    MONcounts <- table(as.Date(MONnonDST,'America/Los_Angeles'))
    MONcountsdf <- as.data.frame(MONcounts)
    TUEnonDST <- secondweek[which(secondweek$wkday == "Tuesday"),"datetime"]
    TUEcounts <- table(as.Date(TUEnonDST,'America/Los_Angeles'))
    TUEcountsdf <- as.data.frame(TUEcounts)
    WEDnonDST <- secondweek[which(secondweek$wkday == "Wednesday"),"datetime"]
    WEDcounts <- table(as.Date(WEDnonDST,'America/Los_Angeles'))
    WEDcountsdf <- as.data.frame(WEDcounts)
    THUnonDST <- secondweek[which(secondweek$wkday == "Thursday"),"datetime"]
    THUcounts <- table(as.Date(THUnonDST,'America/Los_Angeles'))
    THUcountsdf <- as.data.frame(THUcounts)
    FRInonDST <- secondweek[which(secondweek$wkday == "Friday"),"datetime"]
    FRIcounts <- table(as.Date(FRInonDST,'America/Los_Angeles'))
    FRIcountsdf <- as.data.frame(FRIcounts)
    SATnonDST <- secondweek[which(secondweek$wkday == "Saturday"),"datetime"]
    SATcounts <- table(as.Date(SATnonDST,'America/Los_Angeles'))
    SATcountsdf <- as.data.frame(SATcounts)
    
    #T-tests (x is for weekdays in DST, y is for comparison weeks):
    print(SunT <- t.test(SUNcount,SUNcounts))
    print(MonT <- t.test(MONcount,MONcounts))
    print(TueT <- t.test(TUEcount,TUEcounts))
    print(WedT <- t.test(WEDcount,WEDcounts))
    print(ThuT <- t.test(THUcount,THUcounts))
    print(FriT <- t.test(FRIcount,FRIcounts))
    print(SatT <- t.test(SATcount,SATcounts))
    
    #Getting person-count approximate denominators and incidence rates for each day
    # -note this denominator of person-time is inaccurate for multiple reasons:
    #  +it counts people "at risk" only if they've documented a seizure - i.e. ascertainment bias for those reporting
    #  +it doesn't account for single documenters that then stop using the app - also an ascertainment bias
    #  +it doesn't account for interventions (i.e. surgery, changes in regimen), assuming similar risk over similar time periods
    #  +it doesn't account for "voyeurs" - people who signed up, but haven't documented yet
    
    #Creating list of count data frames
    l.df <- lapply(ls(pattern="[A-Z]countdf"), function(x) get(x))
    l.df <- append(l.df, lapply(ls(pattern="[A-Z]countsdf"), function(x) get(x)))
    #Getting names of environmental variables to name the list elements
    DSTnames <- ls(pattern="[A-Z]countdf")
    NONnames <- ls(pattern="[A-Z]countsdf")
    listnames <- c(DSTnames,NONnames)
    names(l.df) <- listnames
    
    for(i in listnames) {
        #This will add in the relevant data
        for(j in 1:nrow(l.df[[i]])) {
            denomdf <- Sz08to16[which(Sz08to16$datetime <= as.Date(l.df[[i]][j,"Var1"])),"Unlinked_ID"]
            l.df[[i]][j,"AtRisk"] <- length(unique(denomdf))
            l.df[[i]][j,"Incidence"] <- l.df[[i]][j,"Freq"]/length(unique(denomdf))
        }
    }
    
    #For each non-DST data frame add in DST variables and calculate Rate Ratios
    for(i in NONnames) {
        DST4NON <- grep(paste("^",substr(i,1,3),sep=""),DSTnames,value=T) #Get name of comparable DST week
        for(j in 1:nrow(l.df[[i]])) { #Iterate over dates in non-DST data frame
            for(k in 1:nrow(l.df[[DST4NON]])) { #Iterate over dates in DST data frame to add comparisons to non-DST data frame
                if(year(l.df[[i]][j,"Var1"]) == year(l.df[[DST4NON]][k,"Var1"])) { 
                    l.df[[i]][j,"DSTFreq"] <- l.df[[DST4NON]][k,"Freq"] 
                    l.df[[i]][j,"DSTAtRisk"] <- l.df[[DST4NON]][k,"AtRisk"] 
                    l.df[[i]][j,"DSTIncidence"] <- l.df[[DST4NON]][k,"Incidence"] 
                }
            }
        }
        l.df[[i]][,"RateRatio"] <- l.df[[i]][,"DSTIncidence"]/l.df[[i]][,"Incidence"] #Calculate Rate Ratios
    }
    
    #Put the new data frames back into the Global Environment
    list2env(l.df,envir=.GlobalEnv)
    
    week2week <- data.frame("Weekday"=character(),
                            "Year"=numeric(),
                            "RateRatio"=numeric(),
                            stringsAsFactors = F)
    list <- c("Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday")
    
    for(i in list) {
        weekdaydf <- grep(paste("^",substr(i,1,3),sep=""),NONnames,value=T,ignore.case=T)
        for(j in min(year(Sz08to16$datetime)):max(year(Sz08to16$datetime))) {
            FORweek2week <- data.frame("RateRatio"=l.df[[weekdaydf]][which(year(as.Date(l.df[[weekdaydf]][,"Var1"])) == j),"RateRatio"])
            FORweek2week$"Weekday" <- i
            FORweek2week$"Year" <- j
            FORweek2week <- FORweek2week[,c(2,3,1)]
            week2week <- rbind(week2week,FORweek2week)
        }
    }
    
    factorlevels <- factor(list,levels=list)
    week2week$Weekday <- factor(week2week$Weekday, levels = factorlevels) #Ensures Weekdays stay in the same order, despite coercing to factors
    write.table(week2week,
                file=paste("Weekday seizure Rate Ratios for ",wkone," compared to ",wktwo,".txt",sep=""),
                quote = F,
                row.names = F)
    
    #Now plot the rate ratios, by weekday
    ggplot() + 
        geom_boxplot(data=week2week[,c("Weekday","RateRatio")], aes(x=Weekday, y=RateRatio), fill="#4271AE", alpha=0.5, outlier.size=NA) + #Avoid duplicate outlier plotting
        geom_point(data=week2week, aes(x=Weekday, y=RateRatio, color=factor(Year)), alpha=1, size=3) +
        geom_hline(yintercept = mean(week2week$RateRatio,na.rm=T)) + 
        geom_hline(yintercept = c(mean(week2week$RateRatio,na.rm=T)+1.96*sd(week2week$RateRatio,na.rm=T),
                                  mean(week2week$RateRatio,na.rm=T)-1.96*sd(week2week$RateRatio,na.rm=T)),
                   linetype=3) + 
        xlab("Weekday") +
        ylab(paste("Rate Ratio (Sz incidence in ",wkone," vs ",wktwo,")",sep="")) +
        ggtitle(paste("Boxplot for seizure Rate Ratios comparing ",wkone," to ",wktwo," over ",min(year(Sz08to16$datetime))," to ",max(year(Sz08to16$datetime)),sep="")) + 
        theme_bw() + 
        theme(legend.title = element_blank())
    #The above demonstrates pretty extreme outliers (particularly in the first full year...possibly bias from high-documentation rates and low population counts)
    # -Seems reasonable to remove those beyond 3 SD (particularly for the case of the whole-year-as-baseline comparisons)
    week2week <- week2week[which(week2week$RateRatio > (mean(week2week$RateRatio)-3*sd(week2week$RateRatio)) & week2week$RateRatio < (mean(week2week$RateRatio)+3*sd(week2week$RateRatio))),]
    
    #Now plot the rate ratios again with extreme outliers removed
    ggplot() + 
        geom_boxplot(data=week2week[,c("Weekday","RateRatio")], aes(x=Weekday, y=RateRatio), fill="#4271AE", alpha=0.5, outlier.size=NA) + #Avoid duplicate outlier plotting
        geom_point(data=week2week, aes(x=Weekday, y=RateRatio, color=factor(Year)), alpha=1, size=3) +
        geom_hline(yintercept = mean(week2week$RateRatio,na.rm=T)) + 
        geom_hline(yintercept = c(mean(week2week$RateRatio,na.rm=T)+1.96*sd(week2week$RateRatio,na.rm=T),
                                  mean(week2week$RateRatio,na.rm=T)-1.96*sd(week2week$RateRatio,na.rm=T)),
                   linetype=3) + 
        xlab("Weekday") +
        ylab(paste("Rate Ratio (Sz incidence in ",wkone," vs ",wktwo,")",sep="")) +
        ggtitle(paste("Boxplot for seizure Rate Ratios comparing ",wkone," to ",wktwo," over ",min(year(Sz08to16$datetime))," to ",max(year(Sz08to16$datetime)),sep="")) + 
        theme_bw() + 
        theme(legend.title = element_blank())
    
    png(paste("Rate Ratios comparing ",wkone," and ",wktwo," over ",min(year(Sz08to16$datetime))," to ",max(year(Sz08to16$datetime)),".png",sep=""), 
        width = 9, 
        height = 6, 
        units = 'in', 
        bg = "transparent", 
        res = 300)
    print(ggplot() + 
        geom_boxplot(data=week2week[,c("Weekday","RateRatio")], aes(x=Weekday, y=RateRatio), fill="#4271AE", alpha=0.5, outlier.size=NA) + #Avoid duplicate outlier plotting
        geom_point(data=week2week, aes(x=Weekday, y=RateRatio, color=factor(Year)), alpha=1, size=3) +
        geom_hline(yintercept = mean(week2week$RateRatio,na.rm=T)) + 
        geom_hline(yintercept = c(mean(week2week$RateRatio,na.rm=T)+1.96*sd(week2week$RateRatio,na.rm=T),
                                  mean(week2week$RateRatio,na.rm=T)-1.96*sd(week2week$RateRatio,na.rm=T)),
                   linetype=3) + 
        xlab("Weekday") +
        ylab(paste("Rate Ratio (Sz incidence in ",wkone," vs ",wktwo,")",sep="")) +
        ggtitle(paste("Boxplot for seizure Rate Ratios comparing ",wkone," to ",wktwo," over ",min(year(Sz08to16$datetime))," to ",max(year(Sz08to16$datetime)),sep="")) + 
        theme_bw() + 
        theme(legend.title = element_blank()))
    dev.off()
    
    firstdf <- data.frame("Week"=character(),
                          "Weekday"=character(),
                          "Mean_Sz_count"=numeric(),
                          "sd"=numeric(),
                          "se"=numeric(),
                          stringsAsFactors = F)
    seconddf <- data.frame("Week"=character(),
                           "Weekday"=character(),
                           "Mean_Sz_count"=numeric(),
                           "sd"=numeric(),
                           "se"=numeric(),
                           stringsAsFactors = F)
    sigdf <- data.frame("Weekday"=character(),
                        "p"=numeric(),
                        "p.signif"=character(),
                        stringsAsFactors = F)
    
    index=1
    for(i in list) {
        firstdf[index,"Week"] <- wkone
        firstdf[index,"Weekday"] <- i
        firstdf[index,"Mean_Sz_count"] <- mean(table(as.Date(firstweek[which(firstweek$wkday == i),"datetime"],'America/Los_Angeles')))
        firstdf[index,"sd"] <- sd(table(as.Date(firstweek[which(firstweek$wkday == i),"datetime"],'America/Los_Angeles')))
        firstdf[index,"se"] <- sd(table(as.Date(firstweek[which(firstweek$wkday == i),"datetime"],'America/Los_Angeles')))/sqrt(table(firstweek$wkday)[[i]])
        
        seconddf[index,"Week"] <- wktwo
        seconddf[index,"Weekday"] <- i
        seconddf[index,"Mean_Sz_count"] <- mean(table(as.Date(secondweek[which(secondweek$wkday == i),"datetime"],'America/Los_Angeles')))
        seconddf[index,"sd"] <- sd(table(as.Date(secondweek[which(secondweek$wkday == i),"datetime"],'America/Los_Angeles')))
        seconddf[index,"se"] <- sd(table(as.Date(firstweek[which(firstweek$wkday == i),"datetime"],'America/Los_Angeles')))/sqrt(table(secondweek$wkday)[[i]])
        
        sigdf[index,"Weekday"] <- i
        sigdf[index,"p"] <- round(t.test(table(as.Date(firstweek[which(firstweek$wkday == i),"datetime"],'America/Los_Angeles')),
                                         table(as.Date(secondweek[which(secondweek$wkday == i),"datetime"],'America/Los_Angeles')))[["p.value"]],4)
        if(sigdf[index,"p"]<0.05 & sigdf[index,"p"]>0.01) {
            sigdf[index,"p.signif"] <- "*"
        } else if(sigdf[index,"p"]<0.01 & sigdf[index,"p"]>0.001) {
            sigdf[index,"p.signif"] <- "**"
        } else if(sigdf[index,"p"]<0.001) {
            sigdf[index,"p.signif"] <- "***"
        } else {
            sigdf[index,"p.signif"] <- "ns"
        }
        
        index=index+1
    }
    firstdf$Weekday <- factor(firstdf$Weekday, levels = firstdf$Weekday) #ensures weekdays stay in order Sun-Sat
    seconddf$Weekday <- factor(seconddf$Weekday, levels = seconddf$Weekday) #ensures weekdays stay in order Sun-Sat
    comparedf <- rbind(firstdf,seconddf)
    
    #To add significance markers can try method here: https://www.r-bloggers.com/add-p-values-and-significance-levels-to-ggplots/
    #library(ggpubr)
    
    require(ggplot2)
    png(paste("Comparison between ",wkone," and ",wktwo,".png",sep=""), 
        width = 9, 
        height = 6, 
        units = 'in', 
        bg = "transparent", 
        res = 300)
    print(ggplot(comparedf, aes(x=Weekday, y=Mean_Sz_count, fill=Week)) + 
        geom_bar(position=position_dodge(), stat="identity",
                 colour="black", # Use black outlines,
                 size=.3) +      # Thinner lines
        #stat_compare_means(aes(group = Week), label = "p.signif", label.y = 300)
        geom_errorbar(aes(ymin=Mean_Sz_count-se, ymax=Mean_Sz_count+se),
                      size=.3,    # Thinner lines
                      width=.2,
                      position=position_dodge(.9)) +
        xlab("Weekday") +
        ylab("Number of seizures (± SEM)") +
        scale_fill_hue(name=paste(wkone,"vs",wktwo), # Legend label, use darker colors
                       breaks=c(wkone, wktwo),
                       labels=c(wkone, wktwo)) +
        ggtitle("Comparison of seizures on a given weekday") +
        scale_y_continuous(breaks=0:500*100) +
        theme_bw())
    dev.off()
    
    print(sigdf)
    write.table(sigdf,file=paste("T-tests between ",wkone," and ",wktwo,".txt",sep=""),quote = F,row.names = F)
    
    ###Could add Rate Ratio stuff here, based on denominator work from weekly comparisons
}
```
  
Compare DST to non-DST
```{r DST to non-DST, echo=FALSE}
compareweekdays(firstweek=Sz08to16wkofDST,
                secondweek=Sz08to16notDST,
                wkone="week of DST",
                wktwo="all non DST")
```
  
Compare DST to pre-DST
```{r DST to pre-DST, echo=FALSE}
compareweekdays(firstweek=Sz08to16wkofDST,
                secondweek=Sz08to16wkpreDST,
                wkone="week of DST",
                wktwo="preDST week")
```
  
Compare DST to the week post-DST week
```{r DST to pre-DST, echo=FALSE}
compareweekdays(firstweek=Sz08to16wkofDST,
                secondweek=Sz08to16wkpostDST,
                wkone="week of DST",
                wktwo="week after DST week")
```
  
Compare DST to ST
```{r DST to ST, echo=FALSE}
compareweekdays(firstweek=Sz08to16wkofDST,
                secondweek=Sz08to16wkofST,
                wkone="week of DST",
                wktwo="ST start week")
```
  
Compare ST to pre-ST
```{r DST to ST, echo=FALSE}
compareweekdays(firstweek=Sz08to16wkofST,
                secondweek=Sz08to16wkpreST,
                wkone="week of ST",
                wktwo="preST week")
```
  
Compare ST to the week post-ST week
```{r DST to ST, echo=FALSE}
compareweekdays(firstweek=Sz08to16wkofST,
                secondweek=Sz08to16wkpostST,
                wkone="week of ST",
                wktwo="week after ST week")
```
  
  
Visual demonstration of seizure rates registered to the DST time period
```{r daily seizure rates graph, echo=FALSE}
Sz4timeplot <- Sz08to16[,c("datetime","DSTday","STday")]
Sz4timeplot$time0 <- yday(Sz08to16$datetime) - Sz08to16$DSTday
summary(Sz4timeplot) #things are now registered to DST's Sunday as t=0
Sz4timeplot$year <- year(Sz08to16$datetime)

table(Sz4timeplot$time0) #Shows that the extreme tails are undersampled (due to variability in onset/offset of DST)...hence usage of SEM
yearlist <- c(min(year(Sz08to16$datetime)):max(year(Sz08to16$datetime))) #Bound years by the bounds of the dataset
CountsByYear <- data.frame("Index"=seq(min(Sz4timeplot$time0),max(Sz4timeplot$time0),1))
colID <- 2
for(i in yearlist) {
    yearlyCount <- Sz4timeplot[which(year(Sz4timeplot$datetime) == i),"time0"]
    table(yearlyCount)
    CountsByYear <- merge.data.frame(CountsByYear,as.data.frame(t(table(yearlyCount)))[,2:3],by.x="Index",by.y="yearlyCount",all.x = T)
    names(CountsByYear)[colID] <- i
    colID <- colID+1
}
fromcol <- grep(min(year(Sz08to16$datetime)), colnames(CountsByYear))
tocol <- grep(max(year(Sz08to16$datetime)), colnames(CountsByYear))
CountsByYear <- cbind(CountsByYear,
                      Mean=apply(CountsByYear[,fromcol:tocol],1,mean,na.rm=T),
                      SD=apply(CountsByYear[,fromcol:tocol],1,sd,na.rm=T))
for(i in 1:nrow(CountsByYear)) {
    CountsByYear[i,"SEM"] <- CountsByYear[i,"SD"]/sqrt(sum(!is.na(CountsByYear[i,fromcol:tocol])))
}
TallCount <- data.frame("Index"=numeric(),
                        "SzCount"=numeric(),
                        "Year"=numeric())
for(i in yearlist) {
    FORtall <- CountsByYear[,c("Index",i)]
    names(FORtall)[2] <- "SzCount"
    FORtall$Year <- i
    TallCount <- rbind(TallCount,FORtall)
}
#CountsByYear$Mean <- rowMeans(CountsByYear[,fromcol:tocol], na.rm=T)
#SDtemp <- transform(CountsByYear[,fromcol:tocol], SD=apply(CountsByYear[,fromcol:tocol],1,sd,na.rm=T))

png("Yearly trend.png", 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
print(ggplot(CountsByYear, aes(x=Index,y=Mean)) + 
    stat_smooth(method="loess", span=7/365, se=TRUE, alpha=0.3) + #using loess smoothing with proportional smoothing from 7 out of 365 days
    geom_vline(xintercept=c(0,7,237,244)) + 
    annotate("rect", xmin=7, xmax=237, ymin=-Inf, ymax=Inf, alpha=0.2, fill="yellow") + 
    annotate("rect", xmin=0, xmax=7, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=237, xmax=244, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Day of the year (indexed to DST transition)") +
    ylab("Seizure counts per day (mean ± SEM)") +
    ggtitle(paste("Yearly seizure trends over the period from",min(year(Sz08to16$datetime)),"to",max(year(Sz08to16$datetime)))) +
    theme_bw())
dev.off()

ggplot(CountsByYear, aes(x=Index,y=Mean)) + 
    stat_smooth(method="loess", span=7/365, se=TRUE, alpha=0.3) + #using loess smoothing with proportional smoothing from 7 out of 365 days
    geom_vline(xintercept=c(0,7,237,244)) + 
    annotate("rect", xmin=7, xmax=237, ymin=-Inf, ymax=Inf, alpha=0.2, fill="yellow") + 
    annotate("rect", xmin=0, xmax=7, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=237, xmax=244, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Day of the year (indexed to DST transition)") +
    ylab("Seizure counts per day (mean ± SEM)") +
    ggtitle(paste("Yearly seizure trends over the period from",min(year(Sz08to16$datetime)),"to",max(year(Sz08to16$datetime)))) +
    theme_bw()

###May consider making CountsByYear a tall matrix and then coloring by year using methods from http://ggplot2.tidyverse.org/reference/geom_smooth.html
#library(RColorBrewer)
png("Yearly trend_with points.png", 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
print(ggplot(TallCount, aes(x=Index,y=SzCount,color=Year)) + 
      geom_point() + 
      #scale_x_continuous(breaks = c(cat(yearlist,sep=","))) + 
      #scale_color_brewer(breaks = c(cat(paste(shQuote(yearlist,type="cmd"),collapse=","))),
      #scale_color_brewer(breaks = c(cat(yearlist,sep=",")), palette="Set3") + #http://www.sthda.com/english/wiki/ggplot2-colors-how-to-change-colors-automatically-and-manually
      geom_smooth(method="loess", span=7/365, se=TRUE, alpha=0.3, colour="red") + 
      geom_vline(xintercept=c(0,7,237,244)) + 
      annotate("rect", xmin=0, xmax=7, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
      annotate("rect", xmin=237, xmax=244, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
      xlab("Day of the year (indexed to DST transition)") +
      ylab("Seizure counts per day (mean ± SEM)") +
      ggtitle(paste("Yearly seizure trends over the period from",min(year(Sz08to16$datetime)),"to",max(year(Sz08to16$datetime)))) + 
      ylim(0,quantile(TallCount$SzCount, 0.99, na.rm=T)[[1]]) + 
      theme_bw())
dev.off()

ggplot(TallCount, aes(x=Index,y=SzCount,color=Year)) + 
    geom_point() + 
    #scale_x_continuous(breaks = c(cat(yearlist,sep=","))) + 
    #scale_color_brewer(breaks = c(cat(paste(shQuote(yearlist,type="cmd"),collapse=","))),
    #scale_color_brewer(breaks = c(cat(yearlist,sep=",")), palette="Set3") + #http://www.sthda.com/english/wiki/ggplot2-colors-how-to-change-colors-automatically-and-manually
    geom_smooth(method="loess", span=7/365, se=TRUE, alpha=0.3, colour="red") + 
    geom_vline(xintercept=c(0,7,237,244)) + 
    annotate("rect", xmin=0, xmax=7, ymin=-Inf, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=237, xmax=244, ymin=-Inf, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Day of the year (indexed to DST transition)") +
    ylab("Seizure counts per day (mean ± SEM)") +
    ggtitle(paste("Yearly seizure trends over the period from",min(year(Sz08to16$datetime)),"to",max(year(Sz08to16$datetime)))) + 
    ylim(0,quantile(TallCount$SzCount, 0.99, na.rm=T)[[1]]) + 
    theme_bw()
```
  
Weekly comparisons
```{r weekly comparisons}
#Find out what week DST is in, register to that then calculate
#If wanting to do comparison to the every-non-DST-week baseline, then second week must be Sz08to16nonDST/"all non DST"
compareweeks <- function(firstweek=Sz08to16wkofDST,
                         secondweek=Sz08to16notDST,
                         wkone="week of DST",
                         wktwo="all non DST") {
    
    #Get seizure counts for the week in DST
    #-this allows for independent t-tests (albeit suboptimal compared to paired t-tests)
    DSTweekCount <- as.data.frame(table(year(firstweek$datetime)))
    
    if(identical(secondweek,Sz08to16notDST)) { #For the all-non-DST-weeks-as-baseline comparison
        #Get seizure counts for week(s) not in DST
        NONweekdf <- secondweek[,c("datetime","weeknum","DSTweek")]
        NONweekdf <- NONweekdf[-which(NONweekdf$weeknum == NONweekdf$DSTweek),] #ensures no DST-week counts are included
        NONweekdf$year <- year(NONweekdf$datetime)
        table(NONweekdf$weeknum,NONweekdf$year)
        NONweekCount <- as.data.frame(table(NONweekdf$weeknum,NONweekdf$year))
        NONweekCount[NONweekCount == 0] <- NA #replace non-existing weeks (e.g. year without the 53rd week, DST)
        
        #T-tests (x is for week of DST, y is for comparison week(s)):
        print(t.test(DSTweekCount$Freq,NONweekCount$Freq))
    
        NON4gg <- NONweekCount[,2:3]
        names(NON4gg) <- c("Year","Freq")
        NON4gg$Year <- as.factor(NON4gg$Year)
        DST4gg <- DSTweekCount
        names(DST4gg) <- c("Year","Freq")
        DST4gg$Year <- as.factor(DST4gg$Year)
        
        #Plot it
        ggplot() + 
            geom_jitter(data=NON4gg, aes(x=Year,y=Freq), position=position_jitter(width=0.05), alpha=0.8) + #Outliers from incomplete weeks
            geom_boxplot(data=NON4gg, aes(x=Year,y=Freq), fill="#4271AE", alpha=0.5, outlier.size=0) + #Outliers from incomplete weeks
            geom_point(data=DST4gg, aes(x=Year,y=Freq), color="red", size=4, shape=18) + 
            xlab("Year") +
            ylab("Seizure Counts (per week)") +
            ggtitle(paste("Percentile for ",wkone," seizure counts, per week from ",min(year(Sz08to16$datetime))," to ",max(year(Sz08to16$datetime)),sep="")) + 
            theme_bw()
        
        png(paste("Percentile for ",wkone," seizure counts, per week from ",min(year(Sz08to16$datetime))," to ",max(year(Sz08to16$datetime)),".png",sep=""), 
            width = 9, 
            height = 6, 
            units = 'in', 
            bg = "transparent", 
            res = 300)
        print(ggplot() + 
            geom_jitter(data=NON4gg, aes(x=Year,y=Freq), position=position_jitter(width=0.05), alpha=0.8) + #Outliers from incomplete weeks
            geom_boxplot(data=NON4gg, aes(x=Year,y=Freq), fill="#4271AE", alpha=0.5, outlier.size=0) + #Outliers from incomplete weeks
            geom_point(data=DST4gg, aes(x=Year,y=Freq), color="red", size=4, shape=18) + 
            xlab("Year") +
            ylab("Seizure Counts (per week)") +
            ggtitle(paste("Percentile for ",wkone," seizure counts, per week from ",min(year(Sz08to16$datetime))," to ",max(year(Sz08to16$datetime)),sep="")) + 
            theme_bw())
        dev.off()
        
        #Make Z-score comparison
        Zweek <- data.frame("Year"=numeric(),
                            "PopMean"=numeric(),
                            "PopSD"=numeric(),
                            "SzCount"=numeric(),
                            "Zscore"=numeric(),
                            "Percentile"=numeric())
        counter=1
        for(i in min(year(Sz08to16$datetime)):max(year(Sz08to16$datetime))) {
            Zweek[counter,"Year"] <- i
            Zweek[counter,"PopMean"] <- mean(na.omit(NONweekCount[which(NONweekCount$Var2 == i),"Freq"]))
            Zweek[counter,"PopSD"] <- sd(na.omit(NONweekCount[which(NONweekCount$Var2 == i),"Freq"]))
            Zweek[counter,"SzCount"] <- DSTweekCount[which(DSTweekCount$Var1 == i),"Freq"]
            Zweek[counter,"Zscore"] <- (Zweek[counter,"SzCount"]-Zweek[counter,"PopMean"])/Zweek[counter,"PopSD"]
            Zweek[counter,"Percentile"] <- round(pnorm(Zweek[counter,"Zscore"])*100,2)
            counter=counter+1
        }
        write.table(Zweek,
                    file = paste("Yearly percentiles by week ",wkone,".txt",sep=""),
                    quote = F,
                    row.names = F)
        Zweek$Year <- as.factor(Zweek$Year)
        #library(ggplot2)

        ggplot(Zweek[,c("Year","Percentile")], aes(x=Year, y=Percentile)) + 
            geom_bar(position=position_dodge(), stat="identity",
                     colour="black", # Use black outlines,
                     size=.3) +      # Thinner lines
            geom_hline(yintercept = mean(Zweek$Percentile)) + 
            geom_hline(yintercept = c(mean(Zweek$Percentile)+sd(Zweek$Percentile),
                                      mean(Zweek$Percentile)-sd(Zweek$Percentile)),
                       linetype=3) + 
            xlab("Year") +
            ylab("Percentile") +
            ggtitle(paste("Percentile of seizure counts for ",wkone," per week from ",min(year(Sz08to16$datetime))," to ",max(year(Sz08to16$datetime)),sep="")) +
            scale_y_continuous(breaks=0:100*10, limits=c(0,100)) +
            theme_bw()
        png(paste("Percentile of seizure counts for ",wkone," per week from ",min(year(Sz08to16$datetime))," to ",max(year(Sz08to16$datetime)),".png",sep=""), 
            width = 9, 
            height = 6, 
            units = 'in', 
            bg = "transparent", 
            res = 300)
        print(ggplot(Zweek[,c("Year","Percentile")], aes(x=Year, y=Percentile)) + 
            geom_bar(position=position_dodge(), stat="identity",
                     colour="black", # Use black outlines,
                     size=.3) +      # Thinner lines
            geom_hline(yintercept = mean(Zweek$Percentile)) + 
            geom_hline(yintercept = c(mean(Zweek$Percentile)+sd(Zweek$Percentile),
                                      mean(Zweek$Percentile)-sd(Zweek$Percentile)),
                       linetype=3) + 
            xlab("Year") +
            ylab("Percentile") +
            ggtitle(paste("Percentile of seizure counts for ",wkone," per week from ",min(year(Sz08to16$datetime))," to ",max(year(Sz08to16$datetime)),sep="")) +
            scale_y_continuous(breaks=0:100*10, limits=c(0,100)) +
            theme_bw())
        dev.off()
        
        for(i in min(year(Sz08to16$datetime)):max(year(Sz08to16$datetime))) {
            #Subsetting for the year of interest
            thisyear <- Sz08to16[which(year(Sz08to16$datetime) == i),]
            firstyear <- firstweek[which(year(firstweek$datetime) == i),]
            secondyear <- secondweek[which(year(secondweek$datetime) == i),]
            
            #Try using denominator estimated by number of individuals recording through the end of the period of interest
            firstdenomdf <- Sz08to16[which(Sz08to16$datetime <= as.Date(max(firstyear$datetime),'America/Los_Angeles')),"Unlinked_ID"]
            firstdenom <- length(unique(firstdenomdf))
            baselineweeklist <- na.omit(NONweekCount[which(NONweekCount$Var2 == i),"Var1"])
            
            #Have to do this for each week in the baseline (NON DST) period
            for (j in baselineweeklist) {
                weeksend <- max(as.Date(secondyear[which(week(secondyear$datetime) == as.numeric(j)),"datetime"],'America/Los_Angeles'))
                seconddenomdf <- Sz08to16[which(as.Date(Sz08to16$datetime,'America/Los_Angeles') <= weeksend),"Unlinked_ID"]
                seconddenom <- length(unique(seconddenomdf))
                NONweekCount[which(NONweekCount$Var1 == as.numeric(j) & NONweekCount$Var2 == i),"AtRisk"] <- seconddenom
                NONweekCount[which(NONweekCount$Var1 == as.numeric(j) & NONweekCount$Var2 == i),"Incidence"] <- NONweekCount[which(NONweekCount$Var1 == as.numeric(j) & NONweekCount$Var2 == i),"Freq"]/seconddenom
            }
            NONweekCount[which(NONweekCount$Var2 == i),"DSTFreq"] <- DSTweekCount[which(DSTweekCount$Var1 == i),"Freq"]
            NONweekCount[which(NONweekCount$Var2 == i),"DSTAtRisk"] <- firstdenom
            NONweekCount[which(NONweekCount$Var2 == i),"DSTIncidence"] <- DSTweekCount[which(DSTweekCount$Var1 == i),"Freq"]/firstdenom
            NONweekCount$RateRatio <- NONweekCount$DSTIncidence/NONweekCount$Incidence
            
        }
        
        ggplot() + 
            geom_jitter(data=NONweekCount, aes(x=Var2,y=RateRatio), position=position_jitter(width=0.05), alpha=0.8) + #Outliers from incomplete weeks
            geom_boxplot(data=NONweekCount, aes(x=Var2,y=RateRatio), fill="#4271AE", alpha=0.5, outlier.size=0) + #Outliers from incomplete weeks
            xlab("Year") +
            ylab(paste("Rate Ratios (",wkone," vs each week of the year)",sep="")) +
            ggtitle(paste("Comparison of weekly seizure Rate Ratios for",wkone,min(year(Sz08to16$datetime)),"to",max(year(Sz08to16$datetime)),sep=" ")) + 
            geom_hline(yintercept = mean(NONweekCount$RateRatio,na.rm=T)) + 
            geom_hline(yintercept = c(mean(NONweekCount$RateRatio,na.rm=T)+1.96*sd(NONweekCount$RateRatio,na.rm=T),
                                      mean(NONweekCount$RateRatio,na.rm=T)-1.96*sd(NONweekCount$RateRatio,na.rm=T)),
                       linetype=3) + 
            ylim((mean(NONweekCount$RateRatio,na.rm=T)-2*sd(NONweekCount$RateRatio,na.rm=T)),(mean(NONweekCount$RateRatio,na.rm=T)+2*sd(NONweekCount$RateRatio,na.rm=T))) + 
            theme_bw()
        
        #Those outliers look quite spurious, so cutting them out at the >3SD threshold and comparing again
        NONweek4gg <- NONweekCount[which(NONweekCount$RateRatio < (mean(NONweekCount$RateRatio,na.rm=T)+3*sd(NONweekCount$RateRatio,na.rm=T)) & NONweekCount$RateRatio > (mean(NONweekCount$RateRatio,na.rm=T)-3*sd(NONweekCount$RateRatio,na.rm=T))),]
        
        ggplot() + 
            geom_jitter(data=NONweek4gg, aes(x=Var2,y=RateRatio), position=position_jitter(width=0.05), alpha=0.8) + #Outliers from incomplete weeks
            geom_boxplot(data=NONweek4gg, aes(x=Var2,y=RateRatio), fill="#4271AE", alpha=0.5, outlier.size=0) + #Outliers from incomplete weeks
            xlab("Year") +
            ylab(paste("Rate Ratios (",wkone," vs each week of the year)",sep="")) +
            ggtitle(paste("Comparison of weekly seizure Rate Ratios for",wkone,min(year(Sz08to16$datetime)),"to",max(year(Sz08to16$datetime)),sep=" ")) + 
            geom_hline(yintercept = mean(NONweek4gg$RateRatio,na.rm=T)) + 
            geom_hline(yintercept = c(mean(NONweek4gg$RateRatio,na.rm=T)+1.96*sd(NONweek4gg$RateRatio,na.rm=T),
                                      mean(NONweek4gg$RateRatio,na.rm=T)-1.96*sd(NONweek4gg$RateRatio,na.rm=T)),
                       linetype=3) + 
            theme_bw()
        png(paste("Comparison of weekly seizure Rate Ratios for ",wkone," from ",min(year(Sz08to16$datetime))," to ",max(year(Sz08to16$datetime)),".png",sep=""), 
            width = 9, 
            height = 6, 
            units = 'in', 
            bg = "transparent", 
            res = 300)
        print(ggplot() + 
            geom_jitter(data=NONweek4gg, aes(x=Var2,y=RateRatio), position=position_jitter(width=0.05), alpha=0.8) + #Outliers from incomplete weeks
            geom_boxplot(data=NONweek4gg, aes(x=Var2,y=RateRatio), fill="#4271AE", alpha=0.5, outlier.size=0) + #Outliers from incomplete weeks
            xlab("Year") +
            ylab(paste("Rate Ratios (",wkone," vs each week of the year)",sep="")) +
            ggtitle(paste("Comparison of weekly seizure Rate Ratios for",wkone,min(year(Sz08to16$datetime)),"to",max(year(Sz08to16$datetime)),sep=" ")) + 
            geom_hline(yintercept = mean(NONweek4gg$RateRatio,na.rm=T)) + 
            geom_hline(yintercept = c(mean(NONweek4gg$RateRatio,na.rm=T)+1.96*sd(NONweek4gg$RateRatio,na.rm=T),
                                      mean(NONweek4gg$RateRatio,na.rm=T)-1.96*sd(NONweek4gg$RateRatio,na.rm=T)),
                       linetype=3) + 
            theme_bw())
        dev.off()
        
        names(NONweekCount) <- c("WeekOfYear","Year","Freq","AtRisk","Incidence","DSTFreq","DSTAtRisk","DSTIncidence","RiskRatio")
        write.table(NONweekCount,
                    file="Rate Ratios for each week.txt",
                    quote = F,
                    row.names = F)
        
        
    } else { #For the single-week-as-baseline comparisons
        #Get seizure counts for weeks not in DST
        NONweekCount <- as.data.frame(table(year(secondweek$datetime)))
        
        #T-tests (x is for week of DST, y is for comparison week(s)):
        print(t.test(DSTweekCount$Freq,NONweekCount$Freq))
        
        week2week <- data.frame("Year"=numeric(),
                                "DSTSzcount"=numeric(),
                                "DSTatrisk"=numeric(),
                                "DSTincidence"=numeric(),
                                "NONSzcount"=numeric(),
                                "NONatrisk"=numeric(),
                                "NONincidence"=numeric(),
                                "RateRatio"=numeric())
        counter=1
        for(i in min(year(Sz08to16$datetime)):max(year(Sz08to16$datetime))) {
            #Subsetting for the year of interest
            thisyear <- Sz08to16[which(year(Sz08to16$datetime) == i),]
            firstyear <- firstweek[which(year(firstweek$datetime) == i),]
            secondyear <- secondweek[which(year(secondweek$datetime) == i),]
            
            #Try using denominator estimated by number of individuals recording through the end of the period of interest
            firstdenomdf <- Sz08to16[which(Sz08to16$datetime <= as.Date(max(firstyear$datetime),'America/Los_Angeles')),"Unlinked_ID"]
            firstdenom <- length(unique(firstdenomdf))
            seconddenomdf <- Sz08to16[which(Sz08to16$datetime <= as.Date(max(secondyear$datetime),'America/Los_Angeles')),"Unlinked_ID"]
            seconddenom <- length(unique(seconddenomdf))
            print(paste("Rough estimate of difference in 'at risk' individuals: ",abs(firstdenom-seconddenom),"; with ",firstdenom," accumulated individuals by DST week of ",i,sep=""))
            
            week2week[counter,"Year"] <- i
            week2week[counter,"DSTSzcount"] <- DSTweekCount[which(DSTweekCount$Var1 == i),"Freq"]
            week2week[counter,"DSTatrisk"] <- firstdenom
            week2week[counter,"DSTincidence"] <- week2week[counter,"DSTSzcount"]/week2week[counter,"DSTatrisk"]
            week2week[counter,"NONSzcount"] <- NONweekCount[which(NONweekCount$Var1 == i),"Freq"]
            week2week[counter,"NONatrisk"] <- seconddenom
            week2week[counter,"NONincidence"] <- week2week[counter,"NONSzcount"]/week2week[counter,"NONatrisk"]
            week2week[counter,"RateRatio"] <- week2week[counter,"DSTincidence"]/week2week[counter,"NONincidence"]
            counter=counter+1
            
        }
        write.table(week2week,
                    file=paste("Seizure Rate Ratios for ",wkone," compared to ",wktwo,".txt",sep=""),
                    quote = F,
                    row.names = F)
        week2week$Year <- as.factor(week2week$Year)
        
        #Now plot the rate ratios, by year
        ggplot(week2week[,c("Year","RateRatio")], aes(x=Year, y=RateRatio)) + 
            #IF WANT AS HISTOGRAM:
            #geom_bar(position=position_dodge(), stat="identity",
            #         colour="black", # Use black outlines,
            #         size=.3) +      # Thinner lines
            geom_point(size=5, color="turquoise4") + 
            geom_hline(yintercept = mean(week2week$RateRatio)) + 
            geom_hline(yintercept = c(mean(week2week$RateRatio)+1.96*sd(week2week$RateRatio),
                                      mean(week2week$RateRatio)-1.96*sd(week2week$RateRatio)),
                       linetype=3) + 
            scale_y_continuous(limits = c(0.5,1.5)) + 
            xlab("Year") +
            ylab("Rate Ratio") +
            ggtitle(paste(wkone,"vs",wktwo,"Rate Ratios from",min(year(Sz08to16$datetime)),"to",max(year(Sz08to16$datetime)))) +
            theme_bw()
        png(paste(wkone," vs ",wktwo," Rate Ratios from ",min(year(Sz08to16$datetime))," to ",max(year(Sz08to16$datetime)),".png",sep=""), 
            width = 9, 
            height = 6, 
            units = 'in', 
            bg = "transparent", 
            res = 300)
        print(ggplot(week2week[,c("Year","RateRatio")], aes(x=Year, y=RateRatio)) + 
            #IF WANT AS HISTOGRAM:
            #geom_bar(position=position_dodge(), stat="identity",
            #         colour="black", # Use black outlines,
            #         size=.3) +      # Thinner lines
            geom_point(size=5, color="turquoise4") + 
            geom_hline(yintercept = mean(week2week$RateRatio)) + 
            geom_hline(yintercept = c(mean(week2week$RateRatio)+1.96*sd(week2week$RateRatio),
                                      mean(week2week$RateRatio)-1.96*sd(week2week$RateRatio)),
                       linetype=3) + 
            scale_y_continuous(limits = c(0.5,1.5)) + 
            xlab("Year") +
            ylab("Rate Ratio") +
            ggtitle(paste(wkone,"vs",wktwo,"Rate Ratios from",min(year(Sz08to16$datetime)),"to",max(year(Sz08to16$datetime)))) +
            theme_bw())
        dev.off()
    }
}
```
  
Compare DST to non-DST
```{r DST to non-DST, echo=FALSE}
compareweeks(firstweek=Sz08to16wkofDST,
             secondweek=Sz08to16notDST,
             wkone="week of DST",
             wktwo="all non DST")
```
  
Compare DST to pre-DST
```{r DST to pre-DST, echo=FALSE}
compareweeks(firstweek=Sz08to16wkofDST,
             secondweek=Sz08to16wkpreDST,
             wkone="week of DST",
             wktwo="preDST week")
```
  
Compare DST to the week post-DST week
```{r DST to pre-DST, echo=FALSE}
compareweeks(firstweek=Sz08to16wkofDST,
             secondweek=Sz08to16wkpostDST,
             wkone="week of DST",
             wktwo="week after DST week")
```
  
Compare DST to ST
```{r DST to ST, echo=FALSE}
compareweeks(firstweek=Sz08to16wkofDST,
             secondweek=Sz08to16wkofST,
             wkone="week of DST",
             wktwo="ST start week")
```
  
Compare ST to pre-ST
```{r DST to ST, echo=FALSE}
compareweeks(firstweek=Sz08to16wkofST,
             secondweek=Sz08to16wkpreST,
             wkone="week of ST",
             wktwo="preST week")
```
  
Compare ST to the week post-ST week
```{r DST to ST, echo=FALSE}
compareweeks(firstweek=Sz08to16wkofST,
             secondweek=Sz08to16wkpostST,
             wkone="week of ST",
             wktwo="week after ST week")
```
    
  
###Scratchpad###  
#==================================#
```{r, eval=FALSE}
#-first need to determine duplicates of Sz per individual to do this
Sz08to17$IDdup <- duplicated(Sz08to17$Unlinked_ID) | duplicated(Sz08to17$Unlinked_ID, fromLast = T)
Sz08to17$datedup <- duplicated(yday(Sz08to17$datetime)) | duplicated(yday(Sz08to17$datetime), fromLast = T)
#for(i in 1:nrow(Sz08to17)) {
#    j=1
#    #check if you're in a block of ID & date duplicates that is new (the i-j comparison)
#    if(Sz08to17[i,"IDdup"] == TRUE & Sz08to17[i,"datedup"] == TRUE & i>=j) {
#        #k is used for iterating over the block
#        k=1
#        #j is used for indexing relative to blocks (so as to not reiterate with the absolute index i)
#        j=i+k
#        #will iterate over the block of duplicates while individual AND date are the same
#        #AND ONLY IF time between end of Sz j-1 and start of Sz j is <5 min
#        #the goal is to find the full span (indexed from i to j) of the "Status" event
#        while(Sz08to17[j,"Unlinked_ID"] == Sz08to17[i,"Unlinked_ID"] & as.Date(Sz08to17[j,"datetime"]) == as.Date(Sz08to17[i,"datetime"]) & (second(Sz08to17[j,"datetime"])-second(Sz08to17[j-1,"datetime"])-Sz08to17[j-1,"dur_secs"])<300) {
#            k=k+1
#            j=i+k
#        }
#        for(l in i:j) {
#            #this makes all entries for a given status event have duration from start of ith Sz to end of jth Sz
#            Sz08to17[l,"StatusYN"]<-1
#            Sz08to17[l,"Statusdur"]<-second(Sz08to17[j,"datetime"])+Sz08to17[j,"dur_secs"]-second(Sz08to17[i,"datetime"])
#        }
#    }
#}

##start after defining m
#for(l in k:k+m-2) {
#    #far more cumbersome way to do the if below: as.numeric(seconds(as.POSIXlt(ordered[k+1,"datetime"]))-seconds(as.POSIXlt(ordered[k,"datetime"]))-ordered[k,"dur_secs"])
#    #if the time between Sz is <5 min
#    if(as.numeric(difftime(ordered[k+1,"datetime"],ordered[k,"datetime"],units="secs"))-ordered[k,"dur_secs"] < 300) {
#        n <- l
#        #...set the k->p entries to Status Yes (1)
#        #...and set all to the total "status epilepticus" duration (from start of first to end of last seizure in status series)
#        for(p in n:z) {
#            #this makes all entries for a given status event have duration from start of ith Sz to end of jth Sz
#            ordered[p,"StatusYN"]<-1
#            ordered[p,"Statusdur"]<-second(ordered[j,"datetime"])+ordered[j,"dur_secs"]-second(ordered[i,"datetime"])
#        }
#    }
#}

##OR multiple Sz with inter-Sz interval <5 min with time from start to end of all Sz >5 min
##Get the dataframe into an order in which the following algorithmic Status Epilepticus checking can work (assumes seizures entered in non-temporal order)
#ordered <- Sz08to17[with(Sz08to17, order(Unlinked_ID, datetime)), ]
##run through the rows of the dataframe
#for(i in 1:nrow(ordered)) {
#    #start relative index for blocks of similar IDs
#    j <- 1
#    #if IDs are the same from current i and next entry...
#    if(ordered[i,"Unlinked_ID"] == ordered[i+1,"Unlinked_ID"] & i>=j) {
#        #...set ID block range from i to the end with j...
#        j <- rle(ordered[i:nrow(ordered),"Unlinked_ID"])$lengths[1]
#        #...then loop over the ID block
#        for(k in i:i+j-1) {
#            #if date is the same from current k and next entry (within the same ID block)...
#            if(date(ordered[k,"datetime"]) == date(ordered[k+1,"datetime"])) {
#                #...set date block range from k to second from the end with m...
#                m <- rle(as.numeric(date(ordered[k:nrow(ordered),"datetime"])))$lengths[1]
#                #...then loop over the same-date-within-same-ID block
#                SEstart <- k
#                SEend <- k
#                while(k<m) {
#                    #if the time between Sz is <5 min
#                    if(as.numeric(difftime(ordered[k+1,"datetime"],ordered[k,"datetime"],units="secs"))-ordered[k,"dur_secs"] < 300) {
#                        SEend <- k+1
#                    } else {
#                        #NOTE: this will only define new Status entries if not able to create a new SEend AND the Status did iterate previously (i.e. SEstart<SEend)
#                        #...set the SEstart->SEend entries to Status Yes (1)
#                        #...and set all to the total "status epilepticus" duration (from start of first to end of last seizure in status series)
#                        if(SEstart<SEend) {
#                            for(p in SEstart:SEend) {
#                                #this makes all entries for a given status event have duration from start of SEstart's Sz to end of SEend's Sz
#                                ordered[p,"StatusYN"]<-1
#                                ordered[p,"Statusdur"]<-as.numeric(ordered[SEend,"datetime"],ordered[SEstart,"datetime"],units="secs")+ordered[SEend,"dur_secs"]
#                            }
#                        }
#                        SEstart <- k+1
#                    }
#                    k <- k+1
#                }
#            }
#        }
#    }
#}

#Get seizure counts for each day of the week not in DST
#-this is tabulated BY DATE (i.e. all Sz on Sunday 2008-03-16)
#-this allows for independent t-tests (albeit suboptimal compared to paired t-tests)
MONnonDST <- Sz08to16notDST[which(Sz08to16notDST$wkday == "Monday"),"datetime"]
MONcounts <- table(as.Date(MONnonDST,'America/Los_Angeles'))
TUEnonDST <- Sz08to16notDST[which(Sz08to16notDST$wkday == "Tuesday"),"datetime"]
TUEcounts <- table(as.Date(TUEnonDST,'America/Los_Angeles'))
WEDnonDST <- Sz08to16notDST[which(Sz08to16notDST$wkday == "Wednesday"),"datetime"]
WEDcounts <- table(as.Date(WEDnonDST,'America/Los_Angeles'))
THUnonDST <- Sz08to16notDST[which(Sz08to16notDST$wkday == "Thursday"),"datetime"]
THUcounts <- table(as.Date(THUnonDST,'America/Los_Angeles'))
FRInonDST <- Sz08to16notDST[which(Sz08to16notDST$wkday == "Friday"),"datetime"]
FRIcounts <- table(as.Date(FRInonDST,'America/Los_Angeles'))
SATnonDST <- Sz08to16notDST[which(Sz08to16notDST$wkday == "Saturday"),"datetime"]
SATcounts <- table(as.Date(SATnonDST,'America/Los_Angeles'))
SUNnonDST <- Sz08to16notDST[which(Sz08to16notDST$wkday == "Sunday"),"datetime"]
SUNcounts <- table(as.Date(SUNnonDST,'America/Los_Angeles'))

#Get seizure counts for each day of the week in DST
#-this is tabulated BY DATE (i.e. all Sz on Sunday 2008-03-16)
MONinDST <- Sz08to16wkofDST[which(Sz08to16wkofDST$wkday == "Monday"),"datetime"]
MONcount <- table(as.Date(MONinDST,'America/Los_Angeles'))
TUEinDST <- Sz08to16wkofDST[which(Sz08to16wkofDST$wkday == "Tuesday"),"datetime"]
TUEcount <- table(as.Date(TUEinDST,'America/Los_Angeles'))
WEDinDST <- Sz08to16wkofDST[which(Sz08to16wkofDST$wkday == "Wednesday"),"datetime"]
WEDcount <- table(as.Date(WEDinDST,'America/Los_Angeles'))
THUinDST <- Sz08to16wkofDST[which(Sz08to16wkofDST$wkday == "Thursday"),"datetime"]
THUcount <- table(as.Date(THUinDST,'America/Los_Angeles'))
FRIinDST <- Sz08to16wkofDST[which(Sz08to16wkofDST$wkday == "Friday"),"datetime"]
FRIcount <- table(as.Date(FRIinDST,'America/Los_Angeles'))
SATinDST <- Sz08to16wkofDST[which(Sz08to16wkofDST$wkday == "Saturday"),"datetime"]
SATcount <- table(as.Date(SATinDST,'America/Los_Angeles'))
SUNinDST <- Sz08to16wkofDST[which(Sz08to16wkofDST$wkday == "Sunday"),"datetime"]
SUNcount <- table(as.Date(SUNinDST,'America/Los_Angeles'))

#T-tests (x is for weekdays in DST):
t.test(MONcount,MONcounts)
t.test(TUEcount,TUEcounts)
t.test(WEDcount,WEDcounts)
t.test(THUcount,THUcounts)
t.test(FRIcount,FRIcounts)
t.test(SATcount,SATcounts)
t.test(SUNcount,SUNcounts)

#Prior method for getting Rate Ratios for weekdays:
counter=1
    for(i in list) {
        weekdaydf <- grep(paste("^",substr(i,1,3),sep=""),NONnames,value=T,ignore.case=T)
        index=counter
        for(j in min(year(Sz08to16$datetime)):max(year(Sz08to16$datetime))) {
            week2week[index,"Weekday"] <- i
            week2week[index,"Year"] <- j
            week2week[index,"RateRatio"] <- l.df[[weekdaydf]][which(year(as.Date(l.df[[weekdaydf]][,"Var1"])) == j),"RateRatio"]
            index=index+1
        }
        counter=index
    }
    
#Now, feature scale each individual's yearly seizures to [0-1]
scaleIDs <- unique(Sz08to16$Unlinked_ID) #get list of unique IDs
for(i in scaleIDs) {
    #Sz08to16 subset just for this individual
    scalesub <- Sz08to16[which(Sz08to16$Unlinked_ID == i),c("Unlinked_ID","datetime")]
    #adding an orderable value of format YYYY.DDD
    scalesub$year.day <- as.numeric(paste(year(scalesub$datetime),
                                          formatC(yday(scalesub$datetime),width=3,flag=0),
                                          sep="."))
    for(k in min(year(scalesub$datetime)):max(year(scalesub$datetime))) {
        #Subset for year k
        fortable <- scalesub[which(year(scalesub$datetime) == k),]
        #Get seizure counts for each day that had documented seizures by individual i in year k
        library(data.table)
        tableofi <- as.data.frame(table(yday(fortable$datetime)))
        tableofi$Var1 <- as.numeric(as.character(tableofi$Var1)) #converts days back to numeric
        library(lubridate)
        #Now with unit vector scaling, in hindsight, partitioning partial/total years was not necessary
        if(k < min(year(scalesub$datetime))) { #Skip years in which the person wasn't yet documenting
        } else if(k == min(year(scalesub$datetime))) { #For year with i's first documented seizure...
            #...gentable is created to start from day of year with first documented seizure
            gentable <- data.frame("Var1"=seq.int(min(tableofi$Var1),
                                                  max(yday(Sz08to16[which(year(Sz08to16$datetime) == k),
                                                                    "datetime"]))),
                                   "Freq"=0)
            #...and documented daily seizure counts are added into the gentable
            for(j in tableofi$Var1) {
                gentable[which(gentable$Var1 == j),"Freq"] <- tableofi[which(tableofi$Var1 == j),"Freq"]
            }
            #...then daily seizure counts are scaled to [0-1] based on i's yearly seizure "profusion", by making the whole year's seizure vector downscale to unit length: https://en.wikipedia.org/wiki/Feature_scaling
            gentable$scaled <- apply(gentable[2], MARGIN = 2, FUN = function(x) {x / sqrt(sum(x^2))})
            toreturn <- merge.data.frame(tableofi,gentable)[,-2]
        } else if(k < min(year(scalesub$datetime))) { #For years after i's first documented seizure...
            #...gentable is created to start on day 1 of year k and end on the last day of year k
            gentable <- data.frame("Var1"=seq.int(min(yday(Sz08to16[which(year(Sz08to16$datetime) == k),
                                                                    "datetime"])),
                                                  max(yday(Sz08to16[which(year(Sz08to16$datetime) == k),
                                                                    "datetime"]))),
                                   "Freq"=0)
            #...and documented daily seizure counts are added into the gentable
            for(j in tableofi$Var1) {
                gentable[which(gentable$Var1 == j),"Freq"] <- tableofi[which(tableofi$Var1 == j),"Freq"]
            }
            #...then daily seizure counts are scaled to [0-1] based on i's yearly seizure "profusion", by making the whole year's seizure vector downscale to unit length: https://en.wikipedia.org/wiki/Feature_scaling
            gentable$scaled <- apply(gentable[2], MARGIN = 2, FUN = function(x) {x / sqrt(sum(x^2))})
            toreturn <- merge.data.frame(tableofi,gentable)[,-2]
        }
        for(j in toreturn$Var1) {
            Sz08to16[which(Sz08to16$Unlinked_ID == i & year(Sz08to16$datetime) == k & yday(Sz08to16$datetime) == j),"ScaledSzCount"] <- toreturn[which(toreturn$Var1 == j),2][1]
        }
    }
}
###TO DO: Still need to recalculate scaled daily/weekly incidences

#############SCRATCH
#apply(gentable[2], MARGIN = 2, FUN = function(x) (x-mean(gentable$Freq)/sd(gentable$Freq)))
[order( forstats[,1], forstats[,2] ),]
#Now, feature scale each individual's yearly seizures to [0-1]
scaleIDs <- unique(Sz08to16$Unlinked_ID) #get list of unique IDs
for(i in scaleIDs) {
    for(j in min(year(Sz08to16$datetime)):max(year(Sz08to16$datetime))) {
        X <- Sz08to16[which(Sz08to16$Unlinked_ID == i & year(Sz08to16$datetime) == j),"FreqperDAY"]
        scaledDAY <- (X - min(X))/diff(range(X)) #Feature scale that year's daily seizure counts, per individual
        Sz08to16[which(Sz08to16$Unlinked_ID == i & year(Sz08to16$datetime) == j),"scaledFreqperDAY"] <- scaledDAY
        Y <- Sz08to16[which(Sz08to16$Unlinked_ID == i & year(Sz08to16$datetime) == j),"FreqperWEEK"]
        scaledWEEK <- (Y - min(Y))/diff(range(Y)) #Feature scale that year's weekly seizure counts, per individual
        Sz08to16[which(Sz08to16$Unlinked_ID == i & year(Sz08to16$datetime) == j),"scaledFreqperWEEK"] <- scaledWEEK
    }
}
#Now calculating a scaled incidence from the scaled seizure frequencies
Sz08to16$scaledIncperDAY <- Sz08to16$scaledFreqperDAY/Sz08to16$AtRiskperDAY
Sz08to16$scaledIncperWEEK <- Sz08to16$scaledFreqperWEEK/Sz08to16$AtRiskperWEEK
################SCRATCH

```