---
title: "Seizure Tracker DST analysis.Rmd"
author: "Logan Schneider"
date: "December 12, 2017"
output: html_document
---
    
    ```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown  
```{r FYI, echo=FALSE}
#print("Analyses perfomed using:")
#R.Version()$version.string
print("lubridate,zoo,ggplot2,RColorBrewer,car,agricolae")
library(lubridate)
library(zoo)
library(ggplot2)
library(RColorBrewer)
library(car)
library(agricolae)
print("Please use the following citation information")
citation()

sessionInfo()
```
  
Data processing  
#useful calculator: http://www.webexhibits.org/daylightsaving/b.html  
#date manipulations with POSIXct variables: https://rstudio-pubs-static.s3.amazonaws.com/28038_1bcb9aa80ca84f27ace07d612872861a.html  
#=====================================#
```{r Data processing}
#read in Sz entry dataset
#install.packages("lubridate")
#library("lubridate")
Sz <- read.csv("STFullExportMignot_20170317.csv_Seizures.txt",stringsAsFactors = F)
names(Sz)
#convert Date_Time to POSIXct format
#alternatively could use install.packages("anytime")
#library("anytime")
Sz$datetime <- as.POSIXct(Sz$Date_Time, format="%Y-%m-%d %H:%M:%S")
summary(year(Sz$datetime))
#export was March 2017, and also don't care about seizures from before origination date Dec 2007
Sz08to17 <- Sz[which(year(Sz$datetime)>2007 & year(Sz$datetime)<2018),]
summary(year(Sz08to17$datetime))
paste("Entries dropped: ",dim(Sz)[1]-dim(Sz08to17)[1]," (",round((dim(Sz)[1]-dim(Sz08to17)[1])*100/dim(Sz)[1],2),"%)",sep = "")
#create sleep period and daytime categories
#first add weekdays
Sz08to17$wkday <- weekdays(Sz08to17$datetime)
#overnight defined as 21:00-07:00, to capture the general sense of sleep periods for most individuals
Sz08to17$overnight <- ifelse(hour(Sz08to17$datetime)<7 | hour(Sz08to17$datetime)>21,1,0)
#confirm
head(Sz08to17[,c("datetime","overnight")],10)
#define the start of the overnight seizures
Sz08to17$overnightStart <- ifelse(hour(Sz08to17$datetime)<7,weekdays(Sz08to17$datetime-3600*24),ifelse(hour(Sz08to17$datetime)>21,weekdays(Sz08to17$datetime),"NA"))
#confirm
head(Sz08to17[,c("datetime","wkday","overnightStart")],10)
#define the week of the year
Sz08to17$weeknum <- isoweek(Sz08to17$datetime)
#confirm
tail(Sz08to17[,c("datetime","weeknum","wkday")],15)
#convert seizure duration to seconds only
Sz08to17$dur_secs <- Sz08to17$length_hr*3600+Sz08to17$length_min*60+Sz08to17$length_sec
#remove seizures with negative duration
Sz08to17 <- Sz08to17[which(Sz08to17$dur_secs>0),]
#confirm
head(Sz08to17[,c("length_hr","length_min","length_sec","dur_secs")],10)
summary(Sz08to17[,c("length_hr","length_min","length_sec","dur_secs")])
```
  
Adding daylight saving information for each year, using methods from:  
```{r getting DST/ST information}
#http://stackoverflow.com/questions/26226453/lubridate-get-date-of-certain-day-in-a-month  
#Most of the US begins DST at 02:00 on the second Sunday in March ends on the first Sunday in November  
#install.packages("zoo")
#library("zoo")
Sz08to17$inDST <- as.POSIXlt(Sz08to17$datetime)$isdst
#confirm
tail(Sz08to17[,c("datetime","inDST")],15)
#determine date of DSTon and DSToff for the year
#and calculate the days since either, depending upon whether in DST or not
#the multiple nested loops makes this a HUGE time commitment (12-13 hrs of processing)

###=====This one takes a little while to run=====###
for(i in 1:length(Sz08to17$datetime)) {
    if(Sz08to17[i,"inDST"]==1) {
        #this calculates the date of the preceding DST transition
        DSTon <- as.Date(ymd(paste(year(as.POSIXlt(Sz08to17[i,"datetime"])),3,01,sep="-")))
        DSTon <- as.Date(ifelse(wday(DSTon)==1,DSTon+7,DSTon+(15-wday(DSTon))))
        #this calculates the days since the preceding DST transition (relevant for analyses of first week's days: 0-6::Sun-Sat)
        Sz08to17[i,"DSTonday"] <- as.numeric(round(as.Date(Sz08to17[i,"datetime"])-as.Date(as.POSIXct(DSTon)),0))
        Sz08to17[i,"DSToffday"] <- "NA"
    } else {
        if(month(Sz08to17[i,"datetime"])>3) {
            #this calculates the date of the preceding ST transition
            DSToff <- as.Date(ymd(paste(year(as.POSIXlt(Sz08to17[i,"datetime"])),11,01,sep="-")))
            DSToff <- as.Date(ifelse(wday(DSToff)==1,DSToff,DSToff+(8-wday(DSToff))))
            #this calculates the days since the preceding ST transition (relevant for analyses of first week's days: 0-6::Sun-Sat)
            Sz08to17[i,"DSToffday"] <- as.numeric(round(as.Date(Sz08to17[i,"datetime"])-as.Date(as.POSIXct(DSToff)),0))
        } else {
            #this calculates the date of the preceding ST transition
            DSToff <- as.Date(ymd(paste(year(as.POSIXlt(Sz08to17[i,"datetime"]))-1,11,01,sep="-")))
            DSToff <- as.Date(ifelse(wday(DSToff)==1,DSToff,DSToff+(8-wday(DSToff))))
            #this calculates the days since the preceding ST transition (relevant for analyses of first week's days: 0-6::Sun-Sat)
            Sz08to17[i,"DSToffday"] <- as.numeric(round(as.Date(Sz08to17[i,"datetime"])-as.Date(as.POSIXct(DSToff)),0))
        }
        Sz08to17[i,"DSTonday"] <- "NA"
    }
}
###=====This one takes a little while to run=====###

#adding week and day number for DST/ST transitions, so can align to t0=transition time
###=====This one takes a little while to run=====###
for(i in 1:length(Sz08to17$datetime)) {
    #this calculates the date of the DST transition for the year
    DSTon <- as.Date(ymd(paste(year(as.POSIXlt(Sz08to17[i,"datetime"])),3,01,sep="-")))
    DSTon <- as.Date(ifelse(wday(DSTon)==1,DSTon+7,DSTon+(15-wday(DSTon))))
    Sz08to17[i,"DSTweek"] <- as.numeric(week(DSTon))
    Sz08to17[i,"DSTday"] <- as.numeric(yday(DSTon))
    #this calculates the date of the ST transition for the year
    DSToff <- as.Date(ymd(paste(year(as.POSIXlt(Sz08to17[i,"datetime"])),11,01,sep="-")))
    DSToff <- as.Date(ifelse(wday(DSToff)==1,DSToff,DSToff+(8-wday(DSToff))))
    Sz08to17[i,"STweek"] <- as.numeric(week(DSToff))
    Sz08to17[i,"STday"] <- as.numeric(yday(DSToff))
}
###=====This one takes a little while to run=====###
#because the addition of NAs coerced the numbers to characters, so coerce back
Sz08to17 <- transform(Sz08to17, DSTonday = as.numeric(DSTonday), DSToffday = as.numeric(DSToffday))

#should be 238 days in DST, so check
summary(Sz08to17$DSTonday)
ifelse(238>=max(Sz08to17$DSTonday,na.rm = T) & 0<=min(Sz08to17$DSTonday,na.rm = T),"expected result","needs a check")
checkON <- Sz08to17[which(Sz08to17$DSTonday==0),]
summary(Sz08to16$STday-Sz08to16$DSTday) # another verification

#conversely, there could be up to 133 days not in DST, depending upon leap years and calendar year crossings (e.g. Nov 1st, 2015 to March 13th, 2016)
summary(Sz08to17$DSToffday)
ifelse(133>=max(Sz08to17$DSToffday,na.rm = T) & 0<=min(Sz08to17$DSToffday,na.rm = T),"expected result","needs a check")
checkOFF <- Sz08to17[which(Sz08to17$DSToffday==0),]
```
  
Now to determine status epilepticus (in the event of stratified analyses)
```{r status determination}
#Define status as >5 min Sz
###=====This one takes a little while to run=====###
for(i in 1:nrow(Sz08to17)) {
    if(Sz08to17[i,"dur_secs"] > 299) {
        Sz08to17[i,"StatusYN"] <- 1
        Sz08to17[i,"Statusdur"] <- Sz08to17[i,"dur_secs"]
    } else {
        Sz08to17[i,"StatusYN"] <- 0
        Sz08to17[i,"Statusdur"] <- 0
    }
}
###=====This one takes a little while to run=====###

#OR multiple Sz with inter-Sz interval <5 min with time from start to end of all Sz >5 min
#Get the dataframe into an order in which the following algorithmic Status Epilepticus checking can work (assumes seizures entered in non-temporal order)
ordered <- Sz08to17[with(Sz08to17, order(Unlinked_ID, datetime)), ]

#define only those events <5 min apart (giving essentially 91,589 lines to look at, rather than the full 1,409,382)
###=====This one takes a while to run=====###
for(i in 2:nrow(ordered)) {
    ordered[i,"timeFROMlast"] <- as.numeric(difftime(ordered[i,"datetime"],ordered[i-1,"datetime"],units="secs"))-ordered[i-1,"dur_secs"]
}
###=====This one takes a while to run=====###
ordered[1,"timeFROMlast"] <- 0

#run through the rows of the dataframe
###=====This one takes about 1 day to run=====###
for(i in 1:(nrow(ordered)-1)) {
    #only perform this nested looping if <5 min between events (ordered by time within individuals)
    if(ordered[i+1,"timeFROMlast"] < 300 & ordered[i+1,"timeFROMlast"] > 0) {
        #start relative index for blocks of similar IDs
        j <- 1
        #if IDs are the same from current i and next entry...
        if(ordered[i,"Unlinked_ID"] == ordered[i+1,"Unlinked_ID"] & i>=j) {
            #...set ID block range from i to the end with j...
            j <- rle(ordered[i:nrow(ordered),"Unlinked_ID"])$lengths[1]
            #...then loop over the ID block
            for(k in i:i+j-1) {
                #if date is the same from current k and next entry (within the same ID block)...
                if(date(ordered[k,"datetime"]) == date(ordered[k+1,"datetime"])) {
                    #...set date block range from k to second from the end with m...
                    m <- rle(as.numeric(date(ordered[k:nrow(ordered),"datetime"])))$lengths[1]
                    #...then loop over the same-date-within-same-ID block
                    SEstart <- k
                    SEend <- k
                    while(k<m) {
                        #if the time between this and the next Sz is <5 min
                        if(ordered[k+1,"timeFROMlast"] < 300 & ordered[k+1,"timeFROMlast"] > 0) {
                            #...set the end of the the Status to the next line
                            SEend <- k+1
                        } else {
                            #...otherwise, end the Status block and calculate total duration
                            #NOTE: this will only define new Status entries if not able to create a new SEend AND the Status did iterate previously (i.e. SEstart<SEend)
                            #...set the SEstart->SEend entries to Status Yes (1)
                            #...and set all to the total "status epilepticus" duration (from start of first to end of last seizure in status series)
                            if(SEstart<SEend) {
                                for(p in SEstart:SEend) {
                                    #this makes all entries for a given status event have duration from start of SEstart's Sz to end of SEend's Sz
                                    ordered[p,"StatusYN"]<-1
                                    ordered[p,"Statusdur"]<-as.numeric(ordered[SEend,"datetime"],ordered[SEstart,"datetime"],units="secs")+ordered[SEend,"dur_secs"]
                                }
                            }
                            SEstart <- k+1
                        }
                        k <- k+1
                    }
                }
            }
        }
    }
}
###=====This one takes about 1 day to run=====###

head(ordered[,c("timeFROMlast","Unlinked_ID","datetime")],15)
tail(ordered[,c("timeFROMlast","Unlinked_ID","datetime")],15)
###CLEANED THE DATA: https://docs.google.com/document/d/1-hO9j-3Zj9mUBu6ukHHilunIDDx_0U7cExPqzt5BA8w/edit?ts=58d2cd60
#personal notes on specifics to my analysis (but check/clean on all aspects in Google)
#May need to do "Sz pos" analysis for those with neg durations, as they comprise about 20% of the data
```
  
Data imaging and analysis   
#====================================#  
```{r yearly data summaries}
#examine by year; source method: http://stackoverflow.com/questions/2127926/how-do-i-highlight-an-observations-bin-in-a-histogram-in-r
highlight <- function(x, value1, value2, col.value1, col.value2, col=NA, ...){
    hst <- hist(x, ...)
    idx1 <- findInterval(value1, hst$breaks)
    idx2 <- findInterval(value2, hst$breaks)
    cols <- rep(col, length(hst$counts))
    cols[idx1] <- col.value1
    cols[idx2] <- col.value2
    hist(x, col=cols, ...)
}
for(i in 2008:2017) {
    DSTon <- as.Date(ymd(paste(i,3,01,sep="-")))
    DSTon <- as.Date(ifelse(wday(DSTon)==1,DSTon+7,DSTon+(15-wday(DSTon))))
    DSToff <- as.Date(ymd(paste(i,11,01,sep="-")))
    DSToff <- as.Date(ifelse(wday(DSToff)==1,DSToff,DSToff+(8-wday(DSToff))))
    Szwks <- week(ordered[which(year(ordered$datetime)==i),"datetime"])
    highlight(Szwks,week(DSTon),week(DSToff),"red","blue",breaks=week(as.POSIXct(paste(i,12,31,sep="-"))),main=paste("Histogram of seizure counts for ",i,sep=""))
}

#plot aggregate data from complete years: 2008-2016
#-normalize week of DST transition to 0
Sz08to16 <- ordered[which(year(ordered$datetime)<2017),]
Szwks<-week(Sz08to16[,"datetime"])-Sz08to16[,"DSTweek"]
#-plot with highlights
highlight(Szwks,0,34,"red","blue",breaks=53,main="Histogram of seizure counts for Jan 2008-Dec 2016")
```
  
Subsetting datasets for DST and baseline time windows
```{r data subsetting}
#Make relevant dataframes for comparison:
#-the week of DST (DSTonday 0-6: Sun-Sat)
Sz08to16wkofDST <- Sz08to16[which(Sz08to16$DSTonday >= 0 & Sz08to16$DSTonday < 7),] #only includes DST-week days
summary(Sz08to16wkofDST$DSTonday)
wkofDST <- table(Sz08to16wkofDST$wkday)
recombobulate <- c(4,2,6,7,5,1,3) #needed to reorder the alphabetical ordering default of table
barplot(wkofDST[recombobulate])
str(Sz08to16wkofDST$DSTonday)
#-the week before DST (a control time period)
Sz08to16wkpreDST <- Sz08to16[which((yday(Sz08to16$datetime) >= Sz08to16$DSTday-7 ) & (yday(Sz08to16$datetime) < Sz08to16$DSTday-0 ) ),] #only includes days in week before DST
summary(yday(Sz08to16wkpreDST$datetime))
summary(Sz08to16$DSTday)
wkpreDST <- table(Sz08to16wkpreDST$wkday)
recombobulate <- c(4,2,6,7,5,1,3) #needed to reorder the alphabetical ordering default of table
barplot(wkpreDST[recombobulate])
str(yday(Sz08to16wkpreDST$datetime))
#-the week following DST week (a control time period)
Sz08to16wkpostDST <- Sz08to16[which(Sz08to16$DSTonday >= 7 & Sz08to16$DSTonday < 14),] #only includes days in week following DST week
summary(yday(Sz08to16wkpostDST$datetime))
summary(Sz08to16$DSTday)
wkpostDST <- table(Sz08to16wkpostDST$wkday)
recombobulate <- c(4,2,6,7,5,1,3) #needed to reorder the alphabetical ordering default of table
barplot(wkpostDST[recombobulate])
str(yday(Sz08to16wkpostDST$datetime))
#-the week of ST (STonday 0-6: Sun-Sat) (a control time period, or primary time period)
Sz08to16wkofST <- Sz08to16[which(Sz08to16$DSToffday >= 0 & Sz08to16$DSToffday < 7),] #only includes ST-week days
summary(Sz08to16wkofST$DSToffday)
wkofST <- table(Sz08to16wkofST$wkday)
recombobulate <- c(4,2,6,7,5,1,3) #needed to reorder the alphabetical ordering default of table
barplot(wkofST[recombobulate])
str(Sz08to16wkofST$DSToffday)
#-the week before ST (a control time period)
Sz08to16wkpreST <- Sz08to16[which(Sz08to16$DSTonday > 231 & Sz08to16$DSTonday <= 238),] #only includes days in week before ST week
summary(yday(Sz08to16wkpreST$datetime))
summary(Sz08to16$STday)
wkpreST <- table(Sz08to16wkpreST$wkday)
recombobulate <- c(4,2,6,7,5,1,3) #needed to reorder the alphabetical ordering default of table
barplot(wkpreST[recombobulate])
str(yday(Sz08to16wkpreST$datetime))
#-the week following ST week (a control time period)
Sz08to16wkpostST <- Sz08to16[which(Sz08to16$DSToffday >= 7 & Sz08to16$DSToffday < 14),] #only includes days in week following ST week
summary(yday(Sz08to16wkpostST$datetime))
summary(Sz08to16$STday)
wkpostST <- table(Sz08to16wkpostST$wkday)
recombobulate <- c(4,2,6,7,5,1,3) #needed to reorder the alphabetical ordering default of table
barplot(wkpostST[recombobulate])
str(yday(Sz08to16wkpostST$datetime))
#-NOT week of DST (a control time period)
Sz08to16notDST <- Sz08to16[which(Sz08to16$DSTonday >= 7 | Sz08to16$DSToffday >=0),] #includes all non-DST-week days and all ST days
summary(yday(Sz08to16notDST$datetime))
notDST <- table(Sz08to16notDST$wkday)
recombobulate <- c(4,2,6,7,5,1,3) #needed to reorder the alphabetical ordering default of table
barplot(notDST[recombobulate])
str(yday(Sz08to16notDST$datetime))
```
  
Comparisons to baseline windows  
###ANALYZED AS SO: chi square by day of the week, T-test (two tailed) by average day of the week, ORs
```{r initial comparisons for chi-square}
DSTvsPRE <- data.frame("wkofDST"=as.data.frame(wkofDST[recombobulate])[,2],"wkpreDST"=as.data.frame(wkpreDST[recombobulate])[,2])
rownames(DSTvsPRE) <- c("Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday")
chisq.test(DSTvsPRE)
barplot(t(DSTvsPRE),legend=T,beside=T)

DSTvsST <- data.frame("wkofDST"=as.data.frame(wkofDST[recombobulate])[,2],"wkofST"=as.data.frame(wkofST[recombobulate])[,2])
rownames(DSTvsST) <- c("Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday")
chisq.test(DSTvsST)
barplot(t(DSTvsST),legend=T,beside=T)
```
  
Calculate Z-scores and percentile for DST seizure mean using the whole of population data as the "normative baseline"  
```{r zscore comparisons and independent t-tests comparing DST to any non-DST baseline weekday}
dailypercentiles <- data.frame("Weekday"=character(),
                               "MeanPercentile"=numeric(),
                               "PercentileSD"=numeric(),
                               stringsAsFactors = F)
sigdf <- data.frame("Weekday"=character(),
                    "p"=numeric(),
                    "p.signif"=character(),
                    stringsAsFactors = F)
percentalls <- data.frame("Year"=numeric(),
                          "Percentile"=numeric(),
                          "Weekday"=character(),
                          stringsAsFactors = F)
yearlist <- c(min(year(Sz08to16$datetime)):max(year(Sz08to16$datetime))) #Bound years by the bounds of the dataset
list <- c("Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday")
index=1
for(i in list) {
    yearlyDSTdf <- data.frame("Year"=numeric(),
                              "PopMean"=numeric(),
                              "PopSD"=numeric(),
                              "SzCount"=numeric(),
                              "Zscore"=numeric(),
                              "Percentile"=numeric())
    counter=1
    for(j in yearlist) {
        daymean <- mean(table(as.Date(Sz08to16[which(Sz08to16$wkday == i & year(Sz08to16$datetime) == j),"datetime"],
                                      'America/Los_Angeles')))
        yearlyDSTdf[counter,"PopMean"] <- daymean
        daysd <- sd(table(as.Date(Sz08to16[which(Sz08to16$wkday == i & year(Sz08to16$datetime) == j),"datetime"],
                                  'America/Los_Angeles')))
        yearlyDSTdf[counter,"PopSD"] <- daysd
        yearlyDSTdf[counter,"Year"] <- j
        yearlyDSTdf[counter,"SzCount"] <- table(as.Date(Sz08to16wkofDST[which(Sz08to16wkofDST$wkday == i & year(Sz08to16wkofDST$datetime) == j),"datetime"],
                                                        'America/Los_Angeles'))[[1]]
        yearlyDSTdf[counter,"Zscore"] <- (yearlyDSTdf[counter,"SzCount"] - daymean)/daysd
        yearlyDSTdf[counter,"Percentile"] <- round(pnorm(yearlyDSTdf[counter,"Zscore"])*100,2)
        counter=counter+1
    }
    FORtall <- yearlyDSTdf[,c("Year","Percentile")]
    FORtall$Weekday <- i
    percentalls <- rbind(percentalls,FORtall)
    write.table(yearlyDSTdf,
                file = paste(i,"yearly percentiles.txt"),
                quote = F,
                row.names = F)
    
    dailypercentiles[index,"Weekday"] <- i
    dailypercentiles[index,"MeanPercentile"] <- mean(yearlyDSTdf$Percentile)
    dailypercentiles[index,"PercentileSD"] <- sd(yearlyDSTdf$Percentile)/sqrt(max(year(Sz08to16$datetime))-min(year(Sz08to16$datetime)))
    
    sigdf[index,"Weekday"] <- i
    sigdf[index,"p"] <- round(t.test(table(as.Date(firstweek[which(firstweek$wkday == i),"datetime"],'America/Los_Angeles')),
                                     table(as.Date(secondweek[which(secondweek$wkday == i),"datetime"],'America/Los_Angeles')))[["p.value"]],4)
    if(sigdf[index,"p"]<0.05 & sigdf[index,"p"]>0.01) {
        sigdf[index,"p.signif"] <- "*"
    } else if(sigdf[index,"p"]<0.01 & sigdf[index,"p"]>0.001) {
        sigdf[index,"p.signif"] <- "**"
    } else if(sigdf[index,"p"]<0.001) {
        sigdf[index,"p.signif"] <- "***"
    } else {
        sigdf[index,"p.signif"] <- "ns"
    }
    
    index=index+1
}
dailypercentiles$Weekday <- factor(dailypercentiles$Weekday, levels = dailypercentiles$Weekday) #ensures weekdays stay in order Sun-Sat
dailypercentiles
factorlevels <- factor(list,levels=list)
percentalls$Weekday <- factor(percentalls$Weekday, levels=factorlevels) #ensures weekdays stay in order Sun-Sat

#library(ggplot2)

ggplot(dailypercentiles, aes(x=Weekday, y=MeanPercentile)) + 
    geom_bar(position=position_dodge(), stat="identity",
             colour="black", # Use black outlines,
             size=.3,  # Thinner lines
             alpha=0.8) +  #Semi-transparent
    #stat_compare_means(aes(group = Week), label = "p.signif", label.y = 300)
    geom_errorbar(aes(ymin=MeanPercentile-PercentileSD, ymax=MeanPercentile+PercentileSD),
                  size=.3,    # Thinner lines
                  width=.2,
                  position=position_dodge(.9)) +
    geom_point(data=percentalls, aes(x=Weekday, y=Percentile, color=factor(Year)), size=3, alpha=0.8) + 
    xlab("Weekday") +
    ylab("Percentile (± SEM)") +
    ggtitle(paste("Percentile of DST seizure counts by weekday over period from",min(year(Sz08to16$datetime)),"to",max(year(Sz08to16$datetime)))) +
    scale_y_continuous(breaks=0:100*10, limits=c(0,100)) +
    theme_bw() + 
    theme(legend.title = element_blank())
png(paste("Percentile of DST seizure counts by weekday over period from ",min(year(Sz08to16$datetime))," to ",max(year(Sz08to16$datetime)),".png",sep=""), 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
print(ggplot(dailypercentiles, aes(x=Weekday, y=MeanPercentile)) + 
    geom_bar(position=position_dodge(), stat="identity",
             colour="black", # Use black outlines,
             size=.3) +      # Thinner lines
    #stat_compare_means(aes(group = Week), label = "p.signif", label.y = 300)
    geom_errorbar(aes(ymin=MeanPercentile-PercentileSD, ymax=MeanPercentile+PercentileSD),
                  size=.3,    # Thinner lines
                  width=.2,
                  position=position_dodge(.9)) +
    xlab("Weekday") +
    ylab("Percentile (± SEM)") +
    ggtitle(paste("Percentile of DST seizure counts by weekday over period from",min(year(Sz08to16$datetime)),"to",max(year(Sz08to16$datetime)))) +
    scale_y_continuous(breaks=0:100*10) +
    theme_bw())
dev.off()
```
  
Check seizure weekday percentiles for DST by ANOVA
```{r ANOVA of DST percentiles by weekday}
attach(percentalls)
Anova(lm(Percentile ~ Weekday,
         data=percentalls),
      type="III")
wkday2percentile <- aov(lm(Percentile ~ Weekday))
wkday2percentile
posthoc <- TukeyHSD(x=wkday2percentile, 'Weekday', conf.level = 0.95)
posthoc
hsdwkday2percentile <- HSD.test(wkday2percentile, "Weekday")
hsdwkday2percentile
```
It appears that Saturday is in a group all it's own (by DST percentiles)...and that it's somewhat protective  
Also, the periweekend days (Fri, Sat, and Sun) appear to be somewhat distinct as well  

###Is the "Weekend protective effect" present throughout the year?
```{r weekday counts for the whole dataset}
weekendlist <- c("Wednesday","Thursday","Friday","Saturday","Sunday","Monday","Tuesday")
factorlevels <- factor(list,levels=weekendlist) # setting factor levels to put weekend in middle of graphs
totANOVA <- as.data.frame(table(Sz08to16$wkday))
totANOVA$Var1 <- factor(totANOVA$Var1, levels=factorlevels)
#Just take a look at total seizure counts over the whole period

ggplot(totANOVA, aes(x=Var1, y=Freq, color=Var1)) + 
    geom_point(size=3) + 
    theme(legend.title = element_blank())
png("Weekday count totals from entire dataset.png", 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
print(ggplot(totANOVA, aes(x=Var1, y=Freq, color=Var1)) + 
    geom_point(size=3) + 
    theme(legend.title = element_blank()))
dev.off()
```
Seems like there might be a protective pattern for the weekends  
  
#First check ANOVA by yearly counts as a coarse estimate
```{r ANOVA by yearly count totals for each weekday}
tabling <- Sz08to16[,c("wkday","datetime")]
tabling$datetime <- year(tabling$datetime)
tabling$wkday <- factor(tabling$wkday, levels=factorlevels)
table(tabling)
barplot(table(tabling),
        col=brewer.pal(n=7,"Accent"),
        legend.text=T,
        args.legend=list(x="topleft"),
        beside=T)
png(paste("Weekday count totals from ",min(year(Sz08to16$datetime))," to ",max(year(Sz08to16$datetime)),".png",sep=""), 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
barplot(table(tabling),
        col=brewer.pal(n=7,"Accent"),
        legend.text=T,
        args.legend=list(x="topleft"),
        beside=T)
dev.off()
yearANOVA <- as.data.frame(table(tabling))
attach(yearANOVA)
Anova(lm(Freq ~ wkday,
         data=yearANOVA),
      type="III")
day2countYEAR <- aov(lm(Freq ~ wkday))
day2countYEAR
posthoc <- TukeyHSD(x=day2countYEAR, 'wkday', conf.level = 0.95)
posthoc
hsdday2countYEAR <- HSD.test(day2countYEAR, "wkday")
hsdday2countYEAR
```
Based on looking at those yearly counts, still seems like a plausible hypothesis  
  
#Now check ANOVA by weekly counts (more granular and less subject to varying/accruing subject counts over the year)
```{r ANOVA by weekly counts in each year}
tabling <- Sz08to16[,c("wkday","weeknum")]
summary(tabling)
#Because first (1st) and last weeks (52nd or 53rd) can be partial weeks, will remove so as not to bias averages for given weekdays
tabling <- tabling[which(tabling$weeknum > 1 & tabling$weeknum < 52),]
summary(tabling)

summary(Sz08to16$weeknum)
#Because first (1st) and last weeks (52nd or 53rd) can be partial weeks, will remove so as not to bias averages for given weekdays
FORtabling <- Sz08to16[which(Sz08to16$weeknum > 1 & Sz08to16$weeknum < 52),c("wkday","datetime","weeknum")]
summary(FORtabling$weeknum)
FORtabling$Date <- as.Date(FORtabling$datetime,'America/Los_Angeles')
summary(FORtabling$Date)
tabling <- FORtabling[,c("wkday","Date")]
tabling$wkday <- factor(tabling$wkday, levels=factorlevels)
#table(tabling)
weekdANOVA <- as.data.frame(table(tabling))
weekdANOVA$Date <- as.POSIXct(weekdANOVA$Date)
weekdANOVA <- weekdANOVA[which(weekdays(weekdANOVA$Date) == weekdANOVA$wkday),] #due to how table works, need to only keep counts for actual dat-weekday matches
weekdANOVA$Year <- year(weekdANOVA$Date)
ggplot() + 
    geom_boxplot(data=weekdANOVA, aes(x=wkday, y=Freq), fill="#4271AE", alpha=0.5, outlier.size=NA,na.rm=T) + #Avoid duplicate outlier plotting
    geom_jitter(data=weekdANOVA, aes(x=wkday,y=Freq,color=factor(Year)), position=position_jitter(width=0.05), alpha=0.8,na.rm=T) + #Outliers from incomplete weeks
    #geom_point(data=weekdANOVA, aes(x=wkday, y=Freq, color=factor(Year)), alpha=1, size=3) +
    geom_hline(yintercept = mean(weekdANOVA$Freq,na.rm=T)) + 
    geom_hline(yintercept = c(mean(weekdANOVA$Freq,na.rm=T)+1.96*sd(weekdANOVA$Freq,na.rm=T),
                              mean(weekdANOVA$Freq,na.rm=T)-1.96*sd(weekdANOVA$Freq,na.rm=T)),
               linetype=3) + 
    ylim((mean(weekdANOVA$Freq,na.rm=T)-2*sd(weekdANOVA$Freq,na.rm=T)),(mean(weekdANOVA$Freq,na.rm=T)+2*sd(weekdANOVA$Freq,na.rm=T))) + 
    xlab("Weekday") +
    ylab("Weekly seizure counts") +
    ggtitle("Weekly seizure counts, aggregated by day of the week") + 
    theme_bw() + 
    theme(legend.title = element_blank())
png(paste("Weekday seizure counts, aggregated by day of the week, from ",min(year(Sz08to16$datetime))," to ",max(year(Sz08to16$datetime)),".png",sep=""), 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
print(ggplot() + 
    geom_boxplot(data=weekdANOVA, aes(x=wkday, y=Freq), fill="#4271AE", alpha=0.5, outlier.size=NA,na.rm=T) + #Avoid duplicate outlier plotting
    geom_jitter(data=weekdANOVA, aes(x=wkday,y=Freq,color=factor(Year)), position=position_jitter(width=0.05), alpha=0.8,na.rm=T) + #Outliers from incomplete weeks
    #geom_point(data=weekdANOVA, aes(x=wkday, y=Freq, color=factor(Year)), alpha=1, size=3) +
    geom_hline(yintercept = mean(weekdANOVA$Freq,na.rm=T)) + 
    geom_hline(yintercept = c(mean(weekdANOVA$Freq,na.rm=T)+1.96*sd(weekdANOVA$Freq,na.rm=T),
                              mean(weekdANOVA$Freq,na.rm=T)-1.96*sd(weekdANOVA$Freq,na.rm=T)),
               linetype=3) + 
    ylim((mean(weekdANOVA$Freq,na.rm=T)-2*sd(weekdANOVA$Freq,na.rm=T)),(mean(weekdANOVA$Freq,na.rm=T)+2*sd(weekdANOVA$Freq,na.rm=T))) + 
    xlab("Weekday") +
    ylab("Weekly seizure counts") +
    ggtitle("Weekly seizure counts, aggregated by day of the week") + 
    theme_bw() + 
    theme(legend.title = element_blank()))
dev.off()
attach(weekdANOVA)
Anova(lm(Freq ~ wkday,
         data=weekdANOVA),
      type="III")
day2countWEEK <- aov(lm(Freq ~ wkday))
day2countWEEK
posthoc <- TukeyHSD(x=day2countWEEK, 'wkday', conf.level = 0.95)
posthoc
hsdday2countWEEK <- HSD.test(day2countWEEK, "wkday")
hsdday2countWEEK
```
Doesn't look like there is a trend in aggregate...  
  
#But the high variance introduced by recruitment may dilute the variation when comparing more stable at-risk population counts (i.e. over a given year)
```{r parse out by year}
p <- ggplot() 
for(i in min(year(Sz08to16$datetime)):max(year(Sz08to16$datetime))) {
    p <- p + geom_boxplot(data=weekdANOVA[which(weekdANOVA[,"Year"] == i),],
                 aes(x=wkday, y=Freq),
                 fill=brewer.pal(n=(max(year(Sz08to16$datetime))-min(year(Sz08to16$datetime))),"Paired")[i-2007],
                 alpha=0.2,
                 outlier.size=NA, #Avoid duplicate outlier plotting
                 notch = T, #Enhance visibility
                 na.rm=T)
    p <- p + geom_jitter(data=weekdANOVA[which(weekdANOVA[,"Year"] == i),],
                aes(x=wkday,y=Freq),
                color=brewer.pal(n=(max(year(Sz08to16$datetime))-min(year(Sz08to16$datetime))),"Paired")[i-2007],
                position=position_jitter(width=0.05),
                alpha=0.8,
                na.rm=T)#Outliers from incomplete weeks
}
p <- p + 
    ylim((mean(weekdANOVA$Freq,na.rm=T)-2*sd(weekdANOVA$Freq,na.rm=T)),(mean(weekdANOVA$Freq,na.rm=T)+2*sd(weekdANOVA$Freq,na.rm=T))) + 
    xlab("Weekday") +
    ylab("Weekly seizure counts") +
    ggtitle("Weekly seizure counts, aggregated by day of the week, separated by year") + 
    theme_bw()
p
print(p)

#That was a little messy, but it looks like the yearly pattern may be there, so plot them (and do ANOVA) separately
groups <- data.frame("Weekday"=weekendlist)
colid <- 2
for(i in min(year(Sz08to16$datetime)):max(year(Sz08to16$datetime))) {
    print(paste("Weekday seizure counts for the 2nd through 51st [full] weeks, for the year of",i))
    wXyANOVA <- weekdANOVA[which(weekdANOVA$Year == i),]
    print(ggplot() + 
        geom_boxplot(data=wXyANOVA, aes(x=wkday, y=Freq), fill="#4271AE", alpha=0.5, outlier.size=NA,na.rm=T) + #Avoid duplicate outlier plotting
        geom_jitter(data=wXyANOVA, aes(x=wkday,y=Freq), position=position_jitter(width=0.05), alpha=0.8,na.rm=T) + #Outliers from incomplete weeks
        geom_hline(yintercept = mean(wXyANOVA$Freq,na.rm=T)) + 
        geom_hline(yintercept = c(mean(wXyANOVA$Freq,na.rm=T)+1.96*sd(wXyANOVA$Freq,na.rm=T),
                                  mean(wXyANOVA$Freq,na.rm=T)-1.96*sd(wXyANOVA$Freq,na.rm=T)),
                   linetype=3) + 
        ylim((mean(wXyANOVA$Freq,na.rm=T)-2*sd(wXyANOVA$Freq,na.rm=T)),(mean(wXyANOVA$Freq,na.rm=T)+2*sd(wXyANOVA$Freq,na.rm=T))) + 
        xlab("Weekday") +
        ylab("Weekly seizure counts") +
        ggtitle(paste("Weekly seizure counts, aggregated by day of the week for",i)) + 
        theme_bw())
    png(paste("Weekday seizure counts for the 2nd through 51st (full) weeks, for the year of ",i,".png",sep=""), 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
        print(ggplot() + 
        geom_boxplot(data=wXyANOVA, aes(x=wkday, y=Freq), fill="#4271AE", alpha=0.5, outlier.size=NA,na.rm=T) + #Avoid duplicate outlier plotting
        geom_jitter(data=wXyANOVA, aes(x=wkday,y=Freq), position=position_jitter(width=0.05), alpha=0.8,na.rm=T) + #Outliers from incomplete weeks
        geom_hline(yintercept = mean(wXyANOVA$Freq,na.rm=T)) + 
        geom_hline(yintercept = c(mean(wXyANOVA$Freq,na.rm=T)+1.96*sd(wXyANOVA$Freq,na.rm=T),
                                  mean(wXyANOVA$Freq,na.rm=T)-1.96*sd(wXyANOVA$Freq,na.rm=T)),
                   linetype=3) + 
        ylim((mean(wXyANOVA$Freq,na.rm=T)-2*sd(wXyANOVA$Freq,na.rm=T)),(mean(wXyANOVA$Freq,na.rm=T)+2*sd(wXyANOVA$Freq,na.rm=T))) + 
        xlab("Weekday") +
        ylab("Weekly seizure counts") +
        ggtitle(paste("Weekly seizure counts, aggregated by day of the week for",i)) + 
        theme_bw())
    dev.off()
    attach(wXyANOVA)
    Anova(lm(Freq ~ wkday,
             data=wXyANOVA),
          type="III")
    day2countWEEK <- aov(lm(Freq ~ wkday))
    print(day2countWEEK)
    posthoc <- TukeyHSD(x=day2countWEEK, 'wkday', conf.level = 0.95)
    print(posthoc)
    hsdday2countWEEK <- HSD.test(day2countWEEK, "wkday")
    print(hsdday2countWEEK)
    plot(hsdday2countWEEK)
    png(paste("Honestly significant difference in seizure counts, by weekday, for ",i,".png",sep=""), 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
    plot(hsdday2countWEEK)
    dev.off()
    groups <- merge(groups,hsdday2countWEEK$groups[2],by.x="Weekday",by.y=0,sort=F)
    names(groups)[colid] <- i
    colid <- colid+1
}
print(groups)
```
It's possible that there is a grouping effect for the weekends...  
  
#It's worthwhile to attempt standardization by approximate incidence (through gross estimates of at-risk population)
```{r pseudostandardized incidence rates per day}
#This will add in the relevant data incidence data, based on an approximation of unique, at-risk individuals
# -note this denominator of person-time is inaccurate for multiple reasons:
#  +it counts people "at risk" only if they've documented a seizure - i.e. ascertainment bias for those reporting
#  +it doesn't account for single documenters that then stop using the app - also an ascertainment bias
#  +it doesn't account for interventions (i.e. surgery, changes in regimen), assuming similar risk over similar time periods
#  +it doesn't account for "voyeurs" - people who signed up, but haven't documented yet

###=====This one takes a little while to run=====###
for(j in 1:nrow(weekdANOVA)) {
    denomdf <- Sz08to16[which(Sz08to16$datetime <= as.Date(weekdANOVA[j,"Date"])),"Unlinked_ID"]
    weekdANOVA[j,"AtRisk"] <- length(unique(denomdf))
    weekdANOVA[j,"Incidence"] <- weekdANOVA[j,"Freq"]/length(unique(denomdf))
}
###=====This one takes a little while to run=====###

p <- ggplot() 
for(i in min(year(Sz08to16$datetime)):max(year(Sz08to16$datetime))) {
    p <- p + geom_boxplot(data=weekdANOVA[which(weekdANOVA[,"Year"] == i),],
                 aes(x=wkday, y=Incidence),
                 fill=brewer.pal(n=(max(year(Sz08to16$datetime))-min(year(Sz08to16$datetime))),"Paired")[i-2007],
                 alpha=0.2,
                 outlier.size=NA, #Avoid duplicate outlier plotting
                 notch = T, #Enhance visibility
                 na.rm=T)
    p <- p + geom_jitter(data=weekdANOVA[which(weekdANOVA[,"Year"] == i),],
                aes(x=wkday,y=Incidence),
                color=brewer.pal(n=(max(year(Sz08to16$datetime))-min(year(Sz08to16$datetime))),"Paired")[i-2007],
                position=position_jitter(width=0.05),
                alpha=0.8,
                na.rm=T)#Outliers from incomplete weeks
}
p <- p + 
    ylim((mean(weekdANOVA$Incidence,na.rm=T)-2*sd(weekdANOVA$Incidence,na.rm=T)),(mean(weekdANOVA$Incidence,na.rm=T)+2*sd(weekdANOVA$Incidence,na.rm=T))) + 
    xlab("Weekday") +
    ylab("Weekly seizure incidence rates (seizures per persons at risk)") +
    ggtitle("Weekly seizure incidence trends, by day of the week, separated by year") + 
    theme_bw()
p
print(p)

#That was a little messy, but it looks like the yearly pattern may be there, so plot them (and do ANOVA) separately
groups <- data.frame("Weekday"=weekendlist)
colid <- 2
for(i in min(year(Sz08to16$datetime)):max(year(Sz08to16$datetime))) {
    print(paste("Weekday seizure incidence trends for the 2nd through 51st [full] weeks, for the year of",i))
    wXyANOVA <- weekdANOVA[which(weekdANOVA$Year == i),]
    print(ggplot() + 
        geom_boxplot(data=wXyANOVA, aes(x=wkday, y=Incidence), fill="#4271AE", alpha=0.5, outlier.size=NA,na.rm=T) + #Avoid duplicate outlier plotting
        geom_jitter(data=wXyANOVA, aes(x=wkday,y=Incidence), position=position_jitter(width=0.05), alpha=0.8,na.rm=T) + #Outliers from incomplete weeks
        geom_hline(yintercept = mean(wXyANOVA$Incidence,na.rm=T)) + 
        geom_hline(yintercept = c(mean(wXyANOVA$Incidence,na.rm=T)+1.96*sd(wXyANOVA$Incidence,na.rm=T),
                                  mean(wXyANOVA$Incidence,na.rm=T)-1.96*sd(wXyANOVA$Incidence,na.rm=T)),
                   linetype=3) + 
        ylim((mean(wXyANOVA$Incidence,na.rm=T)-2*sd(wXyANOVA$Incidence,na.rm=T)),(mean(wXyANOVA$Incidence,na.rm=T)+2*sd(wXyANOVA$Incidence,na.rm=T))) + 
        xlab("Weekday") +
        ylab("Weekly seizure incidence rates (seizures per persons at risk)") +
        ggtitle(paste("Weekly seizure incidence trends, by day of the week for",i)) + 
        theme_bw())
    png(paste("Weekday seizure incidence trends for the 2nd through 51st (full) weeks, for the year of ",i,".png",sep=""), 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
        print(ggplot() + 
        geom_boxplot(data=wXyANOVA, aes(x=wkday, y=Incidence), fill="#4271AE", alpha=0.5, outlier.size=NA,na.rm=T) + #Avoid duplicate outlier plotting
        geom_jitter(data=wXyANOVA, aes(x=wkday,y=Incidence), position=position_jitter(width=0.05), alpha=0.8,na.rm=T) + #Outliers from incomplete weeks
        geom_hline(yintercept = mean(wXyANOVA$Incidence,na.rm=T)) + 
        geom_hline(yintercept = c(mean(wXyANOVA$Incidence,na.rm=T)+1.96*sd(wXyANOVA$Incidence,na.rm=T),
                                  mean(wXyANOVA$Incidence,na.rm=T)-1.96*sd(wXyANOVA$Incidence,na.rm=T)),
                   linetype=3) + 
        ylim((mean(wXyANOVA$Incidence,na.rm=T)-2*sd(wXyANOVA$Incidence,na.rm=T)),(mean(wXyANOVA$Incidence,na.rm=T)+2*sd(wXyANOVA$Incidence,na.rm=T))) + 
        xlab("Weekday") +
        ylab("Weekly seizure incidence rates (seizures per persons at risk)") +
        ggtitle(paste("Weekly seizure incidence trends, by day of the week for",i)) + 
        theme_bw())
    dev.off()
    attach(wXyANOVA)
    Anova(lm(Incidence ~ wkday,
             data=wXyANOVA),
          type="III")
    day2countWEEK <- aov(lm(Incidence ~ wkday))
    print(day2countWEEK)
    posthoc <- TukeyHSD(x=day2countWEEK, 'wkday', conf.level = 0.95)
    print(posthoc)
    hsdday2countWEEK <- HSD.test(day2countWEEK, "wkday")
    print(hsdday2countWEEK)
    plot(hsdday2countWEEK)
    png(paste("Honestly significant difference in seizure incidence, by weekday, for ",i,".png",sep=""), 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
    plot(hsdday2countWEEK)
    dev.off()
    groups <- merge(groups,hsdday2countWEEK$groups[2],by.x="Weekday",by.y=0,sort=F)
    names(groups)[colid] <- i
    colid <- colid+1
}
print(groups)
```
  
Seizure count comparisons by weekday
```{r a function for comparing weekdays, defaulted comparison between DST and all non-DST}
compareweekdays <- function(firstweek=Sz08to16wkofDST,
                            secondweek=Sz08to16notDST,
                            wkone="week of DST",
                            wktwo="all non DST") {
    
    #Get seizure counts for each day of the week in DST
    #-this is tabulated BY DATE (i.e. all Sz on Sunday 2008-03-16)
    #-this allows for independent t-tests (albeit suboptimal compared to paired t-tests)
    SUNinDST <- firstweek[which(firstweek$wkday == "Sunday"),"datetime"]
    SUNcount <- table(as.Date(SUNinDST,'America/Los_Angeles'))
    SUNcountdf <- as.data.frame(SUNcount)
    MONinDST <- firstweek[which(firstweek$wkday == "Monday"),"datetime"]
    MONcount <- table(as.Date(MONinDST,'America/Los_Angeles'))
    MONcountdf <- as.data.frame(MONcount)
    TUEinDST <- firstweek[which(firstweek$wkday == "Tuesday"),"datetime"]
    TUEcount <- table(as.Date(TUEinDST,'America/Los_Angeles'))
    TUEcountdf <- as.data.frame(TUEcount)
    WEDinDST <- firstweek[which(firstweek$wkday == "Wednesday"),"datetime"]
    WEDcount <- table(as.Date(WEDinDST,'America/Los_Angeles'))
    WEDcountdf <- as.data.frame(WEDcount)
    THUinDST <- firstweek[which(firstweek$wkday == "Thursday"),"datetime"]
    THUcount <- table(as.Date(THUinDST,'America/Los_Angeles'))
    THUcountdf <- as.data.frame(THUcount)
    FRIinDST <- firstweek[which(firstweek$wkday == "Friday"),"datetime"]
    FRIcount <- table(as.Date(FRIinDST,'America/Los_Angeles'))
    FRIcountdf <- as.data.frame(FRIcount)
    SATinDST <- firstweek[which(firstweek$wkday == "Saturday"),"datetime"]
    SATcount <- table(as.Date(SATinDST,'America/Los_Angeles'))
    SATcountdf <- as.data.frame(SATcount)
    
    #Get seizure counts for each day of the week not in DST
    #-this is tabulated BY DATE (i.e. all Sz on Sunday 2008-03-16)
    SUNnonDST <- secondweek[which(secondweek$wkday == "Sunday"),"datetime"]
    SUNcounts <- table(as.Date(SUNnonDST,'America/Los_Angeles'))
    SUNcountsdf <- as.data.frame(SUNcounts)
    MONnonDST <- secondweek[which(secondweek$wkday == "Monday"),"datetime"]
    MONcounts <- table(as.Date(MONnonDST,'America/Los_Angeles'))
    MONcountsdf <- as.data.frame(MONcounts)
    TUEnonDST <- secondweek[which(secondweek$wkday == "Tuesday"),"datetime"]
    TUEcounts <- table(as.Date(TUEnonDST,'America/Los_Angeles'))
    TUEcountsdf <- as.data.frame(TUEcounts)
    WEDnonDST <- secondweek[which(secondweek$wkday == "Wednesday"),"datetime"]
    WEDcounts <- table(as.Date(WEDnonDST,'America/Los_Angeles'))
    WEDcountsdf <- as.data.frame(WEDcounts)
    THUnonDST <- secondweek[which(secondweek$wkday == "Thursday"),"datetime"]
    THUcounts <- table(as.Date(THUnonDST,'America/Los_Angeles'))
    THUcountsdf <- as.data.frame(THUcounts)
    FRInonDST <- secondweek[which(secondweek$wkday == "Friday"),"datetime"]
    FRIcounts <- table(as.Date(FRInonDST,'America/Los_Angeles'))
    FRIcountsdf <- as.data.frame(FRIcounts)
    SATnonDST <- secondweek[which(secondweek$wkday == "Saturday"),"datetime"]
    SATcounts <- table(as.Date(SATnonDST,'America/Los_Angeles'))
    SATcountsdf <- as.data.frame(SATcounts)
    
    #T-tests (x is for weekdays in DST, y is for comparison weeks):
    print(SunT <- t.test(SUNcount,SUNcounts))
    print(MonT <- t.test(MONcount,MONcounts))
    print(TueT <- t.test(TUEcount,TUEcounts))
    print(WedT <- t.test(WEDcount,WEDcounts))
    print(ThuT <- t.test(THUcount,THUcounts))
    print(FriT <- t.test(FRIcount,FRIcounts))
    print(SatT <- t.test(SATcount,SATcounts))
    
    #Getting person-count approximate denominators and incidence rates for each day
    # -note this denominator of person-time is inaccurate for multiple reasons:
    #  +it counts people "at risk" only if they've documented a seizure - i.e. ascertainment bias for those reporting
    #  +it doesn't account for single documenters that then stop using the app - also an ascertainment bias
    #  +it doesn't account for interventions (i.e. surgery, changes in regimen), assuming similar risk over similar time periods
    #  +it doesn't account for "voyeurs" - people who signed up, but haven't documented yet
    
    #Creating list of count data frames
    l.df <- lapply(ls(pattern="[A-Z]countdf"), function(x) get(x))
    l.df <- append(l.df, lapply(ls(pattern="[A-Z]countsdf"), function(x) get(x)))
    #Getting names of environmental variables to name the list elements
    DSTnames <- ls(pattern="[A-Z]countdf")
    NONnames <- ls(pattern="[A-Z]countsdf")
    listnames <- c(DSTnames,NONnames)
    names(l.df) <- listnames
    
    for(i in listnames) {
        #This will add in the relevant data
        for(j in 1:nrow(l.df[[i]])) {
            denomdf <- Sz08to16[which(Sz08to16$datetime <= as.Date(l.df[[i]][j,"Var1"])),"Unlinked_ID"]
            l.df[[i]][j,"AtRisk"] <- length(unique(denomdf))
            l.df[[i]][j,"Incidence"] <- l.df[[i]][j,"Freq"]/length(unique(denomdf))
        }
    }
    
    #For each non-DST data frame add in DST variables and calculate Rate Ratios
    for(i in NONnames) {
        DST4NON <- grep(paste("^",substr(i,1,3),sep=""),DSTnames,value=T) #Get name of comparable DST week
        for(j in 1:nrow(l.df[[i]])) { #Iterate over dates in non-DST data frame
            for(k in 1:nrow(l.df[[DST4NON]])) { #Iterate over dates in DST data frame to add comparisons to non-DST data frame
                if(year(l.df[[i]][j,"Var1"]) == year(l.df[[DST4NON]][k,"Var1"])) { 
                    l.df[[i]][j,"DSTFreq"] <- l.df[[DST4NON]][k,"Freq"] 
                    l.df[[i]][j,"DSTAtRisk"] <- l.df[[DST4NON]][k,"AtRisk"] 
                    l.df[[i]][j,"DSTIncidence"] <- l.df[[DST4NON]][k,"Incidence"] 
                }
            }
        }
        l.df[[i]][,"RateRatio"] <- l.df[[i]][,"DSTIncidence"]/l.df[[i]][,"Incidence"] #Calculate Rate Ratios
    }
    
    #Put the new data frames back into the Global Environment
    list2env(l.df,envir=.GlobalEnv)
    
    week2week <- data.frame("Weekday"=character(),
                            "Year"=numeric(),
                            "RateRatio"=numeric(),
                            stringsAsFactors = F)
    list <- c("Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday")
    
    for(i in list) {
        weekdaydf <- grep(paste("^",substr(i,1,3),sep=""),NONnames,value=T,ignore.case=T)
        for(j in min(year(Sz08to16$datetime)):max(year(Sz08to16$datetime))) {
            FORweek2week <- data.frame("RateRatio"=l.df[[weekdaydf]][which(year(as.Date(l.df[[weekdaydf]][,"Var1"])) == j),"RateRatio"])
            FORweek2week$"Weekday" <- i
            FORweek2week$"Year" <- j
            FORweek2week <- FORweek2week[,c(2,3,1)]
            week2week <- rbind(week2week,FORweek2week)
        }
    }
    
    factorlevels <- factor(list,levels=list)
    week2week$Weekday <- factor(week2week$Weekday, levels = factorlevels) #Ensures Weekdays stay in the same order, despite coercing to factors
    write.table(week2week,
                file=paste("Weekday seizure Rate Ratios for ",wkone," compared to ",wktwo,".txt",sep=""),
                quote = F,
                row.names = F)
    
    #Now plot the rate ratios, by weekday
    ggplot() + 
        geom_boxplot(data=week2week[,c("Weekday","RateRatio")], aes(x=Weekday, y=RateRatio), fill="#4271AE", alpha=0.5, outlier.size=NA) + #Avoid duplicate outlier plotting
        geom_point(data=week2week, aes(x=Weekday, y=RateRatio, color=factor(Year)), alpha=1, size=3) +
        geom_hline(yintercept = mean(week2week$RateRatio,na.rm=T)) + 
        geom_hline(yintercept = c(mean(week2week$RateRatio,na.rm=T)+1.96*sd(week2week$RateRatio,na.rm=T),
                                  mean(week2week$RateRatio,na.rm=T)-1.96*sd(week2week$RateRatio,na.rm=T)),
                   linetype=3) + 
        xlab("Weekday") +
        ylab(paste("Rate Ratio (Sz incidence in ",wkone," vs ",wktwo,")",sep="")) +
        ggtitle(paste("Boxplot for seizure Rate Ratios comparing ",wkone," to ",wktwo," over ",min(year(Sz08to16$datetime))," to ",max(year(Sz08to16$datetime)),sep="")) + 
        theme_bw() + 
        theme(legend.title = element_blank())
    #The above demonstrates pretty extreme outliers (particularly in the first full year...possibly bias from high-documentation rates and low population counts)
    # -Seems reasonable to remove those beyond 3 SD (particularly for the case of the whole-year-as-baseline comparisons)
    week2week <- week2week[which(week2week$RateRatio > (mean(week2week$RateRatio)-3*sd(week2week$RateRatio)) & week2week$RateRatio < (mean(week2week$RateRatio)+3*sd(week2week$RateRatio))),]
    
    #Now plot the rate ratios again with extreme outliers removed
    ggplot() + 
        geom_boxplot(data=week2week[,c("Weekday","RateRatio")], aes(x=Weekday, y=RateRatio), fill="#4271AE", alpha=0.5, outlier.size=NA) + #Avoid duplicate outlier plotting
        geom_point(data=week2week, aes(x=Weekday, y=RateRatio, color=factor(Year)), alpha=1, size=3) +
        geom_hline(yintercept = mean(week2week$RateRatio,na.rm=T)) + 
        geom_hline(yintercept = c(mean(week2week$RateRatio,na.rm=T)+1.96*sd(week2week$RateRatio,na.rm=T),
                                  mean(week2week$RateRatio,na.rm=T)-1.96*sd(week2week$RateRatio,na.rm=T)),
                   linetype=3) + 
        xlab("Weekday") +
        ylab(paste("Rate Ratio (Sz incidence in ",wkone," vs ",wktwo,")",sep="")) +
        ggtitle(paste("Boxplot for seizure Rate Ratios comparing ",wkone," to ",wktwo," over ",min(year(Sz08to16$datetime))," to ",max(year(Sz08to16$datetime)),sep="")) + 
        theme_bw() + 
        theme(legend.title = element_blank())
    
    png(paste("Rate Ratios comparing ",wkone," and ",wktwo," over ",min(year(Sz08to16$datetime))," to ",max(year(Sz08to16$datetime)),".png",sep=""), 
        width = 9, 
        height = 6, 
        units = 'in', 
        bg = "transparent", 
        res = 300)
    print(ggplot() + 
        geom_boxplot(data=week2week[,c("Weekday","RateRatio")], aes(x=Weekday, y=RateRatio), fill="#4271AE", alpha=0.5, outlier.size=NA) + #Avoid duplicate outlier plotting
        geom_point(data=week2week, aes(x=Weekday, y=RateRatio, color=factor(Year)), alpha=1, size=3) +
        geom_hline(yintercept = mean(week2week$RateRatio,na.rm=T)) + 
        geom_hline(yintercept = c(mean(week2week$RateRatio,na.rm=T)+1.96*sd(week2week$RateRatio,na.rm=T),
                                  mean(week2week$RateRatio,na.rm=T)-1.96*sd(week2week$RateRatio,na.rm=T)),
                   linetype=3) + 
        xlab("Weekday") +
        ylab(paste("Rate Ratio (Sz incidence in ",wkone," vs ",wktwo,")",sep="")) +
        ggtitle(paste("Boxplot for seizure Rate Ratios comparing ",wkone," to ",wktwo," over ",min(year(Sz08to16$datetime))," to ",max(year(Sz08to16$datetime)),sep="")) + 
        theme_bw() + 
        theme(legend.title = element_blank()))
    dev.off()
    
    firstdf <- data.frame("Week"=character(),
                          "Weekday"=character(),
                          "Mean_Sz_count"=numeric(),
                          "sd"=numeric(),
                          "se"=numeric(),
                          stringsAsFactors = F)
    seconddf <- data.frame("Week"=character(),
                           "Weekday"=character(),
                           "Mean_Sz_count"=numeric(),
                           "sd"=numeric(),
                           "se"=numeric(),
                           stringsAsFactors = F)
    sigdf <- data.frame("Weekday"=character(),
                        "p"=numeric(),
                        "p.signif"=character(),
                        stringsAsFactors = F)
    
    index=1
    for(i in list) {
        firstdf[index,"Week"] <- wkone
        firstdf[index,"Weekday"] <- i
        firstdf[index,"Mean_Sz_count"] <- mean(table(as.Date(firstweek[which(firstweek$wkday == i),"datetime"],'America/Los_Angeles')))
        firstdf[index,"sd"] <- sd(table(as.Date(firstweek[which(firstweek$wkday == i),"datetime"],'America/Los_Angeles')))
        firstdf[index,"se"] <- sd(table(as.Date(firstweek[which(firstweek$wkday == i),"datetime"],'America/Los_Angeles')))/sqrt(table(firstweek$wkday)[[i]])
        
        seconddf[index,"Week"] <- wktwo
        seconddf[index,"Weekday"] <- i
        seconddf[index,"Mean_Sz_count"] <- mean(table(as.Date(secondweek[which(secondweek$wkday == i),"datetime"],'America/Los_Angeles')))
        seconddf[index,"sd"] <- sd(table(as.Date(secondweek[which(secondweek$wkday == i),"datetime"],'America/Los_Angeles')))
        seconddf[index,"se"] <- sd(table(as.Date(firstweek[which(firstweek$wkday == i),"datetime"],'America/Los_Angeles')))/sqrt(table(secondweek$wkday)[[i]])
        
        sigdf[index,"Weekday"] <- i
        sigdf[index,"p"] <- round(t.test(table(as.Date(firstweek[which(firstweek$wkday == i),"datetime"],'America/Los_Angeles')),
                                         table(as.Date(secondweek[which(secondweek$wkday == i),"datetime"],'America/Los_Angeles')))[["p.value"]],4)
        if(sigdf[index,"p"]<0.05 & sigdf[index,"p"]>0.01) {
            sigdf[index,"p.signif"] <- "*"
        } else if(sigdf[index,"p"]<0.01 & sigdf[index,"p"]>0.001) {
            sigdf[index,"p.signif"] <- "**"
        } else if(sigdf[index,"p"]<0.001) {
            sigdf[index,"p.signif"] <- "***"
        } else {
            sigdf[index,"p.signif"] <- "ns"
        }
        
        index=index+1
    }
    firstdf$Weekday <- factor(firstdf$Weekday, levels = firstdf$Weekday) #ensures weekdays stay in order Sun-Sat
    seconddf$Weekday <- factor(seconddf$Weekday, levels = seconddf$Weekday) #ensures weekdays stay in order Sun-Sat
    comparedf <- rbind(firstdf,seconddf)
    
    #To add significance markers can try method here: https://www.r-bloggers.com/add-p-values-and-significance-levels-to-ggplots/
    #library(ggpubr)
    
    require(ggplot2)
    png(paste("Comparison between ",wkone," and ",wktwo,".png",sep=""), 
        width = 9, 
        height = 6, 
        units = 'in', 
        bg = "transparent", 
        res = 300)
    print(ggplot(comparedf, aes(x=Weekday, y=Mean_Sz_count, fill=Week)) + 
        geom_bar(position=position_dodge(), stat="identity",
                 colour="black", # Use black outlines,
                 size=.3) +      # Thinner lines
        #stat_compare_means(aes(group = Week), label = "p.signif", label.y = 300)
        geom_errorbar(aes(ymin=Mean_Sz_count-se, ymax=Mean_Sz_count+se),
                      size=.3,    # Thinner lines
                      width=.2,
                      position=position_dodge(.9)) +
        xlab("Weekday") +
        ylab("Number of seizures (± SEM)") +
        scale_fill_hue(name=paste(wkone,"vs",wktwo), # Legend label, use darker colors
                       breaks=c(wkone, wktwo),
                       labels=c(wkone, wktwo)) +
        ggtitle("Comparison of seizures on a given weekday") +
        scale_y_continuous(breaks=0:500*100) +
        theme_bw())
    dev.off()
    
    print(sigdf)
    write.table(sigdf,file=paste("T-tests between ",wkone," and ",wktwo,".txt",sep=""),quote = F,row.names = F)
    
    ###Could add Rate Ratio stuff here, based on denominator work from weekly comparisons
}
```
  
Compare DST to non-DST
```{r DST to non-DST, echo=FALSE}
compareweekdays(firstweek=Sz08to16wkofDST,
                secondweek=Sz08to16notDST,
                wkone="week of DST",
                wktwo="all non DST")
```
  
Compare DST to pre-DST
```{r DST to pre-DST, echo=FALSE}
compareweekdays(firstweek=Sz08to16wkofDST,
                secondweek=Sz08to16wkpreDST,
                wkone="week of DST",
                wktwo="preDST week")
```
  
Compare DST to the week post-DST week
```{r DST to pre-DST, echo=FALSE}
compareweekdays(firstweek=Sz08to16wkofDST,
                secondweek=Sz08to16wkpostDST,
                wkone="week of DST",
                wktwo="week after DST week")
```
  
Compare DST to ST
```{r DST to ST, echo=FALSE}
compareweekdays(firstweek=Sz08to16wkofDST,
                secondweek=Sz08to16wkofST,
                wkone="week of DST",
                wktwo="ST start week")
```
  
Compare ST to pre-ST
```{r DST to ST, echo=FALSE}
compareweekdays(firstweek=Sz08to16wkofST,
                secondweek=Sz08to16wkpreST,
                wkone="week of ST",
                wktwo="preST week")
```
  
Compare ST to the week post-ST week
```{r DST to ST, echo=FALSE}
compareweekdays(firstweek=Sz08to16wkofST,
                secondweek=Sz08to16wkpostST,
                wkone="week of ST",
                wktwo="week after ST week")
```
  
  
Visual demonstration of seizure rates registered to the DST time period
```{r daily seizure rates graph, echo=FALSE}
Sz4timeplot <- Sz08to16[,c("datetime","DSTday","STday")]
Sz4timeplot$time0 <- yday(Sz08to16$datetime) - Sz08to16$DSTday
summary(Sz4timeplot) #things are now registered to DST's Sunday as t=0
Sz4timeplot$year <- year(Sz08to16$datetime)

table(Sz4timeplot$time0) #Shows that the extreme tails are undersampled (due to variability in onset/offset of DST)...hence usage of SEM
yearlist <- c(min(year(Sz08to16$datetime)):max(year(Sz08to16$datetime))) #Bound years by the bounds of the dataset
CountsByYear <- data.frame("Index"=seq(min(Sz4timeplot$time0),max(Sz4timeplot$time0),1))
colID <- 2
for(i in yearlist) {
    yearlyCount <- Sz4timeplot[which(year(Sz4timeplot$datetime) == i),"time0"]
    table(yearlyCount)
    CountsByYear <- merge.data.frame(CountsByYear,as.data.frame(t(table(yearlyCount)))[,2:3],by.x="Index",by.y="yearlyCount",all.x = T)
    names(CountsByYear)[colID] <- i
    colID <- colID+1
}
fromcol <- grep(min(year(Sz08to16$datetime)), colnames(CountsByYear))
tocol <- grep(max(year(Sz08to16$datetime)), colnames(CountsByYear))
CountsByYear <- cbind(CountsByYear,
                      Mean=apply(CountsByYear[,fromcol:tocol],1,mean,na.rm=T),
                      SD=apply(CountsByYear[,fromcol:tocol],1,sd,na.rm=T))
for(i in 1:nrow(CountsByYear)) {
    CountsByYear[i,"SEM"] <- CountsByYear[i,"SD"]/sqrt(sum(!is.na(CountsByYear[i,fromcol:tocol])))
}
TallCount <- data.frame("Index"=numeric(),
                        "SzCount"=numeric(),
                        "Year"=numeric())
for(i in yearlist) {
    FORtall <- CountsByYear[,c("Index",i)]
    names(FORtall)[2] <- "SzCount"
    FORtall$Year <- i
    TallCount <- rbind(TallCount,FORtall)
}
#CountsByYear$Mean <- rowMeans(CountsByYear[,fromcol:tocol], na.rm=T)
#SDtemp <- transform(CountsByYear[,fromcol:tocol], SD=apply(CountsByYear[,fromcol:tocol],1,sd,na.rm=T))

png("Yearly trend.png", 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
print(ggplot(CountsByYear, aes(x=Index,y=Mean)) + 
    stat_smooth(method="loess", span=7/365, se=TRUE, alpha=0.3) + #using loess smoothing with proportional smoothing from 7 out of 365 days
    geom_vline(xintercept=c(0,7,237,244)) + 
    annotate("rect", xmin=7, xmax=237, ymin=225, ymax=Inf, alpha=0.2, fill="yellow") + 
    annotate("rect", xmin=0, xmax=7, ymin=225, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=237, xmax=244, ymin=225, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Day of the year (indexed to DST transition)") +
    ylab("Seizure counts per day (mean ± SEM)") +
    ggtitle(paste("Yearly seizure trends over the period from",min(year(Sz08to16$datetime)),"to",max(year(Sz08to16$datetime)))) +
    theme_bw())
dev.off()

ggplot(CountsByYear, aes(x=Index,y=Mean)) + 
    stat_smooth(method="loess", span=7/365, se=TRUE, alpha=0.3) + #using loess smoothing with proportional smoothing from 7 out of 365 days
    geom_vline(xintercept=c(0,7,237,244)) + 
    annotate("rect", xmin=7, xmax=237, ymin=225, ymax=Inf, alpha=0.2, fill="yellow") + 
    annotate("rect", xmin=0, xmax=7, ymin=225, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=237, xmax=244, ymin=225, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Day of the year (indexed to DST transition)") +
    ylab("Seizure counts per day (mean ± SEM)") +
    ggtitle(paste("Yearly seizure trends over the period from",min(year(Sz08to16$datetime)),"to",max(year(Sz08to16$datetime)))) +
    theme_bw()

###May consider making CountsByYear a tall matrix and then coloring by year using methods from http://ggplot2.tidyverse.org/reference/geom_smooth.html
#library(RColorBrewer)
png("Yearly trend_with points.png", 
    width = 9, 
    height = 6, 
    units = 'in', 
    bg = "transparent", 
    res = 300)
print(ggplot(TallCount, aes(x=Index,y=SzCount,color=Year)) + 
      geom_point() + 
      #scale_x_continuous(breaks = c(cat(yearlist,sep=","))) + 
      #scale_color_brewer(breaks = c(cat(paste(shQuote(yearlist,type="cmd"),collapse=","))),
      #scale_color_brewer(breaks = c(cat(yearlist,sep=",")), palette="Set3") + #http://www.sthda.com/english/wiki/ggplot2-colors-how-to-change-colors-automatically-and-manually
      geom_smooth(method="loess", span=7/365, se=TRUE, alpha=0.3, colour="red") + 
      geom_vline(xintercept=c(0,7,237,244)) + 
      annotate("rect", xmin=0, xmax=7, ymin=0, ymax=Inf, alpha=0.2, fill="red") + 
      annotate("rect", xmin=237, xmax=244, ymin=0, ymax=Inf, alpha=0.2, fill="green") + 
      xlab("Day of the year (indexed to DST transition)") +
      ylab("Seizure counts per day (mean ± SEM)") +
      ggtitle(paste("Yearly seizure trends over the period from",min(year(Sz08to16$datetime)),"to",max(year(Sz08to16$datetime)))) + 
      ylim(0,quantile(TallCount$SzCount, 0.99, na.rm=T)[[1]]) + 
      theme_bw())
dev.off()

ggplot(TallCount, aes(x=Index,y=SzCount,color=Year)) + 
    geom_point() + 
    #scale_x_continuous(breaks = c(cat(yearlist,sep=","))) + 
    #scale_color_brewer(breaks = c(cat(paste(shQuote(yearlist,type="cmd"),collapse=","))),
    #scale_color_brewer(breaks = c(cat(yearlist,sep=",")), palette="Set3") + #http://www.sthda.com/english/wiki/ggplot2-colors-how-to-change-colors-automatically-and-manually
    geom_smooth(method="loess", span=7/365, se=TRUE, alpha=0.3, colour="red") + 
    geom_vline(xintercept=c(0,7,237,244)) + 
    annotate("rect", xmin=0, xmax=7, ymin=0, ymax=Inf, alpha=0.2, fill="red") + 
    annotate("rect", xmin=237, xmax=244, ymin=0, ymax=Inf, alpha=0.2, fill="green") + 
    xlab("Day of the year (indexed to DST transition)") +
    ylab("Seizure counts per day (mean ± SEM)") +
    ggtitle(paste("Yearly seizure trends over the period from",min(year(Sz08to16$datetime)),"to",max(year(Sz08to16$datetime)))) + 
    ylim(0,quantile(TallCount$SzCount, 0.99, na.rm=T)[[1]]) + 
    theme_bw()
```
  
Weekly comparisons
```{r weekly comparisons}
#Find out what week DST is in, register to that then calculate
#If wanting to do comparison to the every-non-DST-week baseline, then second week must be Sz08to16nonDST/"all non DST"
compareweeks <- function(firstweek=Sz08to16wkofDST,
                         secondweek=Sz08to16notDST,
                         wkone="week of DST",
                         wktwo="all non DST") {
    
    #Get seizure counts for the week in DST
    #-this allows for independent t-tests (albeit suboptimal compared to paired t-tests)
    DSTweekCount <- as.data.frame(table(year(firstweek$datetime)))
    
    if(identical(secondweek,Sz08to16notDST)) { #For the all-non-DST-weeks-as-baseline comparison
        #Get seizure counts for week(s) not in DST
        NONweekdf <- secondweek[,c("datetime","weeknum","DSTweek")]
        NONweekdf <- NONweekdf[-which(NONweekdf$weeknum == NONweekdf$DSTweek),] #ensures no DST-week counts are included
        NONweekdf$year <- year(NONweekdf$datetime)
        table(NONweekdf$weeknum,NONweekdf$year)
        NONweekCount <- as.data.frame(table(NONweekdf$weeknum,NONweekdf$year))
        NONweekCount[NONweekCount == 0] <- NA #replace non-existing weeks (e.g. year without the 53rd week, DST)
        
        #T-tests (x is for week of DST, y is for comparison week(s)):
        print(t.test(DSTweekCount$Freq,NONweekCount$Freq))
    
        NON4gg <- NONweekCount[,2:3]
        names(NON4gg) <- c("Year","Freq")
        NON4gg$Year <- as.factor(NON4gg$Year)
        DST4gg <- DSTweekCount
        names(DST4gg) <- c("Year","Freq")
        DST4gg$Year <- as.factor(DST4gg$Year)
        
        #Plot it
        ggplot() + 
            geom_jitter(data=NON4gg, aes(x=Year,y=Freq), position=position_jitter(width=0.05), alpha=0.8) + #Outliers from incomplete weeks
            geom_boxplot(data=NON4gg, aes(x=Year,y=Freq), fill="#4271AE", alpha=0.5, outlier.size=NA) + #Outliers from incomplete weeks
            geom_point(data=DST4gg, aes(x=Year,y=Freq), color="red", size=4, shape=18) + 
            xlab("Year") +
            ylab("Seizure Counts (per week)") +
            ggtitle(paste("Percentile for ",wkone," seizure counts, per week from ",min(year(Sz08to16$datetime))," to ",max(year(Sz08to16$datetime)),sep="")) + 
            theme_bw()
        
        png(paste("Percentile for ",wkone," seizure counts, per week from ",min(year(Sz08to16$datetime))," to ",max(year(Sz08to16$datetime)),".png",sep=""), 
            width = 9, 
            height = 6, 
            units = 'in', 
            bg = "transparent", 
            res = 300)
        print(ggplot() + 
            geom_jitter(data=NON4gg, aes(x=Year,y=Freq), position=position_jitter(width=0.05), alpha=0.8) + #Outliers from incomplete weeks
            geom_boxplot(data=NON4gg, aes(x=Year,y=Freq), fill="#4271AE", alpha=0.5, outlier.size=NA) + #Outliers from incomplete weeks
            geom_point(data=DST4gg, aes(x=Year,y=Freq), color="red", size=4, shape=18) + 
            xlab("Year") +
            ylab("Seizure Counts (per week)") +
            ggtitle(paste("Percentile for ",wkone," seizure counts, per week from ",min(year(Sz08to16$datetime))," to ",max(year(Sz08to16$datetime)),sep=""))) + 
            theme_bw()
        dev.off()
        
        #Make Z-score comparison
        Zweek <- data.frame("Year"=numeric(),
                            "PopMean"=numeric(),
                            "PopSD"=numeric(),
                            "SzCount"=numeric(),
                            "Zscore"=numeric(),
                            "Percentile"=numeric())
        counter=1
        for(i in min(year(Sz08to16$datetime)):max(year(Sz08to16$datetime))) {
            Zweek[counter,"Year"] <- i
            Zweek[counter,"PopMean"] <- mean(na.omit(NONweekCount[which(NONweekCount$Var2 == i),"Freq"]))
            Zweek[counter,"PopSD"] <- sd(na.omit(NONweekCount[which(NONweekCount$Var2 == i),"Freq"]))
            Zweek[counter,"SzCount"] <- DSTweekCount[which(DSTweekCount$Var1 == i),"Freq"]
            Zweek[counter,"Zscore"] <- (Zweek[counter,"SzCount"]-Zweek[counter,"PopMean"])/Zweek[counter,"PopSD"]
            Zweek[counter,"Percentile"] <- round(pnorm(Zweek[counter,"Zscore"])*100,2)
            counter=counter+1
        }
        write.table(Zweek,
                    file = paste("Yearly percentiles by week ",wkone,".txt",sep=""),
                    quote = F,
                    row.names = F)
        Zweek$Year <- as.factor(Zweek$Year)
        #library(ggplot2)

        ggplot(Zweek[,c("Year","Percentile")], aes(x=Year, y=Percentile)) + 
            geom_bar(position=position_dodge(), stat="identity",
                     colour="black", # Use black outlines,
                     size=.3) +      # Thinner lines
            geom_hline(yintercept = mean(Zweek$Percentile)) + 
            geom_hline(yintercept = c(mean(Zweek$Percentile)+sd(Zweek$Percentile),
                                      mean(Zweek$Percentile)-sd(Zweek$Percentile)),
                       linetype=3) + 
            xlab("Year") +
            ylab("Percentile") +
            ggtitle(paste("Percentile of seizure counts for ",wkone," per week from ",min(year(Sz08to16$datetime))," to ",max(year(Sz08to16$datetime)),sep="")) +
            scale_y_continuous(breaks=0:100*10, limits=c(0,100)) +
            theme_bw()
        png(paste("Percentile of seizure counts for ",wkone," per week from ",min(year(Sz08to16$datetime))," to ",max(year(Sz08to16$datetime)),".png",sep=""), 
            width = 9, 
            height = 6, 
            units = 'in', 
            bg = "transparent", 
            res = 300)
        print(ggplot(Zweek[,c("Year","Percentile")], aes(x=Year, y=Percentile)) + 
            geom_bar(position=position_dodge(), stat="identity",
                     colour="black", # Use black outlines,
                     size=.3) +      # Thinner lines
            geom_hline(yintercept = mean(Zweek$Percentile)) + 
            geom_hline(yintercept = c(mean(Zweek$Percentile)+sd(Zweek$Percentile),
                                      mean(Zweek$Percentile)-sd(Zweek$Percentile)),
                       linetype=3) + 
            xlab("Year") +
            ylab("Percentile") +
            ggtitle(paste("Percentile of seizure counts for ",wkone," per week from ",min(year(Sz08to16$datetime))," to ",max(year(Sz08to16$datetime)),sep="")) +
            scale_y_continuous(breaks=0:100*10, limits=c(0,100)) +
            theme_bw())
        dev.off()
        
        for(i in min(year(Sz08to16$datetime)):max(year(Sz08to16$datetime))) {
            #Subsetting for the year of interest
            thisyear <- Sz08to16[which(year(Sz08to16$datetime) == i),]
            firstyear <- firstweek[which(year(firstweek$datetime) == i),]
            secondyear <- secondweek[which(year(secondweek$datetime) == i),]
            
            #Try using denominator estimated by number of individuals recording through the end of the period of interest
            firstdenomdf <- Sz08to16[which(Sz08to16$datetime <= as.Date(max(firstyear$datetime),'America/Los_Angeles')),"Unlinked_ID"]
            firstdenom <- length(unique(firstdenomdf))
            baselineweeklist <- na.omit(NONweekCount[which(NONweekCount$Var2 == i),"Var1"])
            
            #Have to do this for each week in the baseline (NON DST) period
            for (j in baselineweeklist) {
                weeksend <- max(as.Date(secondyear[which(week(secondyear$datetime) == as.numeric(j)),"datetime"],'America/Los_Angeles'))
                seconddenomdf <- Sz08to16[which(as.Date(Sz08to16$datetime,'America/Los_Angeles') <= weeksend),"Unlinked_ID"]
                seconddenom <- length(unique(seconddenomdf))
                NONweekCount[which(NONweekCount$Var1 == as.numeric(j) & NONweekCount$Var2 == i),"AtRisk"] <- seconddenom
                NONweekCount[which(NONweekCount$Var1 == as.numeric(j) & NONweekCount$Var2 == i),"Incidence"] <- NONweekCount[which(NONweekCount$Var1 == as.numeric(j) & NONweekCount$Var2 == i),"Freq"]/seconddenom
            }
            NONweekCount[which(NONweekCount$Var2 == i),"DSTFreq"] <- DSTweekCount[which(DSTweekCount$Var1 == i),"Freq"]
            NONweekCount[which(NONweekCount$Var2 == i),"DSTAtRisk"] <- firstdenom
            NONweekCount[which(NONweekCount$Var2 == i),"DSTIncidence"] <- DSTweekCount[which(DSTweekCount$Var1 == i),"Freq"]/firstdenom
            NONweekCount$RateRatio <- NONweekCount$DSTIncidence/NONweekCount$Incidence
            
        }
        
        ggplot() + 
            geom_jitter(data=NONweekCount, aes(x=Var2,y=RateRatio), position=position_jitter(width=0.05), alpha=0.8) + #Outliers from incomplete weeks
            geom_boxplot(data=NONweekCount, aes(x=Var2,y=RateRatio), fill="#4271AE", alpha=0.5, outlier.size=NA) + #Outliers from incomplete weeks
            xlab("Year") +
            ylab(paste("Rate Ratios (",wkone," vs each week of the year)",sep="")) +
            ggtitle(paste("Comparison of weekly seizure Rate Ratios for",wkone,min(year(Sz08to16$datetime)),"to",max(year(Sz08to16$datetime)),sep=" ")) + 
            geom_hline(yintercept = mean(NONweekCount$RateRatio,na.rm=T)) + 
            geom_hline(yintercept = c(mean(NONweekCount$RateRatio,na.rm=T)+1.96*sd(NONweekCount$RateRatio,na.rm=T),
                                      mean(NONweekCount$RateRatio,na.rm=T)-1.96*sd(NONweekCount$RateRatio,na.rm=T)),
                       linetype=3) + 
            ylim((mean(NONweekCount$RateRatio,na.rm=T)-2*sd(NONweekCount$RateRatio,na.rm=T)),(mean(NONweekCount$RateRatio,na.rm=T)+2*sd(NONweekCount$RateRatio,na.rm=T))) + 
            theme_bw()
        
        #Those outliers look quite spurious, so cutting them out at the >3SD threshold and comparing again
        NONweek4gg <- NONweekCount[which(NONweekCount$RateRatio < (mean(NONweekCount$RateRatio,na.rm=T)+3*sd(NONweekCount$RateRatio,na.rm=T)) & NONweekCount$RateRatio > (mean(NONweekCount$RateRatio,na.rm=T)-3*sd(NONweekCount$RateRatio,na.rm=T))),]
        
        ggplot() + 
            geom_jitter(data=NONweek4gg, aes(x=Var2,y=RateRatio), position=position_jitter(width=0.05), alpha=0.8) + #Outliers from incomplete weeks
            geom_boxplot(data=NONweek4gg, aes(x=Var2,y=RateRatio), fill="#4271AE", alpha=0.5, outlier.size=NA) + #Outliers from incomplete weeks
            xlab("Year") +
            ylab(paste("Rate Ratios (",wkone," vs each week of the year)",sep="")) +
            ggtitle(paste("Comparison of weekly seizure Rate Ratios for",wkone,min(year(Sz08to16$datetime)),"to",max(year(Sz08to16$datetime)),sep=" ")) + 
            geom_hline(yintercept = mean(NONweek4gg$RateRatio,na.rm=T)) + 
            geom_hline(yintercept = c(mean(NONweek4gg$RateRatio,na.rm=T)+1.96*sd(NONweek4gg$RateRatio,na.rm=T),
                                      mean(NONweek4gg$RateRatio,na.rm=T)-1.96*sd(NONweek4gg$RateRatio,na.rm=T)),
                       linetype=3) + 
            theme_bw()
        png(paste("Comparison of weekly seizure Rate Ratios for ",wkone," from ",min(year(Sz08to16$datetime))," to ",max(year(Sz08to16$datetime)),".png",sep=""), 
            width = 9, 
            height = 6, 
            units = 'in', 
            bg = "transparent", 
            res = 300)
        print(ggplot() + 
            geom_jitter(data=NONweek4gg, aes(x=Var2,y=RateRatio), position=position_jitter(width=0.05), alpha=0.8) + #Outliers from incomplete weeks
            geom_boxplot(data=NONweek4gg, aes(x=Var2,y=RateRatio), fill="#4271AE", alpha=0.5, outlier.size=NA) + #Outliers from incomplete weeks
            xlab("Year") +
            ylab(paste("Rate Ratios (",wkone," vs each week of the year)",sep="")) +
            ggtitle(paste("Comparison of weekly seizure Rate Ratios for",wkone,min(year(Sz08to16$datetime)),"to",max(year(Sz08to16$datetime)),sep=" ")) + 
            geom_hline(yintercept = mean(NONweek4gg$RateRatio,na.rm=T)) + 
            geom_hline(yintercept = c(mean(NONweek4gg$RateRatio,na.rm=T)+1.96*sd(NONweek4gg$RateRatio,na.rm=T),
                                      mean(NONweek4gg$RateRatio,na.rm=T)-1.96*sd(NONweek4gg$RateRatio,na.rm=T)),
                       linetype=3)) + 
            theme_bw()
        dev.off()
        
        names(NONweekCount) <- c("WeekOfYear","Year","Freq","AtRisk","Incidence","DSTFreq","DSTAtRisk","DSTIncidence","RiskRatio")
        write.table(NONweekCount,
                    file="Rate Ratios for each week.txt",
                    quote = F,
                    row.names = F)
        
        
    } else { #For the single-week-as-baseline comparisons
        #Get seizure counts for weeks not in DST
        NONweekCount <- as.data.frame(table(year(secondweek$datetime)))
        
        #T-tests (x is for week of DST, y is for comparison week(s)):
        print(t.test(DSTweekCount$Freq,NONweekCount$Freq))
        
        week2week <- data.frame("Year"=numeric(),
                                "DSTSzcount"=numeric(),
                                "DSTatrisk"=numeric(),
                                "DSTincidence"=numeric(),
                                "NONSzcount"=numeric(),
                                "NONatrisk"=numeric(),
                                "NONincidence"=numeric(),
                                "RateRatio"=numeric())
        counter=1
        for(i in min(year(Sz08to16$datetime)):max(year(Sz08to16$datetime))) {
            #Subsetting for the year of interest
            thisyear <- Sz08to16[which(year(Sz08to16$datetime) == i),]
            firstyear <- firstweek[which(year(firstweek$datetime) == i),]
            secondyear <- secondweek[which(year(secondweek$datetime) == i),]
            
            #Try using denominator estimated by number of individuals recording through the end of the period of interest
            firstdenomdf <- Sz08to16[which(Sz08to16$datetime <= as.Date(max(firstyear$datetime),'America/Los_Angeles')),"Unlinked_ID"]
            firstdenom <- length(unique(firstdenomdf))
            seconddenomdf <- Sz08to16[which(Sz08to16$datetime <= as.Date(max(secondyear$datetime),'America/Los_Angeles')),"Unlinked_ID"]
            seconddenom <- length(unique(seconddenomdf))
            print(paste("Rough estimate of difference in 'at risk' individuals: ",abs(firstdenom-seconddenom),"; with ",firstdenom," accumulated individuals by DST week of ",i,sep=""))
            
            week2week[counter,"Year"] <- i
            week2week[counter,"DSTSzcount"] <- DSTweekCount[which(DSTweekCount$Var1 == i),"Freq"]
            week2week[counter,"DSTatrisk"] <- firstdenom
            week2week[counter,"DSTincidence"] <- week2week[counter,"DSTSzcount"]/week2week[counter,"DSTatrisk"]
            week2week[counter,"NONSzcount"] <- NONweekCount[which(NONweekCount$Var1 == i),"Freq"]
            week2week[counter,"NONatrisk"] <- seconddenom
            week2week[counter,"NONincidence"] <- week2week[counter,"NONSzcount"]/week2week[counter,"NONatrisk"]
            week2week[counter,"RateRatio"] <- week2week[counter,"DSTincidence"]/week2week[counter,"NONincidence"]
            counter=counter+1
            
        }
        write.table(week2week,
                    file=paste("Seizure Rate Ratios for ",wkone," compared to ",wktwo,".txt",sep=""),
                    quote = F,
                    row.names = F)
        week2week$Year <- as.factor(week2week$Year)
        
        #Now plot the rate ratios, by year
        ggplot(week2week[,c("Year","RateRatio")], aes(x=Year, y=RateRatio)) + 
            #IF WANT AS HISTOGRAM:
            #geom_bar(position=position_dodge(), stat="identity",
            #         colour="black", # Use black outlines,
            #         size=.3) +      # Thinner lines
            geom_point(size=5, color="turquoise4") + 
            geom_hline(yintercept = mean(week2week$RateRatio)) + 
            geom_hline(yintercept = c(mean(week2week$RateRatio)+1.96*sd(week2week$RateRatio),
                                      mean(week2week$RateRatio)-1.96*sd(week2week$RateRatio)),
                       linetype=3) + 
            scale_y_continuous(limits = c(0.5,1.5)) + 
            xlab("Year") +
            ylab("Rate Ratio") +
            ggtitle(paste(wkone,"vs",wktwo,"Rate Ratios from",min(year(Sz08to16$datetime)),"to",max(year(Sz08to16$datetime)))) +
            theme_bw()
        png(paste(wkone," vs ",wktwo," Rate Ratios from ",min(year(Sz08to16$datetime))," to ",max(year(Sz08to16$datetime)),".png",sep=""), 
            width = 9, 
            height = 6, 
            units = 'in', 
            bg = "transparent", 
            res = 300)
        print(ggplot(week2week[,c("Year","RateRatio")], aes(x=Year, y=RateRatio)) + 
            #IF WANT AS HISTOGRAM:
            #geom_bar(position=position_dodge(), stat="identity",
            #         colour="black", # Use black outlines,
            #         size=.3) +      # Thinner lines
            geom_point(size=5, color="turquoise4") + 
            geom_hline(yintercept = mean(week2week$RateRatio)) + 
            geom_hline(yintercept = c(mean(week2week$RateRatio)+1.96*sd(week2week$RateRatio),
                                      mean(week2week$RateRatio)-1.96*sd(week2week$RateRatio)),
                       linetype=3) + 
            scale_y_continuous(limits = c(0.5,1.5)) + 
            xlab("Year") +
            ylab("Rate Ratio") +
            ggtitle(paste(wkone,"vs",wktwo,"Rate Ratios from",min(year(Sz08to16$datetime)),"to",max(year(Sz08to16$datetime)))) +
            theme_bw())
        dev.off()
    }
}
```
  
Compare DST to non-DST
```{r DST to non-DST, echo=FALSE}
compareweeks(firstweek=Sz08to16wkofDST,
             secondweek=Sz08to16notDST,
             wkone="week of DST",
             wktwo="all non DST")
```
  
Compare DST to pre-DST
```{r DST to pre-DST, echo=FALSE}
compareweeks(firstweek=Sz08to16wkofDST,
             secondweek=Sz08to16wkpreDST,
             wkone="week of DST",
             wktwo="preDST week")
```
  
Compare DST to the week post-DST week
```{r DST to pre-DST, echo=FALSE}
compareweeks(firstweek=Sz08to16wkofDST,
             secondweek=Sz08to16wkpostDST,
             wkone="week of DST",
             wktwo="week after DST week")
```
  
Compare DST to ST
```{r DST to ST, echo=FALSE}
compareweeks(firstweek=Sz08to16wkofDST,
             secondweek=Sz08to16wkofST,
             wkone="week of DST",
             wktwo="ST start week")
```
  
Compare ST to pre-ST
```{r DST to ST, echo=FALSE}
compareweeks(firstweek=Sz08to16wkofST,
             secondweek=Sz08to16wkpreST,
             wkone="week of ST",
             wktwo="preST week")
```
  
Compare ST to the week post-ST week
```{r DST to ST, echo=FALSE}
compareweeks(firstweek=Sz08to16wkofST,
             secondweek=Sz08to16wkpostST,
             wkone="week of ST",
             wktwo="week after ST week")
```
    
  
###Scratchpad###  
#==================================#
```{r, eval=FALSE}
#-first need to determine duplicates of Sz per individual to do this
Sz08to17$IDdup <- duplicated(Sz08to17$Unlinked_ID) | duplicated(Sz08to17$Unlinked_ID, fromLast = T)
Sz08to17$datedup <- duplicated(yday(Sz08to17$datetime)) | duplicated(yday(Sz08to17$datetime), fromLast = T)
#for(i in 1:nrow(Sz08to17)) {
#    j=1
#    #check if you're in a block of ID & date duplicates that is new (the i-j comparison)
#    if(Sz08to17[i,"IDdup"] == TRUE & Sz08to17[i,"datedup"] == TRUE & i>=j) {
#        #k is used for iterating over the block
#        k=1
#        #j is used for indexing relative to blocks (so as to not reiterate with the absolute index i)
#        j=i+k
#        #will iterate over the block of duplicates while individual AND date are the same
#        #AND ONLY IF time between end of Sz j-1 and start of Sz j is <5 min
#        #the goal is to find the full span (indexed from i to j) of the "Status" event
#        while(Sz08to17[j,"Unlinked_ID"] == Sz08to17[i,"Unlinked_ID"] & as.Date(Sz08to17[j,"datetime"]) == as.Date(Sz08to17[i,"datetime"]) & (second(Sz08to17[j,"datetime"])-second(Sz08to17[j-1,"datetime"])-Sz08to17[j-1,"dur_secs"])<300) {
#            k=k+1
#            j=i+k
#        }
#        for(l in i:j) {
#            #this makes all entries for a given status event have duration from start of ith Sz to end of jth Sz
#            Sz08to17[l,"StatusYN"]<-1
#            Sz08to17[l,"Statusdur"]<-second(Sz08to17[j,"datetime"])+Sz08to17[j,"dur_secs"]-second(Sz08to17[i,"datetime"])
#        }
#    }
#}

##start after defining m
#for(l in k:k+m-2) {
#    #far more cumbersome way to do the if below: as.numeric(seconds(as.POSIXlt(ordered[k+1,"datetime"]))-seconds(as.POSIXlt(ordered[k,"datetime"]))-ordered[k,"dur_secs"])
#    #if the time between Sz is <5 min
#    if(as.numeric(difftime(ordered[k+1,"datetime"],ordered[k,"datetime"],units="secs"))-ordered[k,"dur_secs"] < 300) {
#        n <- l
#        #...set the k->p entries to Status Yes (1)
#        #...and set all to the total "status epilepticus" duration (from start of first to end of last seizure in status series)
#        for(p in n:z) {
#            #this makes all entries for a given status event have duration from start of ith Sz to end of jth Sz
#            ordered[p,"StatusYN"]<-1
#            ordered[p,"Statusdur"]<-second(ordered[j,"datetime"])+ordered[j,"dur_secs"]-second(ordered[i,"datetime"])
#        }
#    }
#}

##OR multiple Sz with inter-Sz interval <5 min with time from start to end of all Sz >5 min
##Get the dataframe into an order in which the following algorithmic Status Epilepticus checking can work (assumes seizures entered in non-temporal order)
#ordered <- Sz08to17[with(Sz08to17, order(Unlinked_ID, datetime)), ]
##run through the rows of the dataframe
#for(i in 1:nrow(ordered)) {
#    #start relative index for blocks of similar IDs
#    j <- 1
#    #if IDs are the same from current i and next entry...
#    if(ordered[i,"Unlinked_ID"] == ordered[i+1,"Unlinked_ID"] & i>=j) {
#        #...set ID block range from i to the end with j...
#        j <- rle(ordered[i:nrow(ordered),"Unlinked_ID"])$lengths[1]
#        #...then loop over the ID block
#        for(k in i:i+j-1) {
#            #if date is the same from current k and next entry (within the same ID block)...
#            if(date(ordered[k,"datetime"]) == date(ordered[k+1,"datetime"])) {
#                #...set date block range from k to second from the end with m...
#                m <- rle(as.numeric(date(ordered[k:nrow(ordered),"datetime"])))$lengths[1]
#                #...then loop over the same-date-within-same-ID block
#                SEstart <- k
#                SEend <- k
#                while(k<m) {
#                    #if the time between Sz is <5 min
#                    if(as.numeric(difftime(ordered[k+1,"datetime"],ordered[k,"datetime"],units="secs"))-ordered[k,"dur_secs"] < 300) {
#                        SEend <- k+1
#                    } else {
#                        #NOTE: this will only define new Status entries if not able to create a new SEend AND the Status did iterate previously (i.e. SEstart<SEend)
#                        #...set the SEstart->SEend entries to Status Yes (1)
#                        #...and set all to the total "status epilepticus" duration (from start of first to end of last seizure in status series)
#                        if(SEstart<SEend) {
#                            for(p in SEstart:SEend) {
#                                #this makes all entries for a given status event have duration from start of SEstart's Sz to end of SEend's Sz
#                                ordered[p,"StatusYN"]<-1
#                                ordered[p,"Statusdur"]<-as.numeric(ordered[SEend,"datetime"],ordered[SEstart,"datetime"],units="secs")+ordered[SEend,"dur_secs"]
#                            }
#                        }
#                        SEstart <- k+1
#                    }
#                    k <- k+1
#                }
#            }
#        }
#    }
#}

#Get seizure counts for each day of the week not in DST
#-this is tabulated BY DATE (i.e. all Sz on Sunday 2008-03-16)
#-this allows for independent t-tests (albeit suboptimal compared to paired t-tests)
MONnonDST <- Sz08to16notDST[which(Sz08to16notDST$wkday == "Monday"),"datetime"]
MONcounts <- table(as.Date(MONnonDST,'America/Los_Angeles'))
TUEnonDST <- Sz08to16notDST[which(Sz08to16notDST$wkday == "Tuesday"),"datetime"]
TUEcounts <- table(as.Date(TUEnonDST,'America/Los_Angeles'))
WEDnonDST <- Sz08to16notDST[which(Sz08to16notDST$wkday == "Wednesday"),"datetime"]
WEDcounts <- table(as.Date(WEDnonDST,'America/Los_Angeles'))
THUnonDST <- Sz08to16notDST[which(Sz08to16notDST$wkday == "Thursday"),"datetime"]
THUcounts <- table(as.Date(THUnonDST,'America/Los_Angeles'))
FRInonDST <- Sz08to16notDST[which(Sz08to16notDST$wkday == "Friday"),"datetime"]
FRIcounts <- table(as.Date(FRInonDST,'America/Los_Angeles'))
SATnonDST <- Sz08to16notDST[which(Sz08to16notDST$wkday == "Saturday"),"datetime"]
SATcounts <- table(as.Date(SATnonDST,'America/Los_Angeles'))
SUNnonDST <- Sz08to16notDST[which(Sz08to16notDST$wkday == "Sunday"),"datetime"]
SUNcounts <- table(as.Date(SUNnonDST,'America/Los_Angeles'))

#Get seizure counts for each day of the week in DST
#-this is tabulated BY DATE (i.e. all Sz on Sunday 2008-03-16)
MONinDST <- Sz08to16wkofDST[which(Sz08to16wkofDST$wkday == "Monday"),"datetime"]
MONcount <- table(as.Date(MONinDST,'America/Los_Angeles'))
TUEinDST <- Sz08to16wkofDST[which(Sz08to16wkofDST$wkday == "Tuesday"),"datetime"]
TUEcount <- table(as.Date(TUEinDST,'America/Los_Angeles'))
WEDinDST <- Sz08to16wkofDST[which(Sz08to16wkofDST$wkday == "Wednesday"),"datetime"]
WEDcount <- table(as.Date(WEDinDST,'America/Los_Angeles'))
THUinDST <- Sz08to16wkofDST[which(Sz08to16wkofDST$wkday == "Thursday"),"datetime"]
THUcount <- table(as.Date(THUinDST,'America/Los_Angeles'))
FRIinDST <- Sz08to16wkofDST[which(Sz08to16wkofDST$wkday == "Friday"),"datetime"]
FRIcount <- table(as.Date(FRIinDST,'America/Los_Angeles'))
SATinDST <- Sz08to16wkofDST[which(Sz08to16wkofDST$wkday == "Saturday"),"datetime"]
SATcount <- table(as.Date(SATinDST,'America/Los_Angeles'))
SUNinDST <- Sz08to16wkofDST[which(Sz08to16wkofDST$wkday == "Sunday"),"datetime"]
SUNcount <- table(as.Date(SUNinDST,'America/Los_Angeles'))

#T-tests (x is for weekdays in DST):
t.test(MONcount,MONcounts)
t.test(TUEcount,TUEcounts)
t.test(WEDcount,WEDcounts)
t.test(THUcount,THUcounts)
t.test(FRIcount,FRIcounts)
t.test(SATcount,SATcounts)
t.test(SUNcount,SUNcounts)

#Prior method for getting Rate Ratios for weekdays:
counter=1
    for(i in list) {
        weekdaydf <- grep(paste("^",substr(i,1,3),sep=""),NONnames,value=T,ignore.case=T)
        index=counter
        for(j in min(year(Sz08to16$datetime)):max(year(Sz08to16$datetime))) {
            week2week[index,"Weekday"] <- i
            week2week[index,"Year"] <- j
            week2week[index,"RateRatio"] <- l.df[[weekdaydf]][which(year(as.Date(l.df[[weekdaydf]][,"Var1"])) == j),"RateRatio"]
            index=index+1
        }
        counter=index
    }
    
```